<!-- 
  EDITOR DE RECORRIDOS - Layout Can√≥nico v2
  
  ESTRUCTURA:
  - .editor-layout: Contenedor flex column que ocupa todo el espacio disponible
  - .editor-topbar: Header del editor (position: relative, NO fixed)
  - .editor-body: Contenido principal (flex: 1, overflow: auto)
  
  REGLAS:
  - NO usar position: fixed en ning√∫n elemento
  - El topbar usa flex-shrink: 0 para mantener altura fija
  - El body usa flex: 1 para ocupar el espacio restante
-->
<div class="recorridos-editor editor-layout" id="recorridos-editor" data-recorrido-id="{{RECORRIDO_ID}}">
  <!-- Header del editor (NO fixed, forma parte del layout) -->
  <div class="editor-topbar bg-slate-800 border-b border-slate-700 px-6 py-4">
    <div class="flex justify-between items-center">
      <div class="flex items-center gap-4">
        <a href="/admin/recorridos" class="text-slate-400 hover:text-white" title="Volver al listado">‚Üê</a>
        <h1 class="text-xl font-bold text-white" id="recorrido-name">Cargando...</h1>
        <span id="publish-status-badge" class="publish-status publish-status--draft" style="display: none;"></span>
        <span id="recorrido-status" class="px-2 py-1 bg-yellow-900 text-yellow-200 rounded text-xs">Cargando...</span>
        <span id="recorrido-version" class="px-2 py-1 bg-slate-600 text-slate-200 rounded text-xs">v-</span>
      </div>
      <div class="flex items-center gap-2">
        <!-- Toggle Vista Lista/Canvas (AXE v0.6.11) -->
        <div class="flex items-center gap-2 mr-2 border-r border-slate-700 pr-2">
          <button onclick="toggleVistaCanvas()" id="toggle-vista-btn" class="px-3 py-2 bg-slate-700 hover:bg-slate-600 text-white text-sm font-medium rounded transition-colors" title="Cambiar entre Vista Canvas y Vista Lista">
            <span id="toggle-vista-label">üìã Lista</span>
          </button>
          <span id="canvas-state-badge" class="px-2 py-1 rounded text-xs font-semibold" style="display: none;" title="Estado del canvas: DERIVED (derivado), PERSISTED (guardado), DIRTY (cambios sin guardar)"></span>
        </div>
        <!-- Panel Flujo AXE (AXE v0.6.11) -->
        <div class="flex items-center gap-2 mr-2 border-r border-slate-700 pr-2">
          <span class="text-slate-400 text-sm mr-1">Flujo AXE:</span>
          <button onclick="editarRecorrido()" class="px-3 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium rounded transition-colors" title="Editar recorrido">
            ‚úèÔ∏è Editar
          </button>
          <button onclick="guardarRecorrido()" id="btn-guardar-flujo" class="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded transition-colors" title="Guardar cambios">
            üíæ Guardar
          </button>
          <button onclick="publicarRecorrido()" id="btn-publicar-flujo" class="px-3 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded transition-colors" title="Publicar recorrido">
            üöÄ Publicar
          </button>
        </div>
        <!-- Selector de Tema para Preview (AXE v5.16.0) -->
        <div class="flex items-center gap-2 mr-2 border-r border-slate-700 pr-2">
          <label for="theme-selector" class="text-slate-400 text-sm">Tema Preview:</label>
          <select id="theme-selector" onchange="cambiarTemaPreview(this.value)" class="px-3 py-2 bg-slate-700 hover:bg-slate-600 text-white text-sm rounded border border-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="auto">üîÑ Auto</option>
            <option value="light-classic">‚òÄÔ∏è Light Classic</option>
            <option value="dark-classic">üåô Dark Classic</option>
          </select>
        </div>
        <!-- Toggle Preview Panel (AXE v5.16.0) -->
        <button onclick="togglePreviewPanel()" id="toggle-preview-btn" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white font-medium rounded transition-colors" title="Mostrar/Ocultar Preview">
          üëÅÔ∏è Preview Panel
        </button>
        <!-- Botones adicionales -->
        <button onclick="validarRecorrido()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded transition-colors">
          ‚úì Validar
        </button>
        <button onclick="previewRecorrido()" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white font-medium rounded transition-colors">
          üëÅÔ∏è Preview
        </button>
      </div>
    </div>
    <div id="validation-messages" class="mt-2"></div>
  </div>
  
  <!-- Contenido principal del editor (flex: 1, scroll interno) -->
  <div class="editor-body flex">
    <!-- Vista Canvas v1 (AXE v0.6.11) - Vista por defecto -->
    <!-- AXE v0.6.9: Grid de 3 columnas: canvas (centro) + panel contextual (derecha sticky) -->
    <div id="canvas-view-container" class="flex-1 bg-slate-900 p-6" style="display: grid; grid-template-columns: 1fr 380px; gap: 16px; align-items: start;">
      <!-- Columna principal: Canvas visual -->
      <div class="canvas-main-column" style="min-width: 0;">
        <div class="max-w-7xl mx-auto">
        <!-- Warnings -->
        <div id="canvas-warnings" class="mb-4"></div>
        
        <!-- Controles Canvas -->
        <div class="bg-slate-800 rounded-lg p-4 mb-4">
          <div class="flex gap-2 flex-wrap mb-2">
            <button onclick="cargarCanvas()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded transition-colors">
              üì• Cargar Canvas
            </button>
            <button onclick="validarCanvas()" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white font-medium rounded transition-colors">
              ‚úì Validar Canvas
            </button>
            <button onclick="guardarCanvas()" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-medium rounded transition-colors">
              üíæ Guardar Canvas
            </button>
            <button onclick="convertirCanvasARecorrido()" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white font-medium rounded transition-colors">
              üîÑ Convertir a Recorrido (Preview)
            </button>
          </div>
          <!-- Acciones Estructurales -->
          <div class="flex gap-2 flex-wrap border-t border-slate-700 pt-2 mt-2">
            <span class="text-slate-300 text-sm self-center mr-2">Acciones:</span>
            <button onclick="a√±adirNodoCanvas()" class="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium rounded transition-colors">
              ‚ûï A√±adir Nodo
            </button>
            <button onclick="eliminarNodoCanvas()" class="px-3 py-1.5 bg-red-600 hover:bg-red-700 text-white text-sm font-medium rounded transition-colors">
              ‚ùå Eliminar Nodo
            </button>
            <button onclick="a√±adirEdgeCanvas()" class="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium rounded transition-colors">
              ‚ûï A√±adir Edge
            </button>
            <button onclick="eliminarEdgeCanvas()" class="px-3 py-1.5 bg-red-600 hover:bg-red-700 text-white text-sm font-medium rounded transition-colors">
              ‚ùå Eliminar Edge
            </button>
          </div>
          <!-- Acciones Sem√°nticas (AXE v0.6.4 - Legacy) -->
          <!-- Nota: AXE v0.6.5 introduce UI contextual. Selecciona un nodo en el viewer para ver acciones disponibles. -->
          <div class="flex gap-2 flex-wrap border-t border-slate-700 pt-2 mt-2">
            <span class="text-slate-300 text-sm self-center mr-2">Acciones Sem√°nticas (Legacy):</span>
            <button onclick="insertNodeAfterAction()" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded transition-colors" title="Insertar nodo despu√©s de otro">
              ‚û°Ô∏è Insertar Despu√©s
            </button>
            <button onclick="convertToDecisionAction()" class="px-3 py-1.5 bg-purple-600 hover:bg-purple-700 text-white text-sm font-medium rounded transition-colors" title="Convertir nodo a decisi√≥n">
              ‚ùì Convertir a Decisi√≥n
            </button>
            <button onclick="markAsStartAction()" class="px-3 py-1.5 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded transition-colors" title="Marcar nodo como inicio">
              üöÄ Marcar como Inicio
            </button>
            <button onclick="markAsEndAction()" class="px-3 py-1.5 bg-orange-600 hover:bg-orange-700 text-white text-sm font-medium rounded transition-colors" title="Marcar nodo como fin">
              üèÅ Marcar como Fin
            </button>
            <button onclick="duplicateSubgraphAction()" class="px-3 py-1.5 bg-teal-600 hover:bg-teal-700 text-white text-sm font-medium rounded transition-colors" title="Duplicar subgrafo completo">
              üìã Duplicar Subgrafo
            </button>
          </div>
        </div>
        
        <!-- Editor Visual Principal (expandido) -->
        <div class="bg-slate-800 rounded-lg p-4 mb-4">
          <div class="flex justify-between items-center mb-2">
            <h3 class="text-white font-semibold text-lg">Editor Visual</h3>
            <div class="flex gap-2">
              <button onclick="toggleFullscreenCanvas()" class="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium rounded transition-colors" title="Pantalla completa">
                ‚õ∂ Pantalla Completa
              </button>
              <button onclick="toggleJsonPanel()" class="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 text-white text-sm font-medium rounded transition-colors" id="toggle-json-btn" title="Mostrar/Ocultar Canvas JSON">
                üìÑ JSON
              </button>
            </div>
          </div>
          <div id="canvas-viewer" class="bg-slate-900 rounded p-4" style="min-height: calc(100vh - 400px);">
            <p class="text-slate-400 text-sm">Carga un canvas para verlo</p>
          </div>
        </div>
        
        <!-- Canvas JSON Colapsable (secundario) -->
        <div id="canvas-json-panel" class="bg-slate-800 rounded-lg p-4 mb-4" style="display: none;">
          <div class="flex justify-between items-center mb-2">
            <h3 class="text-white font-semibold mb-2">Canvas JSON</h3>
            <button onclick="toggleJsonPanel()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Ocultar">
              ‚úï
            </button>
          </div>
          <textarea id="canvas-json-editor" class="w-full h-96 bg-slate-900 text-slate-100 font-mono text-sm p-4 rounded border border-slate-700" placeholder='{"version":"1.0","canvas_id":"...","nodes":[],"edges":[]}' oninput="detectarCambiosCanvas()"></textarea>
        </div>
        
        <!-- Panel de Diagn√≥stico (AXE v0.6.9) -->
        <div class="bg-slate-800 rounded-lg p-4 mb-4">
          <div class="flex justify-between items-center mb-3">
            <h3 class="text-white font-semibold text-lg">üß† Diagn√≥stico</h3>
            <button onclick="actualizarDiagnostico()" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded transition-colors">
              üîÑ Actualizar
            </button>
          </div>
          <div id="canvas-diagnostico" class="space-y-2">
            <p class="text-slate-400 text-sm">Carga un canvas para ver diagn√≥sticos</p>
          </div>
        </div>
        
        <!-- Panel de Sugerencias Pedag√≥gicas (AXE v0.6.10) -->
        <div class="bg-slate-800 rounded-lg p-4 mb-4">
          <div class="flex justify-between items-center mb-3">
            <h3 class="text-white font-semibold text-lg">üß≠ Sugerencias</h3>
            <button onclick="actualizarSugerencias()" class="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium rounded transition-colors">
              üîÑ Actualizar
            </button>
          </div>
          <div id="canvas-sugerencias" class="space-y-2">
            <p class="text-slate-400 text-sm">Carga un canvas para ver sugerencias pedag√≥gicas</p>
          </div>
        </div>
        
        <!-- Resultado de conversi√≥n (si aplica) -->
        <div id="canvas-conversion-result" class="bg-slate-800 rounded-lg p-4" style="display: none;"></div>
        </div>
      </div>
      
      <!-- Columna derecha: Panel contextual sticky (AXE v0.6.9) -->
      <aside id="canvas-contextual-panel" class="canvas-contextual-panel" style="position: sticky; top: 16px; max-height: calc(100vh - 32px); overflow-y: auto; background: #1e293b; border-radius: 12px; padding: 16px; border: 1px solid #334155;">
        <!-- El contenido se renderiza din√°micamente en actualizarPanelContextual() -->
        <div id="canvas-contextual-panel-content">
          <p class="text-slate-400 text-sm">Selecciona un nodo en el canvas para ver sus acciones y propiedades</p>
        </div>
      </aside>
    </div>
    
    <!-- Toast Container -->
    <div id="toast-container" class="fixed top-4 right-4 z-50 space-y-2" style="display: none;"></div>
    
    <!-- Vista Lista (vista secundaria) -->
    <div id="lista-view-container" class="flex-1 flex" style="display: none;">
      <!-- Columna izquierda: Lista de steps -->
      <div class="steps-panel bg-slate-950 border-r border-slate-800 overflow-y-auto" id="steps-panel">
      <div class="p-4">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-lg font-semibold text-white">Steps</h2>
          <div class="flex items-center gap-2">
            <button onclick="toggleStepsPanel()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-sm rounded transition-colors" id="toggle-steps-panel-btn" title="Colapsar/Expandir panel">
              ‚óÄ
            </button>
            <button onclick="a√±adirStep()" class="px-2 py-1 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded">
              ‚ûï
            </button>
          </div>
        </div>
        <div id="steps-list" class="space-y-2">
          <p class="text-slate-400 text-sm">Cargando steps...</p>
        </div>
      </div>
    </div>
    
    <!-- Divisor draggable para redimensionar -->
    <div class="panel-resizer" id="panel-resizer"></div>
    
    <!-- Centro: Preview de pantalla -->
    <div class="editor-main flex-1 bg-slate-900 overflow-y-auto p-6">
      <!-- SPRINT AXE v0.3: Preview Harness Unificado -->
      <div id="preview-harness-container" style="display: none;"></div>
      <!-- Preview Panel con iframe (AXE v5.16.0) -->
      <div id="preview-panel-container" style="display: none; position: fixed; top: 0; right: 0; width: 50%; height: 100vh; background: #1e293b; z-index: 1000; border-left: 2px solid #475569; box-shadow: -4px 0 12px rgba(0,0,0,0.3);">
        <div style="display: flex; flex-direction: column; height: 100%;">
          <div style="padding: 12px 16px; background: #334155; border-bottom: 1px solid #475569; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="color: #f1f5f9; font-size: 0.875rem; font-weight: 600;">Preview Recorrido</h3>
            <button onclick="togglePreviewPanel()" style="padding: 4px 8px; background: #475569; color: #f1f5f9; border: none; border-radius: 4px; cursor: pointer; font-size: 0.75rem;">‚úï Cerrar</button>
          </div>
          <iframe id="preview-iframe" src="/admin/recorridos/preview" style="flex: 1; width: 100%; border: none; background: #1e293b;"></iframe>
        </div>
      </div>
      <!-- Preview legacy (fallback) -->
      <div class="bg-white rounded-lg shadow-lg min-h-full" id="preview-container">
        <div class="p-8 text-center text-slate-400">
          <p>Selecciona un step para ver el preview</p>
        </div>
      </div>
    </div>
    
    <!-- Divisor draggable para redimensionar panel derecho -->
    <div class="panel-resizer-right" id="panel-resizer-right"></div>
    
    <!-- Derecha: Panel de configuraci√≥n (redimensionable) -->
    <div class="config-panel bg-slate-950 border-l border-slate-800 overflow-y-auto" id="config-panel-container">
      <div class="p-4" id="config-panel">
        <p class="text-slate-400 text-sm">Selecciona un step para configurarlo</p>
      </div>
    </div>
    </div>
  </div>
</div>

<style>
  /* ============================================================================
   * LAYOUT CAN√ìNICO DEL EDITOR (FIX BUG CR√çTICO UI)
   * ============================================================================
   * 
   * ESTRUCTURA:
   * - .editor-layout: flex column, altura completa
   * - .editor-topbar: height fija, flex-shrink: 0, position: relative
   * - .editor-body: flex: 1, overflow: auto
   * 
   * PROHIBIDO:
   * - position: fixed en el topbar
   * - margin-top/padding-top "m√°gicos" para compensar headers
   * - z-index excesivos
   * ============================================================================
   */
  
  .editor-layout {
    display: flex;
    flex-direction: column;
    height: calc(100vh - 130px); /* Altura total menos header del admin base (~130px aprox) */
    overflow: hidden;
  }
  
  .editor-topbar {
    position: relative; /* NO fixed */
    flex-shrink: 0;
    z-index: 10; /* z-index normal, no excesivo */
  }
  
  .editor-body {
    flex: 1;
    display: flex;
    overflow: hidden; /* El scroll lo manejan los hijos */
    min-height: 0; /* Importante para que flex funcione con overflow */
  }
  
  /* Columnas internas del editor */
  .editor-body > div {
    height: 100%;
    min-height: 0;
  }
  
  /* AXE v0.6.9: Grid responsive para panel contextual */
  #canvas-view-container {
    display: grid;
    grid-template-columns: 1fr 380px;
    gap: 16px;
    align-items: start;
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
  }
  
  /* Columna principal del canvas */
  .canvas-main-column {
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
  }
  
  /* Canvas visual: no debe interferir con scroll del navegador */
  #canvas-visual-container {
    /* El canvas tiene overflow-hidden para que no interfiera con scroll */
    /* El wheel event solo act√∫a con Alt, permitiendo scroll normal sin Alt */
    touch-action: pan-x pan-y; /* Permitir pan t√°ctil pero no zoom del navegador */
  }
  
  /* Panel contextual: scroll independiente */
  #canvas-contextual-panel {
    height: 100%;
    max-height: calc(100vh - 32px);
    overflow-y: auto;
    overflow-x: hidden;
  }
  
  @media (max-width: 1024px) {
    #canvas-view-container {
      grid-template-columns: 1fr;
    }
    
    #canvas-contextual-panel {
      position: static !important;
      max-height: none !important;
    }
  }
  
  /* Responsive: en m√≥vil, stack vertical */
  @media (max-width: 1024px) {
    .editor-layout {
      height: auto;
      min-height: calc(100vh - 130px);
    }
    
    .editor-body {
      flex-direction: column;
      overflow-y: auto;
    }
    
    .editor-body > div {
      height: auto;
      min-height: 300px;
      width: 100% !important;
      flex-shrink: 0;
    }
  }
  
  /* ============================================================================
   * PANEL DE STEPS REDIMENSIONABLE
   * ============================================================================
   */
  
  .steps-panel {
    width: var(--steps-panel-width, 280px);
    min-width: 200px;
    max-width: 500px;
    transition: width 0.2s ease;
    position: relative;
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  
  /* Contenedor interno del panel de steps con scroll */
  .steps-panel > .p-4 {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
  }
  
  .steps-panel.collapsed {
    width: 48px !important;
    min-width: 48px;
    max-width: 48px;
  }
  
  .steps-panel.collapsed .p-4 > *:not(.flex) {
    display: none;
  }
  
  .steps-panel.collapsed .p-4 .flex {
    justify-content: center;
  }
  
  .steps-panel.collapsed #steps-list {
    display: none;
  }
  
  .panel-resizer {
    width: 6px;
    cursor: col-resize;
    background: rgba(255, 255, 255, 0.05);
    flex-shrink: 0;
    transition: background 0.2s ease;
    user-select: none;
  }
  
  .steps-panel.collapsed + .panel-resizer {
    display: none;
  }
  
  .panel-resizer:hover {
    background: rgba(255, 255, 255, 0.15);
  }
  
  .panel-resizer.resizing {
    background: rgba(79, 70, 229, 0.3);
  }
  
  /* ============================================================================
   * PANEL DERECHO DE CONFIGURACI√ìN REDIMENSIONABLE (AXE)
   * ============================================================================
   */
  
  .config-panel {
    width: var(--config-panel-width, 384px);
    min-width: 320px;
    max-width: 65vw;
    transition: width 0.2s ease;
    position: relative;
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  
  /* Contenedor interno del panel de configuraci√≥n con scroll */
  .config-panel > #config-panel {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
  }
  
  .panel-resizer-right {
    width: 6px;
    cursor: col-resize;
    background: rgba(255, 255, 255, 0.05);
    flex-shrink: 0;
    transition: background 0.2s ease;
    user-select: none;
  }
  
  .panel-resizer-right:hover {
    background: rgba(255, 255, 255, 0.15);
  }
  
  .panel-resizer-right.resizing {
    background: rgba(79, 70, 229, 0.3);
  }
  
  .editor-main {
    flex: 1;
    min-width: 0;
  }
  
  .recorridos-editor {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }
  
  .step-item {
    padding: 12px;
    background: #1e293b;
    border-radius: 8px;
    cursor: grab;
    transition: all 0.2s;
    border: 2px solid transparent;
  }
  
  .step-item:hover {
    background: #334155;
  }
  
  .step-item.active {
    border-color: #4f46e5;
    background: #334155;
  }
  
  .step-item.dragging {
    opacity: 0.5;
    cursor: grabbing;
  }
  
  .step-item.drag-over {
    border-top: 2px solid #3498db;
  }
  
  .step-item .step-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
  }
  
  .step-item .step-id {
    font-weight: 600;
    color: #fff;
    font-size: 14px;
  }
  
  .step-item .step-actions {
    display: flex;
    gap: 4px;
  }
  
  .step-item .step-actions button {
    padding: 2px 6px;
    font-size: 12px;
    background: #475569;
    border: none;
    border-radius: 4px;
    color: #fff;
    cursor: pointer;
  }
  
  .step-item .step-actions button:hover {
    background: #64748b;
  }
  
  .step-item .step-type {
    font-size: 12px;
    color: #94a3b8;
    margin-top: 4px;
  }
  
  .config-section {
    margin-bottom: 24px;
  }
  
  .config-section h3 {
    font-size: 16px;
    font-weight: 600;
    color: #fff;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid #334155;
  }
  
  .form-group {
    margin-bottom: 16px;
  }
  
  .form-group label {
    display: block;
    font-size: 14px;
    color: #cbd5e1;
    margin-bottom: 6px;
  }
  
  .form-group input,
  .form-group select,
  .form-group textarea {
    width: 100%;
    padding: 8px 12px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 6px;
    color: #fff;
    font-size: 14px;
  }
  
  .form-group input:focus,
  .form-group select:focus,
  .form-group textarea:focus {
    outline: none;
    border-color: #4f46e5;
  }
  
  .validation-error {
    background: #7f1d1d;
    border: 1px solid #991b1b;
    color: #fecaca;
    padding: 12px;
    border-radius: 6px;
    margin-bottom: 8px;
  }
  
  .validation-warning {
    background: #78350f;
    border: 1px solid #92400e;
    color: #fed7aa;
    padding: 12px;
    border-radius: 6px;
    margin-bottom: 8px;
  }
  
  .validation-success {
    background: #14532d;
    border: 1px solid #166534;
    color: #bbf7d0;
    padding: 12px;
    border-radius: 6px;
    margin-bottom: 8px;
  }
  
  /* ============================================================================
   * ESTILOS PARA screen_text EDITOR
   * ============================================================================
   */
  
  .screen-text-editor {
    padding: 8px 0;
  }
  
  .screen-text-input {
    width: 100%;
    padding: 10px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    transition: all 0.2s;
  }
  
  .screen-text-input:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  .screen-text-textarea {
    width: 100%;
    padding: 12px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    line-height: 1.6;
    resize: vertical;
    min-height: 200px;
    transition: all 0.2s;
    font-family: inherit;
  }
  
  .screen-text-textarea:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  .screen-text-textarea::placeholder {
    color: #64748b;
    font-style: italic;
  }
  
  /* ============================================================================
   * ESTILOS PARA screen_text PREVIEW
   * ============================================================================
   */
  
  .screen-text-preview {
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100%;
  }
  
  .mobile-frame {
    width: 100%;
    max-width: 375px;
    min-height: 600px;
    background: linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 24px;
    box-shadow: 
      0 4px 6px -1px rgba(0, 0, 0, 0.1),
      0 2px 4px -1px rgba(0, 0, 0, 0.06),
      inset 0 0 0 1px rgba(0, 0, 0, 0.05);
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  
  .mobile-content {
    flex: 1;
    padding: 32px 24px;
    display: flex;
    flex-direction: column;
  }
  
  .preview-title {
    font-size: 28px;
    font-weight: 700;
    color: #0f172a;
    margin: 0 0 12px 0;
    line-height: 1.2;
  }
  
  .preview-subtitle {
    font-size: 18px;
    font-weight: 500;
    color: #475569;
    margin: 0 0 24px 0;
    line-height: 1.4;
  }
  
  .preview-body {
    font-size: 16px;
    color: #334155;
    line-height: 1.7;
    flex: 1;
  }
  
  .preview-placeholder {
    color: #94a3b8;
    font-style: italic;
  }
  
  .preview-action-btn {
    margin-top: auto;
    padding: 16px 32px;
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    color: white;
    font-size: 16px;
    font-weight: 600;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    width: 100%;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  
  .preview-action-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
  }
  
  .preview-info {
    text-align: center;
  }
  
  .preview-info code {
    background: #1e293b;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 11px;
  }
  
  /* ============================================================================
   * ESTILOS PARA screen_video EDITOR
   * ============================================================================
   */
  
  .screen-video-editor {
    padding: 8px 0;
  }
  
  .screen-video-input {
    width: 100%;
    padding: 10px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    transition: all 0.2s;
  }
  
  .screen-video-input:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  .screen-video-textarea {
    width: 100%;
    padding: 12px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    line-height: 1.6;
    resize: vertical;
    min-height: 80px;
    transition: all 0.2s;
    font-family: inherit;
  }
  
  .screen-video-textarea:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  .screen-video-select {
    width: 100%;
    padding: 10px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .screen-video-select:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  .screen-video-radio-group {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
  }
  
  .screen-video-radio-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    background: #1e293b;
    border: 2px solid #334155;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    flex: 1;
    min-width: 140px;
  }
  
  .screen-video-radio-item:hover {
    border-color: #475569;
  }
  
  .screen-video-radio-item.active {
    border-color: #6366f1;
    background: #312e81;
  }
  
  .screen-video-radio-item input[type="radio"] {
    accent-color: #6366f1;
    width: 16px;
    height: 16px;
  }
  
  .screen-video-radio-item label {
    color: #e2e8f0;
    font-size: 14px;
    cursor: pointer;
    margin: 0;
  }
  
  .screen-video-number {
    width: 120px;
    padding: 10px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    transition: all 0.2s;
  }
  
  .screen-video-number:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  /* ============================================================================
   * ESTILOS PARA screen_video PREVIEW
   * ============================================================================
   */
  
  .screen-video-preview {
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100%;
  }
  
  .video-preview-container {
    width: 100%;
    aspect-ratio: 16/9;
    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 16px 0;
    border: 1px solid #334155;
    overflow: hidden;
  }
  
  .video-preview-youtube {
    width: 100%;
    height: 100%;
    border: none;
    border-radius: 12px;
  }
  
  .video-preview-placeholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    color: #64748b;
  }
  
  .video-preview-placeholder .icon {
    font-size: 48px;
    opacity: 0.7;
  }
  
  .video-preview-placeholder .text {
    font-size: 14px;
    text-align: center;
    max-width: 200px;
  }
  
  .video-collapsed-btn {
    padding: 16px 32px;
    background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
    color: white;
    font-size: 16px;
    font-weight: 600;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  
  .video-collapsed-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
  }
  
  .video-duration-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    background: #1e293b;
    border-radius: 20px;
    font-size: 12px;
    color: #94a3b8;
    margin-top: 8px;
  }
  
  /* ============================================================================
   * ESTILOS PARA screen_audio EDITOR
   * ============================================================================
   */
  
  .screen-audio-editor {
    padding: 8px 0;
  }
  
  .screen-audio-input {
    width: 100%;
    padding: 10px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    transition: all 0.2s;
  }
  
  .screen-audio-input:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  .screen-audio-select {
    width: 100%;
    padding: 10px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .screen-audio-select:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  .screen-audio-number {
    width: 120px;
    padding: 10px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    transition: all 0.2s;
  }
  
  .screen-audio-number:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  /* ============================================================================
   * ESTILOS PARA screen_audio PREVIEW
   * ============================================================================
   */
  
  .screen-audio-preview {
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100%;
  }
  
  .audio-preview-container {
    width: 100%;
    padding: 24px 20px;
    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    border-radius: 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 16px 0;
    border: 1px solid #334155;
  }
  
  .audio-preview-icon {
    font-size: 64px;
    margin-bottom: 16px;
    opacity: 0.9;
  }
  
  .audio-preview-placeholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    color: #64748b;
  }
  
  .audio-preview-placeholder .icon {
    font-size: 48px;
    opacity: 0.7;
  }
  
  .audio-preview-placeholder .text {
    font-size: 14px;
    text-align: center;
    max-width: 200px;
  }
  
  .audio-progress-bar {
    width: 100%;
    height: 6px;
    background: #334155;
    border-radius: 3px;
    margin: 16px 0 12px;
    position: relative;
    overflow: hidden;
  }
  
  .audio-progress-bar::after {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    width: 35%;
    background: linear-gradient(90deg, #6366f1 0%, #818cf8 100%);
    border-radius: 3px;
  }
  
  .audio-controls {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-top: 8px;
  }
  
  .audio-play-btn {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
    border: none;
    color: white;
    font-size: 18px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  
  .audio-play-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
  }
  
  .audio-time {
    font-size: 12px;
    color: #94a3b8;
    font-variant-numeric: tabular-nums;
  }
  
  .audio-duration-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    background: #1e293b;
    border-radius: 20px;
    font-size: 12px;
    color: #94a3b8;
    margin-top: 8px;
  }
  
  /* ============================================================================
   * ESTILOS PARA screen_choice EDITOR
   * ============================================================================
   */
  
  .screen-choice-editor {
    padding: 8px 0;
  }
  
  .screen-choice-input {
    width: 100%;
    padding: 10px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    transition: all 0.2s;
  }
  
  .screen-choice-input:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  .screen-choice-textarea {
    width: 100%;
    padding: 12px 14px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 15px;
    line-height: 1.6;
    resize: vertical;
    min-height: 80px;
    transition: all 0.2s;
    font-family: inherit;
  }
  
  .screen-choice-textarea:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  /* Lista de opciones */
  .choices-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  
  .choice-card {
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 12px;
    padding: 16px;
    transition: all 0.2s;
  }
  
  .choice-card:hover {
    border-color: #475569;
  }
  
  .choice-card.incomplete {
    border-color: #f59e0b;
    background: linear-gradient(135deg, #1e293b 0%, #2c1d10 100%);
  }
  
  .choice-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid #334155;
  }
  
  .choice-card-number {
    font-size: 14px;
    font-weight: 600;
    color: #818cf8;
  }
  
  .choice-card-actions {
    display: flex;
    gap: 8px;
  }
  
  .choice-card-actions button {
    padding: 4px 8px;
    font-size: 12px;
    background: #475569;
    border: none;
    border-radius: 4px;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .choice-card-actions button:hover {
    background: #64748b;
  }
  
  .choice-card-actions button.delete-btn:hover {
    background: #dc2626;
  }
  
  .choice-field {
    margin-bottom: 12px;
  }
  
  .choice-field:last-child {
    margin-bottom: 0;
  }
  
  .choice-field label {
    display: block;
    font-size: 12px;
    color: #94a3b8;
    margin-bottom: 4px;
    font-weight: 500;
  }
  
  .choice-field-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  .choice-field input,
  .choice-field textarea {
    width: 100%;
    padding: 8px 12px;
    background: #0f172a;
    border: 1px solid #334155;
    border-radius: 6px;
    color: #fff;
    font-size: 13px;
    transition: all 0.2s;
  }
  
  .choice-field input:focus,
  .choice-field textarea:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.15);
  }
  
  .choice-field input.slug-input {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
    font-size: 12px;
    letter-spacing: 0.5px;
  }
  
  .choice-field input.slug-input.invalid {
    border-color: #dc2626;
  }
  
  .choice-field-hint {
    font-size: 11px;
    color: #64748b;
    margin-top: 2px;
  }
  
  .auto-slug-btn {
    padding: 6px 12px;
    background: #3730a3;
    border: none;
    border-radius: 6px;
    color: #c7d2fe;
    font-size: 11px;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.2s;
  }
  
  .auto-slug-btn:hover {
    background: #4338ca;
  }
  
  .choice-minutes-input {
    width: 80px !important;
  }
  
  .add-choice-btn {
    width: 100%;
    padding: 14px;
    background: linear-gradient(135deg, #1e3a5f 0%, #1e293b 100%);
    border: 2px dashed #334155;
    border-radius: 12px;
    color: #94a3b8;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  
  .add-choice-btn:hover {
    border-color: #6366f1;
    color: #c7d2fe;
    background: linear-gradient(135deg, #312e81 0%, #1e293b 100%);
  }
  
  /* ============================================================================
   * ESTILOS PARA screen_choice PREVIEW
   * ============================================================================
   */
  
  .screen-choice-preview {
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100%;
  }
  
  .preview-question {
    font-size: 20px;
    font-weight: 600;
    color: #1e293b;
    margin: 0 0 20px 0;
    line-height: 1.4;
    text-align: center;
    padding: 16px;
    background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
    border-radius: 12px;
    border-left: 4px solid #6366f1;
  }
  
  .preview-choices {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    margin-bottom: 20px;
  }
  
  .preview-choice-btn {
    width: 100%;
    padding: 14px 18px;
    background: #fff;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    text-align: left;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  
  .preview-choice-btn:hover {
    border-color: #6366f1;
    background: #f8fafc;
    transform: translateX(4px);
  }
  
  .preview-choice-btn.placeholder {
    border-style: dashed;
    opacity: 0.6;
  }
  
  .preview-choice-label {
    font-size: 16px;
    font-weight: 500;
    color: #1e293b;
  }
  
  .preview-choice-desc {
    font-size: 13px;
    color: #64748b;
  }
  
  .preview-choice-meta {
    display: flex;
    gap: 8px;
    margin-top: 4px;
  }
  
  .preview-choice-minutes {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    background: #dbeafe;
    border-radius: 12px;
    font-size: 11px;
    color: #1e40af;
    font-weight: 500;
  }
  
  .preview-choice-tag {
    display: inline-flex;
    padding: 2px 8px;
    background: #f1f5f9;
    border-radius: 12px;
    font-size: 11px;
    color: #475569;
  }
  
  /* ============================================================================
   * ESTILOS PARA FASE 4.1: Indicadores de campos obligatorios y estado
   * ============================================================================
   */
  
  .required-badge {
    color: #e74c3c;
    font-weight: bold;
    margin-left: 4px;
    cursor: help;
  }
  
  .publish-status {
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 0.85rem;
    font-weight: 500;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  
  .publish-status--ready {
    background: #27ae60;
    color: #fff;
  }
  
  .publish-status--draft {
    background: #f39c12;
    color: #fff;
  }
  
  .publish-status--invalid {
    background: #e74c3c;
    color: #fff;
  }
  
  /* ============================================================================
   * ESTILOS PARA FASE 4.2: Badge de handlers especiales
   * ============================================================================
   */
  
  .handler-badge {
    margin-left: 8px;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.75rem;
    background: #34495e;
    color: #ecf0f1;
    cursor: help;
    display: inline-block;
    vertical-align: middle;
  }
  
  /* ============================================================================
   * ESTILOS PARA PANEL DE DIAGN√ìSTICO Y SUGERENCIAS (AXE)
   * ============================================================================
   * Clases sem√°nticas reutilizables para mejorar legibilidad en modo dark
   * Texto principal siempre claro, colores sem√°nticos solo en fondos/badges
   */
  
  /* Clase base para items del panel */
  .axe-panel-item {
    border-radius: 8px;
    padding: 12px;
    font-size: 0.875rem;
    color: #e5e7eb; /* Texto principal siempre claro */
    transition: all 0.2s ease;
  }
  
  .axe-panel-item--clickable {
    cursor: pointer;
  }
  
  .axe-panel-item--clickable:hover {
    opacity: 0.9;
    transform: translateY(-1px);
  }
  
  /* Variantes por prioridad/tipo */
  .axe-panel-item--high {
    background-color: #7c2d12; /* Fondo alta prioridad */
    border: 1px solid rgba(220, 38, 38, 0.3);
  }
  
  .axe-panel-item--high:hover {
    background-color: #991b1b;
  }
  
  .axe-panel-item--medium {
    background-color: #3f3f46; /* Fondo media prioridad */
    border: 1px solid rgba(234, 179, 8, 0.3);
  }
  
  .axe-panel-item--medium:hover {
    background-color: #52525b;
  }
  
  .axe-panel-item--low {
    background-color: #1e293b; /* Fondo baja prioridad */
    border: 1px solid rgba(59, 130, 246, 0.3);
  }
  
  .axe-panel-item--low:hover {
    background-color: #334155;
  }
  
  .axe-panel-item--warning {
    background-color: #1f2937; /* Fondo warning */
    border: 1px solid rgba(234, 179, 8, 0.3);
  }
  
  .axe-panel-item--warning:hover {
    background-color: #374151;
  }
  
  .axe-panel-item--info {
    background-color: #1e293b; /* Fondo info */
    border: 1px solid rgba(59, 130, 246, 0.3);
  }
  
  .axe-panel-item--info:hover {
    background-color: #334155;
  }
  
  /* Texto dentro de los items */
  .axe-panel-item__text {
    color: #e5e7eb; /* Texto principal claro */
    flex: 1;
  }
  
  .axe-panel-item__text--strong {
    color: #ffffff; /* Texto fuerte */
  }
  
  /* Iconos y badges */
  .axe-panel-item__icon {
    font-size: 1rem;
    line-height: 1;
    flex-shrink: 0;
  }
  
  .axe-panel-item__badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-family: monospace;
  }
  
  .axe-panel-item__badge--high {
    background-color: rgba(220, 38, 38, 0.4);
    color: #fecaca;
  }
  
  .axe-panel-item__badge--medium {
    background-color: rgba(234, 179, 8, 0.4);
    color: #fef3c7;
  }
  
  .axe-panel-item__badge--low {
    background-color: rgba(59, 130, 246, 0.4);
    color: #dbeafe;
  }
  
  .axe-panel-item__badge--warning {
    background-color: rgba(234, 179, 8, 0.4);
    color: #fef3c7;
  }
  
  .axe-panel-item__badge--info {
    background-color: rgba(59, 130, 246, 0.4);
    color: #dbeafe;
  }
  
  /* T√≠tulos de secci√≥n */
  .axe-panel-section-title {
    font-size: 0.875rem;
    font-weight: 600;
    margin-bottom: 8px;
    color: #e5e7eb;
  }
  
  .axe-panel-section-title--high {
    color: #fecaca; /* Tono claro para alta prioridad */
  }
  
  .axe-panel-section-title--medium {
    color: #fef3c7; /* Tono claro para media prioridad */
  }
  
  .axe-panel-section-title--low {
    color: #dbeafe; /* Tono claro para baja prioridad */
  }
  
  .axe-panel-section-title--warning {
    color: #fef3c7; /* Tono claro para warnings */
  }
  
  .axe-panel-section-title--info {
    color: #dbeafe; /* Tono claro para info */
  }
  
  /* Contenedor de items */
  .axe-panel-items {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .axe-panel-items--compact {
    gap: 4px;
  }
  
  /* Mensaje de estado vac√≠o */
  .axe-panel-empty {
    color: #10b981; /* Verde claro para mensajes positivos */
    font-size: 0.875rem;
  }
  
  /* Mensaje de error */
  .axe-panel-error {
    color: #fca5a5; /* Rojo claro para errores */
    font-size: 0.875rem;
  }
</style>

<!-- Script module para cargar registry de handlers -->
<script type="module">
  (async () => {
    try {
      const { HANDLER_INFO } = await import('/js/recorridos/step-handler-registry.js');
      window.HANDLER_INFO = HANDLER_INFO;
    } catch (error) {
      console.error('Error cargando HANDLER_INFO:', error);
      window.HANDLER_INFO = {};
    }
  })();
</script>

<script>
  console.log('BOOT REC EDITOR', location.pathname);
  // ============================================================================
  // ESTADO GLOBAL DEL EDITOR (BLINDAJE v2)
  // ============================================================================
  // 
  // PRINCIPIOS:
  // 1. El editor puede estar en estado editable pero inv√°lido (eso NO es un error)
  // 2. El error es intentar persistir basura
  // 3. guardarDraft() solo se llama si valid === true
  // 4. Los IDs son slugs t√©cnicos (generados autom√°ticamente)
  //
  let editorState = {
    recorridoId: null,
    definition: null,
    selectedStepId: null,
    registry: null,
    
    // BLINDAJE v2: Estado de draft
    dirty: false,           // ¬øHay cambios sin guardar?
    valid: false,           // ¬øLa definici√≥n es v√°lida para guardar?
    validationErrors: [],   // Errores de validaci√≥n actuales
    lastSavedAt: null,      // √öltima vez que se guard√≥
    saveTimeout: null,      // Timeout para debounce (ya no agresivo)
    isSaving: false         // ¬øEst√° guardando ahora mismo?
  };
  
  // ============================================================================
  // INICIALIZACI√ìN TEMPRANA DE ESTADO DEL CANVAS (AXE v0.7.0)
  // ============================================================================
  // Inicializar window.canvasSelectionState ANTES de cualquier uso
  // para evitar ReferenceError: selectedNodeId is not defined
  if (!window.canvasSelectionState) {
    window.canvasSelectionState = { selectedNodeId: null };
  }
  
  // ============================================================================
  // FUNCIONES GLOBALES (definidas temprano para evitar errores de referencia)
  // ============================================================================
  
  // Preview con runtime - Definida temprano para estar disponible globalmente
  async function previewRecorrido() {
    // Preview V1: Usa el runtime real con flag preview=1
    if (!editorState.recorridoId) {
      alert('No hay recorrido cargado');
      return;
    }
    window.open(`/enter?recorrido=${editorState.recorridoId}&preview=1`, '_blank');
  }
  
  // ============================================================================
  // UTILIDADES DE BLINDAJE
  // ============================================================================
  
  /**
   * Genera un slug t√©cnico a partir de un texto
   * - Sin espacios (usa _)
   * - Sin acentos
   * - Solo min√∫sculas, n√∫meros, guiones bajos
   */
  function generateSlug(text) {
    if (!text || typeof text !== 'string') return '';
    
    return text
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[\s\-]+/g, '_')
      .replace(/[^a-z0-9_]/g, '')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '')
      .substring(0, 64);
  }
  
  /**
   * Valida que un ID sea un slug t√©cnico v√°lido
   */
  function validateSlugId(id) {
    if (!id || typeof id !== 'string') {
      return { valid: false, error: 'El ID es requerido' };
    }
    if (id.length < 3) {
      return { valid: false, error: 'El ID debe tener al menos 3 caracteres' };
    }
    if (id.length > 64) {
      return { valid: false, error: 'El ID no puede tener m√°s de 64 caracteres' };
    }
    const slugPattern = /^[a-z][a-z0-9_]*$/;
    if (!slugPattern.test(id)) {
      return { valid: false, error: 'El ID solo puede contener letras min√∫sculas, n√∫meros y guiones bajos. Debe empezar con letra.' };
    }
    return { valid: true };
  }
  
  /**
   * Valida la definici√≥n ANTES de guardar draft (validaci√≥n r√°pida, sin registry)
   * Devuelve { valid: boolean, errors: Array<string> }
   */
  function validateDefinitionForDraft(definition) {
    const errors = [];
    
    if (!definition || typeof definition !== 'object') {
      return { valid: false, errors: ['La definici√≥n debe ser un objeto'] };
    }
    
    if (!definition.id) {
      errors.push('Falta el ID del recorrido');
    }
    
    if (!definition.entry_step_id) {
      errors.push('Falta entry_step_id');
    }
    
    if (!definition.steps || typeof definition.steps !== 'object') {
      errors.push('Falta el objeto steps');
    } else {
      const stepIds = Object.keys(definition.steps);
      
      if (stepIds.length === 0) {
        errors.push('Debe haber al menos un step');
      }
      
      if (definition.entry_step_id && !definition.steps[definition.entry_step_id]) {
        errors.push(`entry_step_id "${definition.entry_step_id}" no existe en steps`);
      }
      
      for (const stepId of stepIds) {
        const step = definition.steps[stepId];
        if (!step || typeof step !== 'object') {
          errors.push(`Step "${stepId}": debe ser un objeto`);
          continue;
        }
        
        // Validaci√≥n espec√≠fica para steps tipo motor
        if (step.type === 'motor') {
          // Validar motor_key (obligatorio)
          if (!step.motor_key || typeof step.motor_key !== 'string' || step.motor_key.trim() === '') {
            errors.push(`Step motor "${stepId}": debe tener un "motor_key" (string no vac√≠o)`);
          }
          
          // Validar motor_version (obligatorio, debe ser n√∫mero)
          if (step.motor_version === undefined || step.motor_version === null) {
            errors.push(`Step motor "${stepId}": debe tener un "motor_version" (n√∫mero)`);
          } else if (typeof step.motor_version !== 'number' || step.motor_version < 1) {
            errors.push(`Step motor "${stepId}": motor_version debe ser un n√∫mero >= 1`);
          }
          
          // Validar inputs requeridos (validaci√≥n b√°sica, se valida mejor en publish)
          if (step.inputs && typeof step.inputs !== 'object') {
            errors.push(`Step motor "${stepId}": inputs debe ser un objeto`);
          }
          
          // Los steps motor NO requieren screen_template_id
        } else {
          // Para steps normales, validar screen_template_id
          if (!step.screen_template_id) {
            errors.push(`Step "${stepId}": falta screen_template_id`);
          }
        }
      }
    }
    
    if (!definition.edges || !Array.isArray(definition.edges)) {
      errors.push('edges debe ser un array');
    } else {
      const stepIds = new Set(Object.keys(definition.steps || {}));
      
      for (let i = 0; i < definition.edges.length; i++) {
        const edge = definition.edges[i];
        if (!edge || typeof edge !== 'object') {
          errors.push(`Edge ${i}: debe ser un objeto`);
          continue;
        }
        if (!edge.from_step_id) {
          errors.push(`Edge ${i}: falta from_step_id`);
        } else if (!stepIds.has(edge.from_step_id)) {
          errors.push(`Edge ${i}: from_step_id "${edge.from_step_id}" no existe`);
        }
        if (!edge.to_step_id) {
          errors.push(`Edge ${i}: falta to_step_id`);
        } else if (!stepIds.has(edge.to_step_id)) {
          errors.push(`Edge ${i}: to_step_id "${edge.to_step_id}" no existe`);
        }
      }
    }
    
    return { valid: errors.length === 0, errors };
  }
  
  /**
   * Calcula el estado del draft para publicar (ready/draft/invalid)
   * @returns {string} 'ready' | 'draft' | 'invalid'
   */
  function calculatePublishStatus() {
    // Si hay errores de validaci√≥n ‚Üí invalid
    if (!editorState.valid || editorState.validationErrors.length > 0) {
      return 'invalid';
    }
    
    // Verificar campos publish_required en todos los steps
    const definition = editorState.definition;
    if (!definition || !definition.steps) {
      return 'invalid';
    }
    
    const registry = editorState.registry;
    if (!registry || !registry.screenTemplates) {
      // Si no hay registry, no podemos verificar publish_required
      // Fail-open: asumimos que est√° listo si es v√°lido
      return 'ready';
    }
    
    // Verificar cada step
    for (const stepId of Object.keys(definition.steps)) {
      const step = definition.steps[stepId];
      if (!step || !step.screen_template_id) {
        continue;
      }
      
      // Buscar template en registry
      const template = registry.screenTemplates.find(st => st.id === step.screen_template_id);
      if (!template || !template.editor_config || !template.editor_config.publish_required) {
        continue;
      }
      
      const publishRequired = template.editor_config.publish_required || [];
      const props = step.props || {};
      
      // Verificar cada campo publish_required
      for (const requiredProp of publishRequired) {
        const value = props[requiredProp];
        
        // Verificar si el campo est√° vac√≠o o no definido
        if (value === undefined || value === null || value === '') {
          return 'draft'; // Faltan campos requeridos
        }
        
        // Para arrays (como choices), verificar que tenga elementos v√°lidos
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return 'draft';
          }
          // Para choices, verificar que cada elemento tenga choice_id y label v√°lidos
          if (requiredProp === 'choices') {
            const hasValidChoices = value.every(c => 
              c && c.choice_id && /^[a-z][a-z0-9_]*$/.test(c.choice_id) && c.label && c.label.trim()
            );
            if (!hasValidChoices) {
              return 'draft';
            }
          }
        }
        
        // Para strings, verificar que no est√© vac√≠o despu√©s de trim
        if (typeof value === 'string' && value.trim() === '') {
          return 'draft';
        }
      }
    }
    
    // Si llegamos aqu√≠, todos los campos publish_required est√°n completos
    return 'ready';
  }
  
  /**
   * Actualiza el estado de validaci√≥n y UI del editor
   */
  function updateValidationState() {
    const validation = validateDefinitionForDraft(editorState.definition);
    editorState.valid = validation.valid;
    editorState.validationErrors = validation.errors;
    
    // Actualizar indicador visual de estado
    updateStatusIndicator();
  }
  
  /**
   * Actualiza el indicador visual de estado (dirty/valid/saving)
   */
  function updateStatusIndicator() {
    const statusEl = document.getElementById('recorrido-status');
    if (!statusEl) return;
    
    if (editorState.isSaving) {
      statusEl.textContent = 'üíæ Guardando...';
      statusEl.className = 'px-2 py-1 bg-blue-900 text-blue-200 rounded text-xs';
    } else if (editorState.dirty && !editorState.valid) {
      statusEl.textContent = '‚ö†Ô∏è Cambios sin guardar (inv√°lido)';
      statusEl.className = 'px-2 py-1 bg-red-900 text-red-200 rounded text-xs';
    } else if (editorState.dirty) {
      statusEl.textContent = '‚óè Cambios sin guardar';
      statusEl.className = 'px-2 py-1 bg-yellow-900 text-yellow-200 rounded text-xs';
    } else {
      statusEl.textContent = '‚úì Guardado';
      statusEl.className = 'px-2 py-1 bg-green-900 text-green-200 rounded text-xs';
    }
    
    // Actualizar badge de estado para publicar
    updatePublishStatusBadge();
  }
  
  /**
   * Actualiza el badge de estado para publicar (ready/draft/invalid)
   */
  function updatePublishStatusBadge() {
    const badgeEl = document.getElementById('publish-status-badge');
    if (!badgeEl) return;
    
    // Solo mostrar si hay definici√≥n cargada
    if (!editorState.definition) {
      badgeEl.style.display = 'none';
      return;
    }
    
    const status = calculatePublishStatus();
    badgeEl.style.display = 'inline-flex';
    
    // Remover todas las clases de estado
    badgeEl.classList.remove('publish-status--ready', 'publish-status--draft', 'publish-status--invalid');
    
    // A√±adir la clase correspondiente y actualizar texto
    if (status === 'ready') {
      badgeEl.classList.add('publish-status--ready');
      badgeEl.textContent = 'üü¢ Listo para publicar';
      badgeEl.title = 'Todos los campos obligatorios est√°n completos';
    } else if (status === 'draft') {
      badgeEl.classList.add('publish-status--draft');
      badgeEl.textContent = 'üü° V√°lido pero incompleto';
      badgeEl.title = 'Faltan campos obligatorios para publicar';
    } else {
      badgeEl.classList.add('publish-status--invalid');
      badgeEl.textContent = 'üî¥ Inv√°lido';
      badgeEl.title = 'El recorrido tiene errores que deben corregirse';
    }
  }
  
  /**
   * Marca el estado como dirty y valida
   */
  function markDirty() {
    editorState.dirty = true;
    updateValidationState();
    
    // BLINDAJE v2: Solo programar guardado si es v√°lido
    // Ya no hay autosave agresivo, solo despu√©s de acciones completas
  }
  
  /**
   * Intenta guardar el draft si es v√°lido
   * Llamar despu√©s de acciones completas (no en cada keypress)
   */
  function tryScheduleSave() {
    // Cancelar timeout anterior si existe
    if (editorState.saveTimeout) {
      clearTimeout(editorState.saveTimeout);
      editorState.saveTimeout = null;
    }
    
    // Solo guardar si es v√°lido
    if (!editorState.valid) {
      console.log('Draft no v√°lido, no se guarda:', editorState.validationErrors);
      return false;
    }
    
    // Programar guardado con debounce de 2 segundos
    editorState.saveTimeout = setTimeout(() => {
      guardarDraft();
    }, 2000);
    
    return true;
  }
  
  // Inicializar editor
  async function initEditor() {
    console.log('[Editor] STEP 1: initEditor start');
    
    const editor = document.getElementById('recorridos-editor');
    if (!editor) {
      console.error('[Editor] STEP 1.1: ERROR - Elemento #recorridos-editor no encontrado');
      // Fail-open: mostrar mensaje visible
      const topbar = document.querySelector('.editor-topbar');
      if (topbar) {
        topbar.innerHTML = `
          <div style="padding: 20px; background: #7f1d1d; color: #fca5a5; border-radius: 8px;">
            <h2 style="color: #ef4444; margin-bottom: 10px;">‚ö†Ô∏è Error de inicializaci√≥n</h2>
            <p>No se pudo encontrar el contenedor del editor. Por favor, recarga la p√°gina.</p>
          </div>
        `;
      }
      return;
    }
    
    console.log('[Editor] STEP 2: recorridoId =', editor.dataset.recorridoId);
    const recorridoId = editor.dataset.recorridoId;
    
    if (!recorridoId) {
      console.error('[Editor] STEP 2.1: ERROR - data-recorrido-id no encontrado');
      // Fail-open: mostrar mensaje visible
      const topbar = document.querySelector('.editor-topbar');
      if (topbar) {
        topbar.innerHTML = `
          <div style="padding: 20px; background: #7f1d1d; color: #fca5a5; border-radius: 8px;">
            <h2 style="color: #ef4444; margin-bottom: 10px;">‚ö†Ô∏è Error de inicializaci√≥n</h2>
            <p>No se pudo determinar el ID de recorrido. Por favor, recarga la p√°gina.</p>
          </div>
        `;
      }
      return;
    }
    
    editorState.recorridoId = recorridoId;
    console.log('[Editor] STEP 3: recorridoId asignado =', editorState.recorridoId);
    
    // Cargar registry
    console.log('[Editor] STEP 4: fetching registry');
    try {
      await cargarRegistry();
      console.log('[Editor] STEP 5: registry loaded');
    } catch (error) {
      console.error('[Editor] STEP 5.1: ERROR cargando registry:', error);
      // Fail-open: continuar aunque falle el registry
    }
    
    // Cargar o crear recorrido
    console.log('[Editor] STEP 6: checking if new or existing');
    if (editorState.recorridoId === 'new') {
      console.log('[Editor] STEP 7: creating new recorrido');
      try {
        await crearNuevoRecorrido();
        console.log('[Editor] STEP 8: new recorrido created');
      } catch (error) {
        console.error('[Editor] STEP 8.1: ERROR creando recorrido:', error);
        return;
      }
    } else {
      console.log('[Editor] STEP 7: loading existing recorrido');
      try {
        await cargarRecorrido();
        console.log('[Editor] STEP 8: recorrido loaded');
      } catch (error) {
        console.error('[Editor] STEP 8.1: ERROR cargando recorrido:', error);
        // Fail-open: mostrar mensaje visible
        const stepsListEl = document.getElementById('steps-list');
        if (stepsListEl) {
          stepsListEl.innerHTML = '<p class="text-red-400 text-sm">‚ö†Ô∏è Error cargando recorrido. Por favor, recarga la p√°gina.</p>';
        }
        return;
      }
    }
    
    console.log('[Editor] STEP 9: initEditor complete');
  }
  
  // Cargar registry
  async function cargarRegistry() {
    try {
      const response = await fetch('/admin/api/registry', {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });
      
      if (!response.ok) {
        throw new Error(`Error ${response.status}`);
      }
      
      editorState.registry = await response.json();
      console.log('Registry cargado:', editorState.registry);
      
      // Actualizar badge de estado despu√©s de cargar registry
      updatePublishStatusBadge();
    } catch (error) {
      console.error('Error cargando registry:', error);
      alert(`Error cargando registry: ${error.message}`);
    }
  }
  
  // Crear nuevo recorrido
  // BLINDAJE v2: Genera slug t√©cnico autom√°ticamente desde el nombre
  async function crearNuevoRecorrido() {
    const name = prompt('Nombre del recorrido (ej: "Limpieza Energ√©tica Diaria"):');
    if (!name || !name.trim()) {
      window.location.href = '/admin/recorridos';
      return;
    }
    
    // Generar slug autom√°ticamente
    const autoSlug = generateSlug(name);
    
    // Mostrar al usuario el slug generado y permitir edici√≥n
    const id = prompt(
      `ID t√©cnico generado (puedes editarlo):\n\n` +
      `‚ö†Ô∏è El ID debe ser:\n` +
      `- Solo letras min√∫sculas, n√∫meros y guiones bajos\n` +
      `- Sin espacios ni acentos\n` +
      `- Empezar con letra`,
      autoSlug
    );
    
    if (!id || !id.trim()) {
      window.location.href = '/admin/recorridos';
      return;
    }
    
    // Validar el slug antes de enviar
    const validation = validateSlugId(id);
    if (!validation.valid) {
      alert(`‚ùå ID inv√°lido: ${validation.error}\n\nIntenta de nuevo.`);
      return crearNuevoRecorrido(); // Reintentar
    }
    
    try {
      const response = await fetch('/admin/api/recorridos', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ id, name })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || `Error ${response.status}`);
      }
      
      const data = await response.json();
      editorState.definition = data.draft.definition_json;
      editorState.recorridoId = data.recorrido.id;
      editorState.dirty = false;
      editorState.valid = true;
      editorState.lastSavedAt = new Date();
      
      // Actualizar URL sin recargar (usando el ID t√©cnico)
      window.history.replaceState({}, '', `/admin/recorridos/${encodeURIComponent(editorState.recorridoId)}/edit`);
      
      await actualizarUI();
    } catch (error) {
      console.error('Error creando recorrido:', error);
      alert(`Error creando recorrido: ${error.message}`);
      window.location.href = '/admin/recorridos';
    }
  }
  
  // Cargar recorrido existente
  // BLINDAJE v2: Inicializa estado correctamente
  async function cargarRecorrido() {
    console.log('[Editor] STEP 7.1: cargarRecorrido start');
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      console.log('[Editor] STEP 7.2: encodedId =', encodedId);
      console.log('[Editor] STEP 7.3: fetching recorrido from API');
      
      const response = await fetch(`/admin/api/recorridos/${encodedId}`, {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });
      
      console.log('[Editor] STEP 7.4: response status =', response.status);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Error ${response.status}`);
      }
      
      console.log('[Editor] STEP 7.5: parsing response JSON');
      const data = await response.json();
      console.log('[Editor] STEP 7.6: data received, draft =', !!data.draft, 'published =', !!data.published_version);
      
      editorState.definition = data.draft?.definition_json || data.published_version?.definition_json;
      console.log('[Editor] STEP 7.7: definition assigned =', !!editorState.definition);
      
      // LOG TEMPORAL: Mostrar order cargado desde servidor
      if (editorState.definition?.steps) {
        const stepsLoaded = editorState.definition.steps;
        console.log('[RecorridosEditor] definition.steps:', stepsLoaded);
        console.log('[RecorridosEditor] definition.steps es objeto?', typeof stepsLoaded === 'object');
        console.log('[RecorridosEditor] definition.steps keys:', Object.keys(stepsLoaded));
        
        const orderLoaded = Object.keys(stepsLoaded).reduce((acc, stepId) => {
          const step = stepsLoaded[stepId];
          acc[stepId] = typeof step?.order === 'number' ? step.order : 'undefined';
          return acc;
        }, {});
        console.log('üì• Order cargado desde servidor:', orderLoaded);
      } else {
        console.warn('[RecorridosEditor] definition.steps no existe o es falsy');
      }
      
      if (!editorState.definition) {
        console.warn('[RecorridosEditor] No hay definition, creando nueva...');
        alert('El recorrido no tiene definici√≥n. Se crear√° una nueva.');
        editorState.definition = {
          id: editorState.recorridoId,
          entry_step_id: 'step1',
          steps: {
            step1: {
              screen_template_id: 'blank',
              props: {},
              order: 0
            }
          },
          edges: []
        };
        console.log('[RecorridosEditor] Nueva definition creada:', editorState.definition);
        // Marcar como dirty porque es nuevo
        editorState.dirty = true;
      } else {
        // Cargado desde servidor, no est√° dirty
        editorState.dirty = false;
        editorState.lastSavedAt = data.draft?.updated_at ? new Date(data.draft.updated_at) : null;
        console.log('[RecorridosEditor] Definition cargada desde servidor, dirty=false');
      }
      
      console.log('[Editor] STEP 7.8: definition.steps =', !!editorState.definition?.steps, 'keys =', editorState.definition?.steps ? Object.keys(editorState.definition.steps).length : 0);
      
      // BLINDAJE v2: Validar el estado inicial
      updateValidationState();
      
      // Actualizar nombre y estado
      const nameEl = document.getElementById('recorrido-name');
      if (nameEl) {
        nameEl.textContent = data.recorrido.name || editorState.recorridoId;
      }
      const versionEl = document.getElementById('recorrido-version');
      if (versionEl) {
        versionEl.textContent = data.recorrido.current_published_version 
          ? `v${data.recorrido.current_published_version}` 
          : 'v-';
      }
      
      console.log('[Editor] STEP 7.9: calling actualizarUI()');
      await actualizarUI();
      console.log('[Editor] STEP 7.10: actualizarUI() completed');
      updateStatusIndicator();
      
    } catch (error) {
      console.error('[Editor] STEP 7.11: ERROR cargando recorrido:', error);
      // Fail-open: mostrar mensaje visible
      const stepsListEl = document.getElementById('steps-list');
      if (stepsListEl) {
        stepsListEl.innerHTML = `<p class="text-red-400 text-sm">‚ö†Ô∏è Error cargando recorrido: ${error.message}</p>`;
      }
      alert(`Error cargando recorrido: ${error.message}`);
    }
    console.log('[Editor] STEP 7.12: cargarRecorrido end');
  }
  
  // Actualizar UI completa
  async function actualizarUI() {
    console.log('[Editor] STEP 7.9.1: actualizarUI start');
    
    if (!editorState.definition) {
      console.warn('[Editor] STEP 7.9.2: WARNING - definition es falsy, fail-open');
      // Fail-open: mostrar mensaje visible
      const stepsListEl = document.getElementById('steps-list');
      if (stepsListEl) {
        stepsListEl.innerHTML = '<p class="text-red-400 text-sm">‚ö†Ô∏è No hay datos para mostrar (fail-open)</p>';
      }
      // Actualizar badge de estado
      updatePublishStatusBadge();
      return;
    }
    
    console.log('[Editor] STEP 7.9.3: definition exists, steps count =', editorState.definition.steps ? Object.keys(editorState.definition.steps).length : 0);
    
    console.log('[Editor] STEP 7.9.4: calling renderStepsList()');
    renderStepsList();
    console.log('[Editor] STEP 7.9.5: renderStepsList() completed');
    
    if (editorState.selectedStepId) {
      console.log('[Editor] STEP 7.9.6: step selected, rendering config and preview');
      renderStepConfig();
      // FIX: renderPreview es async, debe ser awaited
      await renderPreview();
      console.log('[Editor] STEP 7.9.7: config and preview rendered');
    } else {
      console.log('[Editor] STEP 7.9.6: no step selected');
      // Asegurar que el preview muestra el mensaje cuando no hay step seleccionado
      const previewContainer = document.getElementById('preview-container');
      if (previewContainer) {
        previewContainer.innerHTML = '<div class="p-8 text-center text-slate-400"><p>Selecciona un step para ver el preview</p></div>';
      }
    }
    
    // Actualizar badge de estado
    updatePublishStatusBadge();
    console.log('[Editor] STEP 7.9.8: actualizarUI complete');
  }
  
  // Inicializar campo order en steps si no existe
  function initializeStepsOrder() {
    const steps = editorState.definition?.steps || {};
    const stepIds = Object.keys(steps);
    
    // CR√çTICO: Solo asignar order si NO existe. NUNCA pisar un order existente.
    // Esto preserva el orden establecido por el usuario mediante drag & drop.
    const hasAnyOrder = stepIds.some(stepId => typeof steps[stepId].order === 'number');
    
    if (!hasAnyOrder) {
      // Si ning√∫n step tiene order, inicializar todos
      stepIds.forEach((stepId, index) => {
        // Solo asignar si NO existe (doble verificaci√≥n defensiva)
        if (typeof steps[stepId].order !== 'number') {
          steps[stepId].order = index;
        }
      });
    } else {
      // Si algunos tienen order y otros no, asignar order solo a los que no lo tienen
      let maxOrder = -1;
      stepIds.forEach(stepId => {
        if (typeof steps[stepId].order === 'number') {
          maxOrder = Math.max(maxOrder, steps[stepId].order);
        }
      });
      
      stepIds.forEach(stepId => {
        // CR√çTICO: Solo asignar si NO existe. NUNCA pisar.
        if (typeof steps[stepId].order !== 'number') {
          steps[stepId].order = ++maxOrder;
        }
      });
    }
  }
  
  // Renderizar lista de steps
  function renderStepsList() {
    console.log('[RecorridosEditor] renderStepsList - INICIO');
    console.log('[RecorridosEditor] renderStepsList - editorState.definition:', editorState.definition);
    console.log('[RecorridosEditor] renderStepsList - editorState.definition?.steps:', editorState.definition?.steps);
    
    const container = document.getElementById('steps-list');
    console.log('[RecorridosEditor] renderStepsList - container:', container);
    console.log('[RecorridosEditor] renderStepsList - container es null?', container === null);
    
    if (!container) {
      console.error('[RecorridosEditor] renderStepsList - ERROR: container no existe');
      return;
    }
    
    const steps = editorState.definition?.steps || {};
    console.log('[RecorridosEditor] renderStepsList - steps:', steps);
    console.log('[RecorridosEditor] renderStepsList - steps es undefined?', steps === undefined);
    console.log('[RecorridosEditor] renderStepsList - steps es null?', steps === null);
    console.log('[RecorridosEditor] renderStepsList - steps es objeto?', typeof steps === 'object');
    console.log('[RecorridosEditor] renderStepsList - steps keys:', Object.keys(steps));
    console.log('[RecorridosEditor] renderStepsList - steps length:', Object.keys(steps).length);
    
    // Asegurar que todos los steps tengan campo order
    initializeStepsOrder();
    
    const stepIds = Object.keys(steps);
    console.log('[RecorridosEditor] renderStepsList - stepIds:', stepIds);
    console.log('[RecorridosEditor] renderStepsList - stepIds.length:', stepIds.length);
    
    if (stepIds.length === 0) {
      console.warn('[RecorridosEditor] renderStepsList - WARNING: No hay steps, mostrando mensaje');
      container.innerHTML = '<p class="text-slate-400 text-sm">No hay steps. Haz clic en ‚ûï para a√±adir uno.</p>';
      return;
    }
    
    // Ordenar steps por order (arriba ‚Üí abajo)
    const sortedStepIds = stepIds.sort((a, b) => {
      const orderA = steps[a].order ?? 0;
      const orderB = steps[b].order ?? 0;
      return orderA - orderB;
    });
    
    console.log('[RecorridosEditor] renderStepsList - sortedStepIds:', sortedStepIds);
    console.log('[RecorridosEditor] renderStepsList - Generando HTML...');
    
    const html = sortedStepIds.map(stepId => {
      const step = steps[stepId];
      const isActive = stepId === editorState.selectedStepId;
      console.log('[Editor] renderStepsList - stepId:', stepId, 'isActive:', isActive, 'selectedStepId:', editorState.selectedStepId);
      const stepType = step.step_type || 'N/A';
      const screenTemplate = step.screen_template_id || 'N/A';
      
      // Detectar si el step tiene handler_id y mostrar badge
      const handlerId = step.handler_id;
      const handler = window.HANDLER_INFO?.[handlerId];
      const handlerBadge = handler
        ? `<span class="handler-badge" title="${handler.description}">${handler.icon} ${handler.label}</span>`
        : '';
      
      return `
        <div class="step-item ${isActive ? 'active' : ''}" 
             draggable="true"
             data-step-id="${stepId}"
             ondragstart="handleDragStart(event, '${stepId}')"
             ondragover="handleDragOver(event)"
             ondrop="handleDrop(event, '${stepId}')"
             ondragend="handleDragEnd(event)"
             onclick="seleccionarStep('${stepId}')">
          <div class="step-header">
            <span class="step-id">${stepId}${handlerBadge}</span>
            <div class="step-actions" onclick="event.stopPropagation()">
              <button onclick="previewStep('${stepId}')" title="Preview">üëÅÔ∏è</button>
              <button onclick="eliminarStep('${stepId}')" title="Eliminar">üóëÔ∏è</button>
              <button onclick="duplicarStep('${stepId}')" title="Duplicar">üìã</button>
            </div>
          </div>
          <div class="step-type">${stepType} ‚Üí ${screenTemplate}</div>
        </div>
      `;
    }).join('');
    
      console.log('[Editor] STEP 7.9.4.1: HTML generated, length =', html.length);
      container.innerHTML = html;
      console.log('[Editor] STEP 7.9.4.2: innerHTML assigned to steps-list');
      
      // Asegurar event listeners usando event delegation como respaldo
      // Esto garantiza que los clicks funcionen incluso si los onclick inline fallan
      container.removeEventListener('click', handleStepListClick);
      container.addEventListener('click', handleStepListClick);
      console.log('[Editor] STEP 7.9.4.3: event delegation registered');
  }
  
  // Event delegation para clicks en steps (respaldo de onclick inline)
  function handleStepListClick(event) {
    // Buscar el elemento step-item m√°s cercano
    const stepItem = event.target.closest('.step-item');
    if (!stepItem) return;
    
    // Si el click fue en step-actions, no hacer nada (ya tiene stopPropagation)
    if (event.target.closest('.step-actions')) return;
    
    const stepId = stepItem.dataset.stepId;
    if (stepId) {
      console.log('[Editor] handleStepListClick - stepId clicked:', stepId);
      seleccionarStep(stepId);
    }
  }
  
  // Variables para drag & drop
  let draggedStepId = null;
  let draggedElement = null;
  
  // Manejar inicio de drag
  function handleDragStart(event, stepId) {
    draggedStepId = stepId;
    draggedElement = event.currentTarget;
    draggedElement.classList.add('dragging');
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', stepId);
  }
  
  // Manejar drag over
  function handleDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    
    const targetElement = event.currentTarget;
    if (targetElement && targetElement !== draggedElement) {
      // Remover clase de otros elementos
      document.querySelectorAll('.step-item.drag-over').forEach(el => {
        if (el !== targetElement) el.classList.remove('drag-over');
      });
      targetElement.classList.add('drag-over');
    }
  }
  
  // Manejar drop
  function handleDrop(event, targetStepId) {
    event.preventDefault();
    event.stopPropagation();
    
    if (!draggedStepId || draggedStepId === targetStepId) {
      return;
    }
    
    try {
      const steps = editorState.definition?.steps || {};
      const stepIds = Object.keys(steps);
      
      // Ordenar steps por order actual
      const sortedStepIds = [...stepIds].sort((a, b) => {
        const orderA = steps[a].order ?? 0;
        const orderB = steps[b].order ?? 0;
        return orderA - orderB;
      });
      
      // Obtener √≠ndices actuales en el array ordenado
      const draggedIndex = sortedStepIds.findIndex(id => id === draggedStepId);
      const targetIndex = sortedStepIds.findIndex(id => id === targetStepId);
      
      if (draggedIndex === -1 || targetIndex === -1) {
        return;
      }
      
      // Remover el elemento arrastrado de su posici√≥n
      sortedStepIds.splice(draggedIndex, 1);
      
      // Calcular la nueva posici√≥n de inserci√≥n
      // Queremos insertar el elemento arrastrado justo antes del objetivo
      // Despu√©s de remover el arrastrado:
      // - Si el arrastrado estaba antes del objetivo, el objetivo ahora est√° en (targetIndex - 1)
      // - Si el arrastrado estaba despu√©s del objetivo, el objetivo sigue en targetIndex
      let insertIndex;
      if (draggedIndex < targetIndex) {
        // El objetivo se movi√≥ una posici√≥n hacia arriba
        insertIndex = targetIndex - 1;
      } else {
        // El objetivo no cambi√≥ de posici√≥n
        insertIndex = targetIndex;
      }
      
      // Insertar en la nueva posici√≥n (antes del objetivo)
      sortedStepIds.splice(insertIndex, 0, draggedStepId);
      
      // Recalcular order para todos los steps
      sortedStepIds.forEach((stepId, index) => {
        steps[stepId].order = index;
      });
      
      // Mantener el step seleccionado si existe
      const selectedStepId = editorState.selectedStepId;
      
      // Marcar como dirty y programar guardado inmediato
      markDirty();
      updateValidationState();
      tryScheduleSave();
      
      // Re-renderizar
      actualizarUI();
      
      // Restaurar selecci√≥n
      if (selectedStepId) {
        editorState.selectedStepId = selectedStepId;
        actualizarUI();
      }
      
    } catch (error) {
      console.error('Error reordenando steps:', error);
      // Fail-open: mantener orden original
      actualizarUI();
    }
  }
  
  // Manejar fin de drag
  function handleDragEnd(event) {
    // Remover clases de drag
    document.querySelectorAll('.step-item.dragging, .step-item.drag-over').forEach(el => {
      el.classList.remove('dragging', 'drag-over');
    });
    
    draggedStepId = null;
    draggedElement = null;
  }
  
  // Seleccionar step
  function seleccionarStep(stepId) {
    console.log('[Editor] seleccionarStep called with stepId:', stepId);
    editorState.selectedStepId = stepId;
    console.log('[Editor] selectedStepId updated to:', editorState.selectedStepId);
    actualizarUI();
  }
  
  // Asegurar que seleccionarStep est√© disponible globalmente
  window.seleccionarStep = seleccionarStep;
  
  // A√±adir step
  // BLINDAJE v2: Valida ID de step como slug
  function a√±adirStep() {
    const stepIdRaw = prompt('ID del step (ej: step_bienvenida, paso_2):');
    if (!stepIdRaw) return;
    
    // Generar slug del ID
    const stepId = generateSlug(stepIdRaw) || stepIdRaw.toLowerCase().replace(/[^a-z0-9_]/g, '_');
    
    if (!stepId || stepId.length < 2) {
      alert('El ID del step debe tener al menos 2 caracteres v√°lidos');
      return;
    }
    
    if (editorState.definition.steps[stepId]) {
      alert(`Ya existe un step con el ID "${stepId}"`);
      return;
    }
    
    // Calcular el order m√°ximo actual
    const existingSteps = Object.values(editorState.definition.steps || {});
    const maxOrder = existingSteps.length > 0
      ? Math.max(...existingSteps.map(s => typeof s.order === 'number' ? s.order : -1))
      : -1;
    
    editorState.definition.steps[stepId] = {
      screen_template_id: 'blank',
      props: {},
      order: maxOrder + 1
    };
    
    // Si es el primer step, establecerlo como entry
    if (Object.keys(editorState.definition.steps).length === 1) {
      editorState.definition.entry_step_id = stepId;
    }
    
    // BLINDAJE v2: Marcar dirty y validar, luego intentar guardar
    markDirty();
    tryScheduleSave();
    seleccionarStep(stepId);
  }
  
  // Eliminar step
  function eliminarStep(stepId) {
    if (!confirm(`¬øEliminar el step "${stepId}"?\n\nTambi√©n se eliminar√°n los edges que lo referencian.`)) return;
    
    delete editorState.definition.steps[stepId];
    
    // Eliminar edges que referencian este step
    editorState.definition.edges = editorState.definition.edges.filter(edge => 
      edge.from_step_id !== stepId && edge.to_step_id !== stepId
    );
    
    // Si era el entry step, cambiar a otro
    if (editorState.definition.entry_step_id === stepId) {
      const remainingSteps = Object.keys(editorState.definition.steps);
      editorState.definition.entry_step_id = remainingSteps[0] || null;
    }
    
    if (editorState.selectedStepId === stepId) {
      editorState.selectedStepId = null;
    }
    
    // BLINDAJE v2: Marcar dirty y validar, luego intentar guardar
    markDirty();
    tryScheduleSave();
    actualizarUI();
  }
  
  // Duplicar step
  // BLINDAJE v2: Valida nuevo ID como slug
  function duplicarStep(stepId) {
    const defaultNewId = `${stepId}_copia`;
    const newStepIdRaw = prompt('ID del nuevo step:', defaultNewId);
    if (!newStepIdRaw) return;
    
    // Generar slug del ID
    const newStepId = generateSlug(newStepIdRaw) || newStepIdRaw.toLowerCase().replace(/[^a-z0-9_]/g, '_');
    
    if (!newStepId || newStepId.length < 2) {
      alert('El ID del step debe tener al menos 2 caracteres v√°lidos');
      return;
    }
    
    if (editorState.definition.steps[newStepId]) {
      alert(`Ya existe un step con el ID "${newStepId}"`);
      return;
    }
    
    editorState.definition.steps[newStepId] = JSON.parse(JSON.stringify(editorState.definition.steps[stepId]));
    
    // Asignar un nuevo order al step duplicado (al final)
    const existingSteps = Object.values(editorState.definition.steps || {});
    const maxOrder = existingSteps.length > 0
      ? Math.max(...existingSteps.map(s => typeof s.order === 'number' ? s.order : -1))
      : -1;
    editorState.definition.steps[newStepId].order = maxOrder + 1;
    
    // BLINDAJE v2: Marcar dirty y validar, luego intentar guardar
    markDirty();
    tryScheduleSave();
    seleccionarStep(newStepId);
  }
  
  // Renderizar configuraci√≥n del step
  function renderStepConfig() {
    const panel = document.getElementById('config-panel');
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step) return;
    
    const stepTypes = editorState.registry?.stepTypes || [];
    const screenTemplates = editorState.registry?.screenTemplates || [];
    
    // Detectar si es un step tipo motor
    if (step.type === 'motor') {
      renderMotorConfigPanel(step);
      return;
    }
    
    // Filtrar screen templates compatibles con el step type seleccionado
    const compatibleTemplates = step.screen_template_id 
      ? screenTemplates.filter(t => t.id === step.screen_template_id || !step.step_type)
      : screenTemplates;
    
    panel.innerHTML = `
      <h2 class="text-xl font-bold text-white mb-4">Configuraci√≥n: ${editorState.selectedStepId}</h2>
      
      <div class="config-section">
        <h3>Step Type</h3>
        <div class="form-group">
          <label>Step Type</label>
          <select id="config-step-type" onchange="actualizarStepType()">
            <option value="">Seleccionar...</option>
            ${stepTypes.map(st => `
              <option value="${st.id}" ${step.step_type === st.id ? 'selected' : ''}>${st.name || st.id}</option>
            `).join('')}
          </select>
        </div>
      </div>
      
      <div class="config-section">
        <h3>Screen Template</h3>
        <div class="form-group">
          <label>Screen Template</label>
          <select id="config-screen-template" onchange="actualizarScreenTemplate()">
            <option value="">Seleccionar...</option>
            ${screenTemplates.map(st => `
              <option value="${st.id}" ${step.screen_template_id === st.id ? 'selected' : ''}>${st.name || st.id}</option>
            `).join('')}
          </select>
        </div>
      </div>
      
      <div class="config-section">
        <h3>Props</h3>
        <div id="config-props">
          ${renderPropsEditor(step)}
        </div>
      </div>
      
      <div class="config-section">
        <h3>Capture</h3>
        <div class="form-group">
          <label>Capture Variable</label>
          <input type="text" id="config-capture" value="${step.capture || ''}" 
                 onchange="actualizarCapture()" placeholder="variable_name">
        </div>
      </div>
      
      <div class="config-section">
        <h3>Branches (Edges)</h3>
        <div id="config-branches">
          ${renderBranchesEditor(step)}
        </div>
      </div>
      
      <div class="config-section">
        <h3>Emit Events</h3>
        <div id="config-events">
          ${renderEventsEditor(step)}
        </div>
      </div>
    `;
    
    // Actualizar badge de estado despu√©s de renderizar
    updatePublishStatusBadge();
  }
  
  // ============================================================================
  // EDITOR DE MOTOR PDE
  // ============================================================================
  
  // Estado global para el motor seleccionado
  let selectedMotorData = null;
  
  /**
   * Renderiza el panel de configuraci√≥n espec√≠fico para steps tipo motor
   */
  async function renderMotorConfigPanel(step) {
    const panel = document.getElementById('config-panel');
    
    // Inicializar step como motor si no lo es
    if (step.type !== 'motor') {
      step.type = 'motor';
      step.motor_key = step.motor_key || '';
      step.motor_version = step.motor_version || undefined;
      step.inputs = step.inputs || {};
    }
    
    // Cargar motores published si no est√°n cargados
    let motorsList = [];
    try {
      const response = await fetch('/admin/pde/motors?status=published');
      if (response.ok) {
        const data = await response.json();
        motorsList = data.motors || [];
      }
    } catch (error) {
      console.error('Error cargando motores:', error);
    }
    
    // Si hay un motor_key seleccionado, cargar sus datos
    if (step.motor_key && !selectedMotorData) {
      try {
        const motor = motorsList.find(m => m.motor_key === step.motor_key);
        if (motor) {
          selectedMotorData = motor;
          // Si no hay motor_version o no coincide, actualizarlo
          if (!step.motor_version || step.motor_version !== motor.version) {
            step.motor_version = motor.version;
            markDirty();
          }
        }
      } catch (error) {
        console.error('Error obteniendo motor:', error);
      }
    }
    
    // Si cambi√≥ el motor_key, resetear selectedMotorData
    if (step.motor_key && selectedMotorData && selectedMotorData.motor_key !== step.motor_key) {
      selectedMotorData = null;
      step.inputs = {}; // Resetear inputs al cambiar motor
    }
    
    panel.innerHTML = `
      <h2 class="text-xl font-bold text-white mb-4">Configuraci√≥n: ${editorState.selectedStepId}</h2>
      
      <div class="config-section">
        <h3>Step Type</h3>
        <div class="form-group">
          <label>Step Type</label>
          <select id="config-step-type" onchange="actualizarStepType()">
            <option value="">Seleccionar...</option>
            ${(editorState.registry?.stepTypes || []).map(st => `
              <option value="${st.id}" ${step.step_type === st.id ? 'selected' : ''}>${st.name || st.id}</option>
            `).join('')}
          </select>
        </div>
      </div>
      
      <div class="config-section">
        <h3>üß† Configuraci√≥n del Motor PDE</h3>
        <div class="form-group">
          <label>Motor PDE (Published) <span class="text-red-400">*</span></label>
          <select id="config-motor-key" onchange="actualizarMotorKey(this.value)">
            <option value="">Seleccionar motor...</option>
            ${motorsList.map(motor => `
              <option value="${motor.motor_key}" 
                      data-version="${motor.version}"
                      ${step.motor_key === motor.motor_key ? 'selected' : ''}>
                ${motor.name || motor.motor_key} (v${motor.version}) - ${motor.motor_key}
              </option>
            `).join('')}
          </select>
          <p class="text-xs text-slate-400 mt-1">Solo se muestran motores con status = published</p>
        </div>
        
        ${step.motor_key && selectedMotorData ? `
          <div class="mt-4 p-3 bg-slate-800 rounded-lg border border-slate-600">
            <h4 class="text-sm font-semibold text-white mb-2">Informaci√≥n del Motor</h4>
            <p class="text-xs text-slate-300"><strong>Nombre:</strong> ${selectedMotorData.name || 'N/A'}</p>
            <p class="text-xs text-slate-300"><strong>Clave:</strong> ${selectedMotorData.motor_key}</p>
            <p class="text-xs text-slate-300"><strong>Versi√≥n:</strong> ${selectedMotorData.version}</p>
            ${selectedMotorData.description ? `<p class="text-xs text-slate-300 mt-1"><strong>Descripci√≥n:</strong> ${selectedMotorData.description}</p>` : ''}
          </div>
        ` : ''}
      </div>
      
      ${step.motor_key && selectedMotorData ? `
        <div class="config-section">
          <h3>üì• Inputs del Motor</h3>
          <div id="config-motor-inputs">
            ${renderMotorInputs(step, selectedMotorData)}
          </div>
        </div>
      ` : step.motor_key ? `
        <div class="config-section">
          <p class="text-amber-400 text-sm">‚ö†Ô∏è Cargando informaci√≥n del motor...</p>
        </div>
      ` : ''}
      
      <div class="config-section">
        <h3>Branches (Edges)</h3>
        <div id="config-branches">
          ${renderBranchesEditor(step)}
        </div>
      </div>
    `;
    
    // Si hay motor_key pero no selectedMotorData, cargarlo
    if (step.motor_key && !selectedMotorData) {
      await cargarMotorData(step.motor_key);
    }
    
    // Actualizar badge de estado despu√©s de renderizar
    updatePublishStatusBadge();
  }
  
  /**
   * Carga los datos de un motor por su motor_key
   */
  async function cargarMotorData(motorKey) {
    try {
      const motorsResponse = await fetch('/admin/pde/motors?status=published');
      if (motorsResponse.ok) {
        const motorsData = await motorsResponse.json();
        const motor = motorsData.motors?.find(m => m.motor_key === motorKey);
        if (motor) {
          selectedMotorData = motor;
          renderStepConfig(); // Re-renderizar para mostrar inputs
        }
      }
    } catch (error) {
      console.error('Error cargando motor:', error);
    }
  }
  
  /**
   * Renderiza los inputs del motor din√°micamente
   */
  function renderMotorInputs(step, motor) {
    const inputs = motor.definition?.inputs || [];
    const stepInputs = step.inputs || {};
    
    if (inputs.length === 0) {
      return '<p class="text-slate-400 text-sm">Este motor no tiene inputs definidos.</p>';
    }
    
    return inputs.map(input => {
      const inputValue = stepInputs[input.key] || '';
      const isRequired = input.required === true;
      
      let inputHtml = '';
      
      // Renderizar seg√∫n el tipo
      if (input.type === 'string') {
        inputHtml = `
          <input type="text" 
                 id="motor-input-${input.key}"
                 value="${escapeHtml(inputValue)}"
                 onchange="actualizarMotorInput('${input.key}', this.value)"
                 placeholder="Valor o {{context.variable}}"
                 class="w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded text-white text-sm"
                 ${isRequired ? 'required' : ''}>
        `;
      } else if (input.type === 'number') {
        // Para inputs number, permitir tanto n√∫meros literales como bindings ({{context.variable}})
        // Usar type="text" para permitir escribir bindings libremente
        // La validaci√≥n del tipo se hace en runtime, no en el editor
        inputHtml = `
          <input type="text" 
                 id="motor-input-${input.key}"
                 value="${escapeHtml(String(inputValue || ''))}"
                 onchange="actualizarMotorInput('${input.key}', this.value)"
                 placeholder="N√∫mero o {{context.variable}}"
                 class="w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded text-white text-sm"
                 ${isRequired ? 'required' : ''}>
        `;
      } else if (input.type === 'boolean') {
        inputHtml = `
          <select id="motor-input-${input.key}"
                  onchange="actualizarMotorInput('${input.key}', this.value)"
                  class="w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded text-white text-sm"
                  ${isRequired ? 'required' : ''}>
            <option value="">Seleccionar...</option>
            <option value="true" ${inputValue === 'true' || inputValue === true ? 'selected' : ''}>S√≠</option>
            <option value="false" ${inputValue === 'false' || inputValue === false ? 'selected' : ''}>No</option>
            <option value="{{context.${input.key}}}" ${inputValue && inputValue.startsWith('{{context.') ? 'selected' : ''}>Desde contexto</option>
          </select>
        `;
      } else if (input.type === 'enum' || input.type === 'select') {
        const options = input.options || [];
        inputHtml = `
          <select id="motor-input-${input.key}"
                  onchange="actualizarMotorInput('${input.key}', this.value)"
                  class="w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded text-white text-sm"
                  ${isRequired ? 'required' : ''}>
            <option value="">Seleccionar...</option>
            ${options.map(opt => {
              const optValue = typeof opt === 'string' ? opt : opt.value || opt;
              const optLabel = typeof opt === 'string' ? opt : opt.label || opt.value || opt;
              return `<option value="${escapeHtml(optValue)}" ${inputValue === optValue ? 'selected' : ''}>${escapeHtml(optLabel)}</option>`;
            }).join('')}
            <option value="{{context.${input.key}}}" ${inputValue && inputValue.startsWith('{{context.') ? 'selected' : ''}>Desde contexto</option>
          </select>
        `;
      } else if (input.type === 'pde_catalog') {
        // Para cat√°logos PDE, solo mostrar informaci√≥n (read-only)
        inputHtml = `
          <div class="p-3 bg-slate-700 rounded border border-slate-600">
            <p class="text-xs text-slate-300"><strong>Cat√°logo PDE:</strong> ${input.catalog_key || 'N/A'}</p>
            <p class="text-xs text-slate-400 mt-1">Este input usa un cat√°logo PDE. El valor se obtiene del contexto del recorrido.</p>
            <input type="text" 
                   id="motor-input-${input.key}"
                   value="${escapeHtml(inputValue)}"
                   onchange="actualizarMotorInput('${input.key}', this.value)"
                   placeholder="{{context.${input.key}}}"
                   class="w-full mt-2 px-3 py-2 bg-slate-800 border border-slate-600 rounded text-white text-sm"
                   ${isRequired ? 'required' : ''}>
          </div>
        `;
      } else {
        // Tipo desconocido, input de texto gen√©rico
        inputHtml = `
          <input type="text" 
                 id="motor-input-${input.key}"
                 value="${escapeHtml(inputValue)}"
                 onchange="actualizarMotorInput('${input.key}', this.value)"
                 placeholder="Valor o {{context.variable}}"
                 class="w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded text-white text-sm"
                 ${isRequired ? 'required' : ''}>
        `;
      }
      
      return `
        <div class="form-group mb-4">
          <label class="block text-sm text-white mb-1">
            ${input.key} ${isRequired ? '<span class="text-red-400">*</span>' : ''}
            <span class="text-xs text-slate-400 ml-2">(${input.type})</span>
          </label>
          ${inputHtml}
          ${input.description ? `<p class="text-xs text-slate-400 mt-1">${escapeHtml(input.description)}</p>` : ''}
        </div>
      `;
    }).join('');
  }
  
  /**
   * Actualiza el motor_key del step
   */
  async function actualizarMotorKey(motorKey) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step) return;
    
    const select = document.getElementById('config-motor-key');
    const selectedOption = select.options[select.selectedIndex];
    const motorVersion = selectedOption ? parseInt(selectedOption.dataset.version) : undefined;
    
    // Si cambi√≥ el motor, resetear inputs y mostrar warning
    if (step.motor_key && step.motor_key !== motorKey) {
      step.inputs = {};
      // Mostrar warning suave
      const warningEl = document.createElement('div');
      warningEl.className = 'bg-amber-900 border border-amber-600 text-amber-200 px-3 py-2 rounded text-sm mt-2';
      warningEl.textContent = '‚ö†Ô∏è Los inputs se han reiniciado';
      select.parentElement.appendChild(warningEl);
      setTimeout(() => warningEl.remove(), 3000);
    }
    
    step.motor_key = motorKey || undefined;
    step.motor_version = motorVersion;
    selectedMotorData = null; // Resetear para forzar recarga
    
    markDirty();
    tryScheduleSave();
    
    // Re-renderizar para mostrar inputs del nuevo motor
    await renderStepConfig();
  }
  
  /**
   * Actualiza un input del motor
   */
  function actualizarMotorInput(inputKey, value) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step) return;
    
    if (!step.inputs) {
      step.inputs = {};
    }
    
    if (value === '' || value === null || value === undefined) {
      delete step.inputs[inputKey];
    } else {
      step.inputs[inputKey] = value;
    }
    
    markDirty();
    tryScheduleSave();
  }
  
  /**
   * Helper para escapar HTML
   */
  function escapeHtml(text) {
    if (text == null) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // ============================================================================
  // EDITOR DE PROPS - Screen Templates
  // ============================================================================
  // 
  // Renderiza campos visuales espec√≠ficos seg√∫n el template
  // screen_text: t√≠tulo, subt√≠tulo, contenido (textarea grande)
  // Otros: editor gen√©rico basado en schema
  //
  
  /**
   * Renderiza el editor de screen_video con campos visuales espec√≠ficos
   * Campos bien delimitados como en Typeform
   */
  function renderScreenVideoEditor(step) {
    const props = step.props || {};
    const videoSource = props.video_source || '';
    const displayMode = props.display_mode || 'inline';
    
    // Obtener template y campos publish_required
    const template = editorState.registry?.screenTemplates?.find(st => st.id === step.screen_template_id);
    const publishRequired = template?.editor_config?.publish_required || [];
    
    // Funci√≥n helper para generar badge de requerido
    const getRequiredBadge = (propName) => {
      const isRequired = publishRequired.includes(propName);
      return isRequired 
        ? '<span class="required-badge" title="Obligatorio para publicar">*</span>'
        : '';
    };
    
    // Placeholder din√°mico seg√∫n el origen del v√≠deo
    const videoRefPlaceholder = videoSource === 'internal' 
      ? 'ID del v√≠deo en el banco interno' 
      : 'ID o URL del v√≠deo de YouTube';
    
    // Estado de completitud para publicar
    const isReadyToPublish = videoSource && props.video_ref;
    
    return `
      <div class="screen-video-editor">
        <!-- T√≠tulo -->
        <div class="form-group">
          <label>
            üé¨ T√≠tulo${getRequiredBadge('title')}
            ${!publishRequired.includes('title') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-video-title"
                 value="${escapeHtml(props.title || '')}" 
                 onchange="actualizarVideoPropConDebounce('title', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="Ej: Introducci√≥n al m√≥dulo"
                 maxlength="200"
                 class="screen-video-input">
          <p class="text-xs text-slate-500 mt-1">T√≠tulo opcional de la pantalla</p>
        </div>
        
        <!-- Descripci√≥n -->
        <div class="form-group">
          <label>
            üìù Descripci√≥n${getRequiredBadge('description')}
            ${!publishRequired.includes('description') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <textarea id="prop-video-description"
                    onchange="actualizarVideoPropConDebounce('description', this.value)"
                    oninput="markDirtyOnly()"
                    placeholder="Texto opcional antes o despu√©s del v√≠deo"
                    maxlength="500"
                    rows="3"
                    class="screen-video-textarea">${escapeHtml(props.description || '')}</textarea>
          <p class="text-xs text-slate-500 mt-1">Texto descriptivo que acompa√±a al v√≠deo</p>
        </div>
        
        <!-- Origen del v√≠deo -->
        <div class="form-group">
          <label>
            üì∫ Origen del v√≠deo${getRequiredBadge('video_source')}
            ${publishRequired.includes('video_source') ? '<span class="text-amber-400 text-xs font-normal ml-2">‚ö†Ô∏è Obligatorio para publicar</span>' : ''}
          </label>
          <select id="prop-video-source"
                  onchange="actualizarVideoSource(this.value)"
                  class="screen-video-select">
            <option value="" ${!videoSource ? 'selected' : ''}>Seleccionar origen...</option>
            <option value="youtube" ${videoSource === 'youtube' ? 'selected' : ''}>üì∫ YouTube</option>
            <option value="internal" ${videoSource === 'internal' ? 'selected' : ''}>üé• V√≠deo interno</option>
          </select>
          <p class="text-xs text-slate-500 mt-1">
            ${publishRequired.includes('video_source') 
              ? '¬øDe d√≥nde proviene el v√≠deo?' 
              : '¬øDe d√≥nde proviene el v√≠deo? <span class="text-blue-400">(Opcional: si no se define, no se mostrar√°)</span>'}
          </p>
        </div>
        
        <!-- Referencia del v√≠deo -->
        <div class="form-group">
          <label>
            üîó Referencia del v√≠deo${getRequiredBadge('video_ref')}
            ${publishRequired.includes('video_ref') ? '<span class="text-amber-400 text-xs font-normal ml-2">‚ö†Ô∏è Obligatorio para publicar</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-video-ref"
                 value="${escapeHtml(props.video_ref || '')}" 
                 onchange="actualizarVideoPropConDebounce('video_ref', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="${videoRefPlaceholder}"
                 maxlength="500"
                 class="screen-video-input">
          <p class="text-xs text-slate-500 mt-1">
            ${publishRequired.includes('video_ref')
              ? (videoSource === 'youtube' 
                  ? 'Puedes pegar la URL completa o solo el ID del v√≠deo (ej: dQw4w9WgXcQ)' 
                  : videoSource === 'internal'
                    ? 'ID del v√≠deo en el banco de v√≠deos interno'
                    : 'Selecciona primero el origen del v√≠deo')
              : (videoSource === 'youtube' 
                  ? 'Puedes pegar la URL completa o solo el ID del v√≠deo (ej: dQw4w9WgXcQ). <span class="text-blue-400">Opcional: si no se define, no se mostrar√°.</span>' 
                  : videoSource === 'internal'
                    ? 'ID del v√≠deo en el banco de v√≠deos interno. <span class="text-blue-400">Opcional: si no se define, no se mostrar√°.</span>'
                    : 'Selecciona primero el origen del v√≠deo. <span class="text-blue-400">Opcional: si no se define, no se mostrar√°.</span>')}
          </p>
        </div>
        
        <!-- Modo de visualizaci√≥n -->
        <div class="form-group">
          <label>
            üëÅÔ∏è Modo de visualizaci√≥n
            <span class="text-slate-500 text-xs font-normal ml-2">(por defecto: inline)</span>
          </label>
          <div class="screen-video-radio-group">
            <div class="screen-video-radio-item ${displayMode === 'inline' ? 'active' : ''}"
                 onclick="actualizarVideoDisplayMode('inline')">
              <input type="radio" name="display_mode" value="inline" 
                     ${displayMode === 'inline' ? 'checked' : ''} id="display-inline">
              <label for="display-inline">‚ñ∂Ô∏è Inline</label>
            </div>
            <div class="screen-video-radio-item ${displayMode === 'collapsed' ? 'active' : ''}"
                 onclick="actualizarVideoDisplayMode('collapsed')">
              <input type="radio" name="display_mode" value="collapsed" 
                     ${displayMode === 'collapsed' ? 'checked' : ''} id="display-collapsed">
              <label for="display-collapsed">üì¶ Colapsado</label>
            </div>
          </div>
          <p class="text-xs text-slate-500 mt-2">
            <strong>Inline:</strong> El v√≠deo se muestra directamente visible<br>
            <strong>Colapsado:</strong> El usuario debe hacer click para ver el v√≠deo
          </p>
        </div>
        
        <!-- Duraci√≥n declarada (para futuro) -->
        <div class="form-group">
          <label>
            ‚è±Ô∏è Duraci√≥n estimada
            <span class="text-slate-500 text-xs font-normal ml-2">(opcional, para reloj futuro)</span>
          </label>
          <div class="flex items-center gap-2">
            <input type="number" 
                   id="prop-video-duration"
                   value="${props.declared_duration_minutes || ''}" 
                   onchange="actualizarVideoPropConDebounce('declared_duration_minutes', this.value ? parseFloat(this.value) : null)"
                   oninput="markDirtyOnly()"
                   placeholder="0"
                   min="0"
                   max="240"
                   class="screen-video-number">
            <span class="text-slate-400 text-sm">minutos</span>
          </div>
          <p class="text-xs text-slate-500 mt-1">Se usar√° en el futuro para el reloj del recorrido (no se muestra a√∫n)</p>
        </div>
        
        <!-- Indicador de estado -->
        <div class="screen-video-status mt-4 p-3 rounded ${isReadyToPublish ? 'bg-green-900/30 border border-green-700' : 'bg-amber-900/30 border border-amber-700'}">
          ${isReadyToPublish 
            ? '<span class="text-green-400">‚úÖ Listo para publicar</span>' 
            : '<span class="text-amber-400">‚ö†Ô∏è Selecciona origen y referencia del v√≠deo para poder publicar</span>'}
        </div>
      </div>
    `;
  }
  
  /**
   * Actualiza prop de video con debounce
   */
  let videoPropDebounceTimer = null;
  function actualizarVideoPropConDebounce(key, value) {
    if (!editorState.definition.steps[editorState.selectedStepId].props) {
      editorState.definition.steps[editorState.selectedStepId].props = {};
    }
    editorState.definition.steps[editorState.selectedStepId].props[key] = value;
    
    markDirty();
    renderPreview();
    
    if (videoPropDebounceTimer) {
      clearTimeout(videoPropDebounceTimer);
    }
    videoPropDebounceTimer = setTimeout(() => {
      tryScheduleSave();
    }, 1500);
  }
  
  /**
   * Actualiza el origen del v√≠deo (YouTube o interno)
   */
  function actualizarVideoSource(value) {
    if (!editorState.definition.steps[editorState.selectedStepId].props) {
      editorState.definition.steps[editorState.selectedStepId].props = {};
    }
    editorState.definition.steps[editorState.selectedStepId].props.video_source = value || undefined;
    
    markDirty();
    renderStepConfig(); // Re-render para actualizar placeholder
    renderPreview();
    tryScheduleSave();
  }
  
  /**
   * Actualiza el modo de visualizaci√≥n (inline o collapsed)
   */
  function actualizarVideoDisplayMode(mode) {
    if (!editorState.definition.steps[editorState.selectedStepId].props) {
      editorState.definition.steps[editorState.selectedStepId].props = {};
    }
    editorState.definition.steps[editorState.selectedStepId].props.display_mode = mode;
    
    markDirty();
    renderStepConfig(); // Re-render para actualizar radio buttons
    renderPreview();
    tryScheduleSave();
  }
  
  // ============================================================================
  // EDITOR DE screen_audio
  // ============================================================================
  
  /**
   * Renderiza el editor de screen_audio con campos visuales espec√≠ficos
   * Campos bien delimitados siguiendo el patr√≥n de screen_video
   */
  function renderScreenAudioEditor(step) {
    const props = step.props || {};
    const audioSource = props.audio_source || '';
    
    // Obtener template y campos publish_required
    const template = editorState.registry?.screenTemplates?.find(st => st.id === step.screen_template_id);
    const publishRequired = template?.editor_config?.publish_required || [];
    
    // Funci√≥n helper para generar badge de requerido
    const getRequiredBadge = (propName) => {
      const isRequired = publishRequired.includes(propName);
      return isRequired 
        ? '<span class="required-badge" title="Obligatorio para publicar">*</span>'
        : '';
    };
    
    // Placeholder din√°mico seg√∫n el origen del audio
    const audioRefPlaceholder = audioSource === 'internal' 
      ? 'ID del audio en el banco interno' 
      : 'URL del audio externo';
    
    // Estado de completitud para publicar
    const isReadyToPublish = audioSource && props.audio_ref;
    
    return `
      <div class="screen-audio-editor">
        <!-- T√≠tulo -->
        <div class="form-group">
          <label>
            üéµ T√≠tulo${getRequiredBadge('title')}
            ${!publishRequired.includes('title') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-audio-title"
                 value="${escapeHtml(props.title || '')}" 
                 onchange="actualizarAudioPropConDebounce('title', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="Ej: Meditaci√≥n guiada"
                 maxlength="200"
                 class="screen-audio-input">
          <p class="text-xs text-slate-500 mt-1">T√≠tulo opcional de la pantalla</p>
        </div>
        
        <!-- Subt√≠tulo -->
        <div class="form-group">
          <label>
            üìù Subt√≠tulo${getRequiredBadge('subtitle')}
            ${!publishRequired.includes('subtitle') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-audio-subtitle"
                 value="${escapeHtml(props.subtitle || '')}" 
                 onchange="actualizarAudioPropConDebounce('subtitle', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="Ej: 5 minutos de relajaci√≥n"
                 maxlength="500"
                 class="screen-audio-input">
          <p class="text-xs text-slate-500 mt-1">Texto descriptivo debajo del t√≠tulo</p>
        </div>
        
        <!-- Origen del audio -->
        <div class="form-group">
          <label>
            üìª Origen del audio${getRequiredBadge('audio_source')}
            ${publishRequired.includes('audio_source') ? '<span class="text-amber-400 text-xs font-normal ml-2">‚ö†Ô∏è Obligatorio para publicar</span>' : ''}
          </label>
          <select id="prop-audio-source"
                  onchange="actualizarAudioSource(this.value)"
                  class="screen-audio-select">
            <option value="" ${!audioSource ? 'selected' : ''}>Seleccionar origen...</option>
            <option value="internal" ${audioSource === 'internal' ? 'selected' : ''}>üéß Audio interno</option>
            <option value="external" ${audioSource === 'external' ? 'selected' : ''}>üåê Audio externo (URL)</option>
          </select>
          <p class="text-xs text-slate-500 mt-1">
            ${publishRequired.includes('audio_source') 
              ? '¬øDe d√≥nde proviene el audio?' 
              : '¬øDe d√≥nde proviene el audio? <span class="text-blue-400">(Opcional: si no se define, no se mostrar√°)</span>'}
          </p>
        </div>
        
        <!-- Referencia del audio -->
        <div class="form-group">
          <label>
            üîó Referencia del audio${getRequiredBadge('audio_ref')}
            ${publishRequired.includes('audio_ref') ? '<span class="text-amber-400 text-xs font-normal ml-2">‚ö†Ô∏è Obligatorio para publicar</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-audio-ref"
                 value="${escapeHtml(props.audio_ref || '')}" 
                 onchange="actualizarAudioPropConDebounce('audio_ref', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="${audioRefPlaceholder}"
                 maxlength="500"
                 class="screen-audio-input">
          <p class="text-xs text-slate-500 mt-1">
            ${publishRequired.includes('audio_ref')
              ? (audioSource === 'internal'
                  ? 'ID del audio en el banco de audios interno'
                  : audioSource === 'external'
                    ? 'URL completa del archivo de audio'
                    : 'Selecciona primero el origen del audio')
              : (audioSource === 'internal'
                  ? 'ID del audio en el banco de audios interno. <span class="text-blue-400">Opcional: si no se define, no se mostrar√°.</span>'
                  : audioSource === 'external'
                    ? 'URL completa del archivo de audio. <span class="text-blue-400">Opcional: si no se define, no se mostrar√°.</span>'
                    : 'Selecciona primero el origen del audio. <span class="text-blue-400">Opcional: si no se define, no se mostrar√°.</span>')}
          </p>
        </div>
        
        <!-- Duraci√≥n declarada (para futuro) -->
        <div class="form-group">
          <label>
            ‚è±Ô∏è Duraci√≥n estimada
            <span class="text-slate-500 text-xs font-normal ml-2">(opcional, para reloj futuro)</span>
          </label>
          <div class="flex items-center gap-2">
            <input type="number" 
                   id="prop-audio-duration"
                   value="${props.declared_duration_minutes || ''}" 
                   onchange="actualizarAudioPropConDebounce('declared_duration_minutes', this.value ? parseFloat(this.value) : null)"
                   oninput="markDirtyOnly()"
                   placeholder="0"
                   min="0"
                   max="240"
                   class="screen-audio-number">
            <span class="text-slate-400 text-sm">minutos</span>
          </div>
          <p class="text-xs text-slate-500 mt-1">Se usar√° en el futuro para el reloj del recorrido (no se muestra a√∫n)</p>
        </div>
        
        <!-- Indicador de estado -->
        <div class="screen-audio-status mt-4 p-3 rounded ${isReadyToPublish ? 'bg-green-900/30 border border-green-700' : 'bg-amber-900/30 border border-amber-700'}">
          ${isReadyToPublish 
            ? '<span class="text-green-400">‚úÖ Listo para publicar</span>' 
            : '<span class="text-amber-400">‚ö†Ô∏è Selecciona origen y referencia del audio para poder publicar</span>'}
        </div>
      </div>
    `;
  }
  
  /**
   * Actualiza prop de audio con debounce
   */
  let audioPropDebounceTimer = null;
  function actualizarAudioPropConDebounce(key, value) {
    if (!editorState.definition.steps[editorState.selectedStepId].props) {
      editorState.definition.steps[editorState.selectedStepId].props = {};
    }
    editorState.definition.steps[editorState.selectedStepId].props[key] = value;
    
    markDirty();
    renderPreview();
    
    if (audioPropDebounceTimer) {
      clearTimeout(audioPropDebounceTimer);
    }
    audioPropDebounceTimer = setTimeout(() => {
      tryScheduleSave();
    }, 1500);
  }
  
  /**
   * Actualiza el origen del audio (interno o externo)
   */
  function actualizarAudioSource(value) {
    if (!editorState.definition.steps[editorState.selectedStepId].props) {
      editorState.definition.steps[editorState.selectedStepId].props = {};
    }
    editorState.definition.steps[editorState.selectedStepId].props.audio_source = value || undefined;
    
    markDirty();
    renderStepConfig(); // Re-render para actualizar placeholder
    renderPreview();
    tryScheduleSave();
  }
  
  // ============================================================================
  // EDITOR DE screen_choice
  // ============================================================================
  
  /**
   * Genera un slug a partir de un texto (para choice_id)
   * Reutiliza la funci√≥n generateSlug ya existente
   */
  function generateChoiceSlug(text) {
    return generateSlug(text);
  }
  
  /**
   * Valida si un string es un slug v√°lido
   */
  function isValidChoiceSlug(slug) {
    if (!slug || typeof slug !== 'string') return false;
    return /^[a-z][a-z0-9_]*$/.test(slug);
  }
  
  /**
   * Renderiza el editor de screen_choice con campos visuales espec√≠ficos
   * Campos cuadrados: T√≠tulo / Subt√≠tulo / Pregunta / Opciones
   */
  function renderScreenChoiceEditor(step) {
    const props = step.props || {};
    const choices = props.choices || [];
    
    // Obtener template y campos publish_required
    const template = editorState.registry?.screenTemplates?.find(st => st.id === step.screen_template_id);
    const publishRequired = template?.editor_config?.publish_required || [];
    
    // Funci√≥n helper para generar badge de requerido
    const getRequiredBadge = (propName) => {
      const isRequired = publishRequired.includes(propName);
      return isRequired 
        ? '<span class="required-badge" title="Obligatorio para publicar">*</span>'
        : '';
    };
    
    // Verificar si est√° listo para publicar
    const hasQuestion = props.question && props.question.trim();
    const hasValidChoices = choices.length > 0 && choices.every(c => 
      c.choice_id && isValidChoiceSlug(c.choice_id) && c.label && c.label.trim()
    );
    const isReadyToPublish = hasQuestion && hasValidChoices;
    
    return `
      <div class="screen-choice-editor">
        <!-- T√≠tulo -->
        <div class="form-group">
          <label>
            üìù T√≠tulo${getRequiredBadge('title')}
            ${!publishRequired.includes('title') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-choice-title"
                 value="${escapeHtml(props.title || '')}" 
                 onchange="actualizarChoicePropConDebounce('title', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="Ej: Personaliza tu pr√°ctica"
                 maxlength="200"
                 class="screen-choice-input">
          <p class="text-xs text-slate-500 mt-1">T√≠tulo opcional de la pantalla</p>
        </div>
        
        <!-- Subt√≠tulo -->
        <div class="form-group">
          <label>
            üìå Subt√≠tulo${getRequiredBadge('subtitle')}
            ${!publishRequired.includes('subtitle') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-choice-subtitle"
                 value="${escapeHtml(props.subtitle || '')}" 
                 onchange="actualizarChoicePropConDebounce('subtitle', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="Ej: Elige las opciones que m√°s resuenen contigo"
                 maxlength="500"
                 class="screen-choice-input">
          <p class="text-xs text-slate-500 mt-1">Texto secundario debajo del t√≠tulo</p>
        </div>
        
        <!-- Pregunta (obligatoria para publicar) -->
        <div class="form-group">
          <label>
            ‚ùì Pregunta${getRequiredBadge('question')}
            ${publishRequired.includes('question') ? '<span class="text-amber-400 text-xs font-normal ml-2">‚ö†Ô∏è Obligatorio para publicar</span>' : ''}
          </label>
          <textarea id="prop-choice-question"
                    onchange="actualizarChoicePropConDebounce('question', this.value)"
                    oninput="markDirtyOnly()"
                    placeholder="¬øQu√© te gustar√≠a trabajar hoy?"
                    maxlength="500"
                    rows="2"
                    class="screen-choice-textarea">${escapeHtml(props.question || '')}</textarea>
          <p class="text-xs text-slate-500 mt-1">La pregunta que ver√° el usuario</p>
        </div>
        
        <!-- Opciones (choices) -->
        <div class="form-group">
          <label>
            üéØ Opciones${getRequiredBadge('choices')}
            ${publishRequired.includes('choices') ? '<span class="text-amber-400 text-xs font-normal ml-2">‚ö†Ô∏è M√≠nimo 1 opci√≥n para publicar</span>' : ''}
          </label>
          
          <div class="choices-list" id="choices-list">
            ${choices.map((choice, idx) => renderChoiceCard(choice, idx)).join('')}
          </div>
          
          <button type="button" 
                  onclick="a√±adirChoice()"
                  class="add-choice-btn mt-3">
            ‚ûï A√±adir opci√≥n
          </button>
          
          <p class="text-xs text-slate-500 mt-2">
            Cada opci√≥n necesita un <strong>ID t√©cnico</strong> (slug) y un <strong>texto visible</strong> para publicar
          </p>
        </div>
        
        <!-- Indicador de estado -->
        <div class="screen-choice-status mt-4 p-3 rounded ${isReadyToPublish ? 'bg-green-900/30 border border-green-700' : 'bg-amber-900/30 border border-amber-700'}">
          ${isReadyToPublish 
            ? '<span class="text-green-400">‚úÖ Listo para publicar</span>' 
            : '<span class="text-amber-400">‚ö†Ô∏è Completa la pregunta y al menos 1 opci√≥n v√°lida para publicar</span>'}
        </div>
      </div>
    `;
  }
  
  /**
   * Renderiza el editor de screen_checklist_preparacion
   * Solo muestra title y description. Los items vienen del Motor PDE.
   */
  function renderScreenChecklistPreparacionEditor(step) {
    const props = step.props || {};
    const template = editorState.registry?.screenTemplates?.find(st => st.id === step.screen_template_id);
    const publishRequired = template?.editor_config?.publish_required || [];
    const infoMessage = template?.editor_config?.info_message || '';
    
    // Funci√≥n helper para generar badge de requerido
    const getRequiredBadge = (propName) => {
      const isRequired = publishRequired.includes(propName);
      return isRequired 
        ? '<span class="required-badge" title="Obligatorio para publicar">*</span>'
        : '';
    };
    
    return `
      <div class="screen-checklist-preparacion-editor">
        <!-- Mensaje informativo -->
        ${infoMessage ? `
          <div class="info-message p-3 rounded bg-blue-900/30 border border-blue-700 mb-4">
            <p class="text-blue-300 text-sm">‚ÑπÔ∏è ${infoMessage}</p>
          </div>
        ` : ''}
        
        <!-- T√≠tulo -->
        <div class="form-group">
          <label>
            üìù T√≠tulo${getRequiredBadge('title')}
            ${!publishRequired.includes('title') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-checklist-title"
                 value="${escapeHtml(props.title || '')}" 
                 onchange="actualizarProp('title', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="Ej: Selecciona tus preparaciones"
                 maxlength="200"
                 class="screen-choice-input">
          <p class="text-xs text-slate-500 mt-1">T√≠tulo opcional de la pantalla</p>
        </div>
        
        <!-- Descripci√≥n -->
        <div class="form-group">
          <label>
            üìå Descripci√≥n${getRequiredBadge('description')}
            ${!publishRequired.includes('description') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <textarea id="prop-checklist-description"
                    onchange="actualizarProp('description', this.value)"
                    oninput="markDirtyOnly()"
                    placeholder="Elige las preparaciones que deseas realizar..."
                    maxlength="500"
                    rows="3"
                    class="screen-choice-textarea">${escapeHtml(props.description || '')}</textarea>
          <p class="text-xs text-slate-500 mt-1">Texto descriptivo opcional</p>
        </div>
        
        <!-- Estado -->
        <div class="screen-choice-status mt-4 p-3 rounded bg-green-900/30 border border-green-700">
          <span class="text-green-400">‚úÖ Listo para usar</span>
          <p class="text-xs text-slate-400 mt-1">Los items de la checklist se generan din√°micamente desde el Motor PDE</p>
        </div>
      </div>
    `;
  }
  
  /**
   * Renderiza una tarjeta de opci√≥n individual
   */
  function renderChoiceCard(choice, idx) {
    const choiceId = choice.choice_id || '';
    const label = choice.label || '';
    const description = choice.description || '';
    const minutes = choice.estimated_minutes || '';
    const tags = (choice.tags || []).join(', ');
    
    // Determinar si la opci√≥n est√° incompleta
    const isIncomplete = !choiceId || !isValidChoiceSlug(choiceId) || !label.trim();
    const slugIsInvalid = choiceId && !isValidChoiceSlug(choiceId);
    
    return `
      <div class="choice-card ${isIncomplete ? 'incomplete' : ''}" data-choice-idx="${idx}">
        <div class="choice-card-header">
          <span class="choice-card-number">Opci√≥n ${idx + 1}</span>
          <div class="choice-card-actions">
            <button type="button" onclick="moverChoice(${idx}, -1)" title="Mover arriba" ${idx === 0 ? 'disabled style="opacity:0.5"' : ''}>‚¨ÜÔ∏è</button>
            <button type="button" onclick="moverChoice(${idx}, 1)" title="Mover abajo">‚¨áÔ∏è</button>
            <button type="button" onclick="eliminarChoice(${idx})" title="Eliminar" class="delete-btn">üóëÔ∏è</button>
          </div>
        </div>
        
        <!-- ID t√©cnico (slug) -->
        <div class="choice-field">
          <label>ID t√©cnico (slug) *</label>
          <div class="choice-field-row">
            <input type="text" 
                   class="slug-input ${slugIsInvalid ? 'invalid' : ''}"
                   value="${escapeHtml(choiceId)}"
                   onchange="actualizarChoiceField(${idx}, 'choice_id', this.value)"
                   oninput="markDirtyOnly()"
                   placeholder="limpieza_hogar"
                   maxlength="64">
            <button type="button" 
                    class="auto-slug-btn"
                    onclick="autoGenerarSlugChoice(${idx})"
                    title="Generar desde el texto visible">
              üîÑ Auto
            </button>
          </div>
          <p class="choice-field-hint">Solo letras min√∫sculas, n√∫meros y guiones bajos (a-z0-9_)</p>
        </div>
        
        <!-- Texto visible (label) -->
        <div class="choice-field">
          <label>Texto visible *</label>
          <input type="text" 
                 value="${escapeHtml(label)}"
                 onchange="actualizarChoiceField(${idx}, 'label', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="Limpieza del hogar"
                 maxlength="200">
        </div>
        
        <!-- Descripci√≥n (opcional) -->
        <div class="choice-field">
          <label>Descripci√≥n (opcional)</label>
          <textarea rows="2"
                    onchange="actualizarChoiceField(${idx}, 'description', this.value)"
                    oninput="markDirtyOnly()"
                    placeholder="Una descripci√≥n breve de esta opci√≥n"
                    maxlength="500">${escapeHtml(description)}</textarea>
        </div>
        
        <!-- Minutos estimados y Tags en fila -->
        <div class="choice-field" style="display: flex; gap: 16px;">
          <div style="flex: 1;">
            <label>Minutos estimados (opcional)</label>
            <input type="number" 
                   class="choice-minutes-input"
                   value="${minutes}"
                   onchange="actualizarChoiceField(${idx}, 'estimated_minutes', this.value ? parseFloat(this.value) : null)"
                   oninput="markDirtyOnly()"
                   placeholder="5"
                   min="0"
                   max="240">
            <p class="choice-field-hint">Para el reloj futuro</p>
          </div>
          <div style="flex: 2;">
            <label>Tags (opcional)</label>
            <input type="text" 
                   value="${escapeHtml(tags)}"
                   onchange="actualizarChoiceTags(${idx}, this.value)"
                   oninput="markDirtyOnly()"
                   placeholder="limpieza, hogar, energia">
            <p class="choice-field-hint">Separados por coma</p>
          </div>
        </div>
      </div>
    `;
  }
  
  /**
   * A√±adir una nueva opci√≥n vac√≠a
   */
  function a√±adirChoice() {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step.props) step.props = {};
    if (!step.props.choices) step.props.choices = [];
    
    step.props.choices.push({
      choice_id: '',
      label: '',
      description: '',
      estimated_minutes: null,
      tags: []
    });
    
    markDirty();
    renderStepConfig();
    renderPreview();
  }
  
  /**
   * Eliminar una opci√≥n
   */
  function eliminarChoice(idx) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step.props?.choices) return;
    
    step.props.choices.splice(idx, 1);
    
    markDirty();
    tryScheduleSave();
    renderStepConfig();
    renderPreview();
  }
  
  /**
   * Mover una opci√≥n arriba o abajo
   */
  function moverChoice(idx, direction) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step.props?.choices) return;
    
    const newIdx = idx + direction;
    if (newIdx < 0 || newIdx >= step.props.choices.length) return;
    
    // Intercambiar posiciones
    const temp = step.props.choices[idx];
    step.props.choices[idx] = step.props.choices[newIdx];
    step.props.choices[newIdx] = temp;
    
    markDirty();
    tryScheduleSave();
    renderStepConfig();
    renderPreview();
  }
  
  /**
   * Actualizar un campo de una opci√≥n
   */
  let choiceFieldDebounceTimer = null;
  function actualizarChoiceField(idx, field, value) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step.props?.choices?.[idx]) return;
    
    step.props.choices[idx][field] = value;
    
    markDirty();
    renderPreview();
    
    // Debounce el guardado
    if (choiceFieldDebounceTimer) {
      clearTimeout(choiceFieldDebounceTimer);
    }
    choiceFieldDebounceTimer = setTimeout(() => {
      tryScheduleSave();
      // Re-render para actualizar estado de completitud
      renderStepConfig();
    }, 1500);
  }
  
  /**
   * Actualizar tags de una opci√≥n (parseando desde string separado por comas)
   */
  function actualizarChoiceTags(idx, tagsString) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step.props?.choices?.[idx]) return;
    
    // Parsear tags: separar por comas, limpiar espacios, filtrar vac√≠os
    const tags = tagsString
      .split(',')
      .map(t => t.trim())
      .filter(t => t.length > 0);
    
    step.props.choices[idx].tags = tags;
    
    markDirty();
    renderPreview();
    
    if (choiceFieldDebounceTimer) {
      clearTimeout(choiceFieldDebounceTimer);
    }
    choiceFieldDebounceTimer = setTimeout(() => {
      tryScheduleSave();
    }, 1500);
  }
  
  /**
   * Auto-generar slug desde el label de la opci√≥n
   */
  function autoGenerarSlugChoice(idx) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step.props?.choices?.[idx]) return;
    
    const label = step.props.choices[idx].label || '';
    if (!label.trim()) {
      alert('Primero escribe el texto visible para generar el ID autom√°ticamente');
      return;
    }
    
    const generatedSlug = generateChoiceSlug(label);
    if (!generatedSlug) {
      alert('No se pudo generar un ID v√°lido. Escribe uno manualmente.');
      return;
    }
    
    step.props.choices[idx].choice_id = generatedSlug;
    
    markDirty();
    tryScheduleSave();
    renderStepConfig();
    renderPreview();
  }
  
  /**
   * Actualiza prop de choice con debounce (para campos simples)
   */
  let choicePropDebounceTimer = null;
  function actualizarChoicePropConDebounce(key, value) {
    if (!editorState.definition.steps[editorState.selectedStepId].props) {
      editorState.definition.steps[editorState.selectedStepId].props = {};
    }
    editorState.definition.steps[editorState.selectedStepId].props[key] = value;
    
    markDirty();
    renderPreview();
    
    if (choicePropDebounceTimer) {
      clearTimeout(choicePropDebounceTimer);
    }
    choicePropDebounceTimer = setTimeout(() => {
      tryScheduleSave();
    }, 1500);
  }

  /**
   * Renderiza el editor de screen_text con campos visuales espec√≠ficos
   * NO es JSON, son campos claros para el usuario
   */
  function renderScreenTextEditor(step) {
    const props = step.props || {};
    
    // Obtener template y campos publish_required
    const template = editorState.registry?.screenTemplates?.find(st => st.id === step.screen_template_id);
    const publishRequired = template?.editor_config?.publish_required || [];
    
    // Funci√≥n helper para generar badge de requerido
    const getRequiredBadge = (propName) => {
      const isRequired = publishRequired.includes(propName);
      return isRequired 
        ? '<span class="required-badge" title="Obligatorio para publicar">*</span>'
        : '';
    };
    
    return `
      <div class="screen-text-editor">
        <!-- T√≠tulo -->
        <div class="form-group">
          <label>
            üìù T√≠tulo${getRequiredBadge('title')}
            ${!publishRequired.includes('title') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-title"
                 value="${escapeHtml(props.title || '')}" 
                 onchange="actualizarPropConDebounce('title', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="Ej: Bienvenido a tu recorrido"
                 maxlength="200"
                 class="screen-text-input">
          <p class="text-xs text-slate-500 mt-1">El t√≠tulo principal de la pantalla</p>
        </div>
        
        <!-- Subt√≠tulo -->
        <div class="form-group">
          <label>
            üìå Subt√≠tulo${getRequiredBadge('subtitle')}
            ${!publishRequired.includes('subtitle') ? '<span class="text-slate-500 text-xs font-normal ml-2">(opcional)</span>' : ''}
          </label>
          <input type="text" 
                 id="prop-subtitle"
                 value="${escapeHtml(props.subtitle || '')}" 
                 onchange="actualizarPropConDebounce('subtitle', this.value)"
                 oninput="markDirtyOnly()"
                 placeholder="Ej: Un subt√≠tulo descriptivo"
                 maxlength="500"
                 class="screen-text-input">
          <p class="text-xs text-slate-500 mt-1">Texto secundario debajo del t√≠tulo</p>
        </div>
        
        <!-- Contenido (Body) -->
        <div class="form-group">
          <label>
            üìÑ Contenido${getRequiredBadge('body')}
            ${publishRequired.includes('body') ? '<span class="text-amber-400 text-xs font-normal ml-2">‚ö†Ô∏è Obligatorio para publicar</span>' : ''}
          </label>
          <textarea id="prop-body"
                    onchange="actualizarPropConDebounce('body', this.value)"
                    oninput="markDirtyOnly()"
                    placeholder="Escribe aqu√≠ el contenido principal del texto...

Puedes escribir varios p√°rrafos.
El texto se mostrar√° tal como lo escribas."
                    maxlength="5000"
                    rows="10"
                    class="screen-text-textarea">${escapeHtml(props.body || '')}</textarea>
          <div class="flex justify-between items-center mt-1">
            <p class="text-xs text-slate-500">El texto principal que ver√° el usuario</p>
            <span class="text-xs text-slate-500" id="body-char-count">${(props.body || '').length}/5000</span>
          </div>
        </div>
        
        <!-- Indicador de estado -->
        <div class="screen-text-status mt-4 p-3 rounded ${props.body ? 'bg-green-900/30 border border-green-700' : 'bg-amber-900/30 border border-amber-700'}">
          ${props.body 
            ? '<span class="text-green-400">‚úÖ Listo para publicar</span>' 
            : '<span class="text-amber-400">‚ö†Ô∏è A√±ade contenido para poder publicar</span>'}
        </div>
      </div>
    `;
  }
  
  /**
   * Escapa HTML para prevenir XSS
   */
  function escapeHtml(str) {
    if (!str) return '';
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
  
  /**
   * Solo marca dirty sin programar guardado
   * √ötil para oninput (cada keystroke)
   */
  function markDirtyOnly() {
    editorState.dirty = true;
    updateStatusIndicator();
    
    // Actualizar contador de caracteres si existe
    const bodyTextarea = document.getElementById('prop-body');
    const charCount = document.getElementById('body-char-count');
    if (bodyTextarea && charCount) {
      charCount.textContent = `${bodyTextarea.value.length}/5000`;
    }
  }
  
  /**
   * Actualiza prop con debounce (para campos de texto)
   * Solo guarda despu√©s de que el usuario deje de escribir
   */
  let propDebounceTimer = null;
  function actualizarPropConDebounce(key, value) {
    // Actualizar estado inmediatamente
    if (!editorState.definition.steps[editorState.selectedStepId].props) {
      editorState.definition.steps[editorState.selectedStepId].props = {};
    }
    editorState.definition.steps[editorState.selectedStepId].props[key] = value;
    
    markDirty();
    renderPreview(); // Actualizar preview en tiempo real
    
    // Debounce el guardado
    if (propDebounceTimer) {
      clearTimeout(propDebounceTimer);
    }
    propDebounceTimer = setTimeout(() => {
      tryScheduleSave();
    }, 1500); // 1.5 segundos despu√©s de dejar de escribir
  }
  
  // Renderizar editor de props
  function renderPropsEditor(step) {
    const screenTemplate = editorState.registry?.screenTemplates?.find(st => st.id === step.screen_template_id);
    
    // ============================================================================
    // EDITOR ESPEC√çFICO PARA screen_text
    // ============================================================================
    if (step.screen_template_id === 'screen_text') {
      return renderScreenTextEditor(step);
    }
    
    // ============================================================================
    // EDITOR ESPEC√çFICO PARA screen_video
    // ============================================================================
    if (step.screen_template_id === 'screen_video') {
      return renderScreenVideoEditor(step);
    }
    
    // ============================================================================
    // EDITOR ESPEC√çFICO PARA screen_audio
    // ============================================================================
    if (step.screen_template_id === 'screen_audio') {
      return renderScreenAudioEditor(step);
    }
    
    // ============================================================================
    // EDITOR ESPEC√çFICO PARA screen_choice
    // ============================================================================
    if (step.screen_template_id === 'screen_choice') {
      return renderScreenChoiceEditor(step);
    }
    
    // ============================================================================
    // EDITOR ESPEC√çFICO PARA screen_checklist_preparacion
    // ============================================================================
    if (step.screen_template_id === 'screen_checklist_preparacion') {
      return renderScreenChecklistPreparacionEditor(step);
    }
    
    // ============================================================================
    // EDITOR GEN√âRICO PARA OTROS TEMPLATES
    // ============================================================================
    const schema = screenTemplate?.props_schema || {};
    const props = step.props || {};
    const publishRequired = screenTemplate?.editor_config?.publish_required || [];
    
    if (!schema || !schema.properties || Object.keys(schema.properties).length === 0) {
      return '<p class="text-slate-400 text-sm">Este screen template no requiere props.</p>';
    }
    
    // Funci√≥n helper para generar badge de requerido
    const getRequiredBadge = (propName) => {
      const isRequired = publishRequired.includes(propName);
      return isRequired 
        ? '<span class="required-badge" title="Obligatorio para publicar">*</span>'
        : '';
    };
    
    return Object.keys(schema.properties).map(propKey => {
      const propSchema = schema.properties[propKey];
      const propValue = props[propKey] !== undefined ? props[propKey] : propSchema.default;
      const propType = propSchema.type || 'string';
      const isRequired = schema.required?.includes(propKey);
      const isPublishRequired = publishRequired.includes(propKey);
      
      let inputHtml = '';
      
      if (propType === 'boolean') {
        inputHtml = `
          <select onchange="actualizarProp('${propKey}', this.value === 'true')">
            <option value="true" ${propValue === true ? 'selected' : ''}>S√≠</option>
            <option value="false" ${propValue === false ? 'selected' : ''}>No</option>
          </select>
        `;
      } else if (propType === 'number' || propType === 'integer') {
        inputHtml = `
          <input type="number" value="${propValue || ''}" 
                 onchange="actualizarProp('${propKey}', parseFloat(this.value))" 
                 placeholder="${propSchema.default || ''}">
        `;
      } else if (propType === 'array') {
        inputHtml = `
          <textarea onchange="actualizarPropJson('${propKey}', this.value)" 
                    class="font-mono text-xs" rows="4">${JSON.stringify(propValue || [], null, 2)}</textarea>
          <p class="text-xs text-slate-500 mt-1">Formato JSON</p>
        `;
      } else {
        inputHtml = `
          <input type="text" value="${escapeHtml((propValue || '').toString())}" 
                 onchange="actualizarProp('${propKey}', this.value)" 
                 placeholder="${propSchema.default || ''}">
        `;
      }
      
      return `
        <div class="form-group">
          <label>
            ${propKey}${getRequiredBadge(propKey)}
            ${isRequired ? '<span class="text-red-400">*</span>' : ''}
            ${isPublishRequired ? '<span class="text-amber-400 text-xs font-normal ml-2">‚ö†Ô∏è Obligatorio para publicar</span>' : ''}
          </label>
          ${inputHtml}
          ${propSchema.description ? `<p class="text-xs text-slate-500 mt-1">${propSchema.description}</p>` : ''}
        </div>
      `;
    }).join('');
  }
  
  /**
   * Actualiza prop que es un JSON (arrays, objetos)
   */
  function actualizarPropJson(key, jsonString) {
    try {
      const value = JSON.parse(jsonString);
      actualizarProp(key, value);
    } catch (e) {
      console.error('JSON inv√°lido:', e);
      // No actualizar si el JSON es inv√°lido
    }
  }
  
  // Renderizar editor de branches
  function renderBranchesEditor(step) {
    const stepId = editorState.selectedStepId;
    const edges = editorState.definition.edges.filter(e => e.from_step_id === stepId);
    const allSteps = Object.keys(editorState.definition.steps);
    const conditions = editorState.registry?.conditions || [];
    
    let html = edges.map((edge, idx) => {
      return `
        <div class="bg-slate-800 p-3 rounded mb-2">
          <div class="flex justify-between items-center mb-2">
            <span class="text-sm text-white">Branch ${idx + 1}</span>
            <button onclick="eliminarBranch(${idx})" class="text-red-400 text-xs">Eliminar</button>
          </div>
          <div class="form-group">
            <label>To Step</label>
            <select onchange="actualizarBranchTo(${idx}, this.value)">
              <option value="">Seleccionar...</option>
              ${allSteps.map(sid => `
                <option value="${sid}" ${edge.to_step_id === sid ? 'selected' : ''}>${sid}</option>
              `).join('')}
            </select>
          </div>
          <div class="form-group">
            <label>Condition</label>
            <select onchange="actualizarBranchCondition(${idx}, this.value)">
              <option value="">Siempre (sin condici√≥n)</option>
              ${conditions.map(c => `
                <option value="${c.id}" ${edge.condition?.type === c.id ? 'selected' : ''}>${c.name || c.id}</option>
              `).join('')}
            </select>
          </div>
        </div>
      `;
    }).join('');
    
    html += `
      <button onclick="a√±adirBranch()" class="w-full px-3 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded">
        ‚ûï A√±adir Branch
      </button>
    `;
    
    return html;
  }
  
  // Renderizar editor de events
  function renderEventsEditor(step) {
    const events = step.emit_events || [];
    const eventTypes = editorState.registry?.events || [];
    
    let html = events.map((event, idx) => {
      return `
        <div class="bg-slate-800 p-3 rounded mb-2">
          <div class="flex justify-between items-center mb-2">
            <span class="text-sm text-white">Event ${idx + 1}</span>
            <button onclick="eliminarEvent(${idx})" class="text-red-400 text-xs">Eliminar</button>
          </div>
          <div class="form-group">
            <label>Event Type</label>
            <select onchange="actualizarEventType(${idx}, this.value)">
              <option value="">Seleccionar...</option>
              ${eventTypes.map(et => `
                <option value="${et.id}" ${event.type === et.id ? 'selected' : ''}>${et.name || et.id}</option>
              `).join('')}
            </select>
          </div>
          <div class="form-group">
            <label>Payload (JSON)</label>
            <textarea onchange="actualizarEventPayload(${idx}, this.value)" 
                      class="font-mono text-xs" rows="3">${JSON.stringify(event.payload || {}, null, 2)}</textarea>
          </div>
        </div>
      `;
    }).join('');
    
    html += `
      <button onclick="a√±adirEvent()" class="w-full px-3 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded">
        ‚ûï A√±adir Event
      </button>
    `;
    
    return html;
  }
  
  // ============================================================================
  // PREVIEW DE STEPS
  // ============================================================================
  // 
  // Renderiza una vista previa visual del step seg√∫n su template
  // screen_text: muestra t√≠tulo, subt√≠tulo y body como se ver√≠a en runtime
  // Otros: muestra un preview b√°sico con los props
  //
  
  /**
   * Renderiza preview espec√≠fico para screen_text
   */
  function renderScreenTextPreview(step) {
    const props = step.props || {};
    
    return `
      <div class="screen-text-preview">
        <!-- Simulaci√≥n de pantalla m√≥vil -->
        <div class="mobile-frame">
          <div class="mobile-content">
            ${props.title ? `
              <h1 class="preview-title">${escapeHtml(props.title)}</h1>
            ` : `
              <h1 class="preview-title preview-placeholder">Sin t√≠tulo</h1>
            `}
            
            ${props.subtitle ? `
              <h2 class="preview-subtitle">${escapeHtml(props.subtitle)}</h2>
            ` : ''}
            
            ${props.body ? `
              <div class="preview-body">${escapeHtml(props.body).replace(/\n/g, '<br>')}</div>
            ` : `
              <div class="preview-body preview-placeholder">
                <p>El contenido aparecer√° aqu√≠...</p>
                <p class="text-amber-500 text-sm mt-4">‚ö†Ô∏è A√±ade contenido para ver el preview</p>
              </div>
            `}
            
            <!-- Bot√≥n de acci√≥n simulado -->
            <button class="preview-action-btn">Continuar</button>
          </div>
        </div>
        
        <!-- Info del template -->
        <div class="preview-info mt-4">
          <span class="text-xs text-slate-500">
            Template: <code>screen_text</code> ‚Ä¢ 
            Step: <code>${editorState.selectedStepId}</code>
          </span>
        </div>
      </div>
    `;
  }
  
  /**
   * Extrae el ID de YouTube de una URL o devuelve el string si ya es un ID
   */
  function extractYouTubeId(urlOrId) {
    if (!urlOrId) return null;
    
    // Si ya es un ID corto (11 caracteres), devolverlo
    if (/^[a-zA-Z0-9_-]{11}$/.test(urlOrId)) {
      return urlOrId;
    }
    
    // Intentar extraer de URL completa
    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
      /youtube\.com\/v\/([a-zA-Z0-9_-]{11})/,
      /youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})/
    ];
    
    for (const pattern of patterns) {
      const match = urlOrId.match(pattern);
      if (match) return match[1];
    }
    
    // Si no coincide con nada, devolver el string original (podr√≠a ser un ID)
    return urlOrId;
  }
  
  /**
   * Renderiza preview espec√≠fico para screen_choice
   */
  function renderScreenChoicePreview(step) {
    const props = step.props || {};
    const choices = props.choices || [];
    
    return `
      <div class="screen-choice-preview">
        <!-- Simulaci√≥n de pantalla m√≥vil -->
        <div class="mobile-frame">
          <div class="mobile-content">
            ${props.title ? `
              <h1 class="preview-title">${escapeHtml(props.title)}</h1>
            ` : ''}
            
            ${props.subtitle ? `
              <h2 class="preview-subtitle">${escapeHtml(props.subtitle)}</h2>
            ` : ''}
            
            ${props.question ? `
              <div class="preview-question">${escapeHtml(props.question)}</div>
            ` : `
              <div class="preview-question preview-placeholder" style="opacity: 0.5; border-left-color: #64748b;">
                (Escribe una pregunta...)
              </div>
            `}
            
            <div class="preview-choices">
              ${choices.length > 0 ? choices.map((choice, idx) => `
                <button type="button" class="preview-choice-btn ${(!choice.label || !choice.label.trim()) ? 'placeholder' : ''}">
                  <span class="preview-choice-label">
                    ${choice.label && choice.label.trim() ? escapeHtml(choice.label) : `(Opci√≥n ${idx + 1} sin texto)`}
                  </span>
                  ${choice.description && choice.description.trim() ? `
                    <span class="preview-choice-desc">${escapeHtml(choice.description)}</span>
                  ` : ''}
                  ${(choice.estimated_minutes || (choice.tags && choice.tags.length > 0)) ? `
                    <div class="preview-choice-meta">
                      ${choice.estimated_minutes ? `
                        <span class="preview-choice-minutes">‚è±Ô∏è +${choice.estimated_minutes} min</span>
                      ` : ''}
                      ${(choice.tags || []).slice(0, 3).map(tag => `
                        <span class="preview-choice-tag">${escapeHtml(tag)}</span>
                      `).join('')}
                    </div>
                  ` : ''}
                </button>
              `).join('') : `
                <button type="button" class="preview-choice-btn placeholder">
                  <span class="preview-choice-label">(A√±ade opciones...)</span>
                </button>
              `}
            </div>
            
            <!-- Bot√≥n de acci√≥n simulado -->
            <button class="preview-action-btn">Continuar</button>
          </div>
        </div>
        
        <!-- Info del template -->
        <div class="preview-info mt-4">
          <span class="text-xs text-slate-500">
            Template: <code>screen_choice</code> ‚Ä¢ 
            Step: <code>${editorState.selectedStepId}</code> ‚Ä¢ 
            Opciones: <code>${choices.length}</code>
          </span>
        </div>
      </div>
    `;
  }
  
  /**
   * Renderiza preview espec√≠fico para screen_audio
   */
  function renderScreenAudioPreview(step) {
    const props = step.props || {};
    const audioSource = props.audio_source || '';
    const audioRef = props.audio_ref || '';
    
    // Contenido del audio seg√∫n configuraci√≥n
    let audioContent = '';
    
    if (!audioSource || !audioRef) {
      // Sin audio configurado
      audioContent = `
        <div class="audio-preview-container">
          <div class="audio-preview-placeholder">
            <span class="icon">üéµ</span>
            <span class="text">Configura el origen y referencia del audio para ver el preview</span>
          </div>
        </div>
      `;
    } else {
      // Audio configurado - mostrar reproductor simulado
      audioContent = `
        <div class="audio-preview-container">
          <div class="audio-preview-icon">üéß</div>
          <div style="width: 100%;">
            <div class="audio-progress-bar"></div>
            <div class="audio-controls">
              <button class="audio-play-btn" onclick="alert('Preview visual - el audio no se reproduce en editor')">
                ‚ñ∂Ô∏è
              </button>
              <span class="audio-time">0:00 / --:--</span>
            </div>
          </div>
          <code style="background: #334155; padding: 4px 8px; border-radius: 4px; font-size: 11px; margin-top: 12px; color: #94a3b8;">
            ${audioSource === 'internal' ? 'üéß Interno: ' : 'üåê Externo: '}${escapeHtml(audioRef.substring(0, 40))}${audioRef.length > 40 ? '...' : ''}
          </code>
        </div>
      `;
    }
    
    return `
      <div class="screen-audio-preview">
        <!-- Simulaci√≥n de pantalla m√≥vil -->
        <div class="mobile-frame">
          <div class="mobile-content">
            ${props.title ? `
              <h1 class="preview-title">${escapeHtml(props.title)}</h1>
            ` : ''}
            
            ${props.subtitle ? `
              <p class="preview-subtitle" style="font-size: 15px; margin-bottom: 16px;">${escapeHtml(props.subtitle)}</p>
            ` : ''}
            
            ${audioContent}
            
            ${props.declared_duration_minutes ? `
              <div class="audio-duration-badge">
                <span>‚è±Ô∏è</span>
                <span>${props.declared_duration_minutes} min</span>
              </div>
            ` : ''}
            
            <!-- Bot√≥n de acci√≥n simulado -->
            <button class="preview-action-btn">Continuar</button>
          </div>
        </div>
        
        <!-- Info del template -->
        <div class="preview-info mt-4">
          <span class="text-xs text-slate-500">
            Template: <code>screen_audio</code> ‚Ä¢ 
            Step: <code>${editorState.selectedStepId}</code> ‚Ä¢ 
            ${audioSource ? `Origen: <code>${audioSource}</code>` : 'Sin configurar'}
          </span>
        </div>
      </div>
    `;
  }
  
  /**
   * Renderiza preview espec√≠fico para screen_video
   */
  function renderScreenVideoPreview(step) {
    const props = step.props || {};
    const displayMode = props.display_mode || 'inline';
    const videoSource = props.video_source || '';
    const videoRef = props.video_ref || '';
    
    // Extraer ID de YouTube si aplica
    const youtubeId = videoSource === 'youtube' ? extractYouTubeId(videoRef) : null;
    
    // Contenido del v√≠deo seg√∫n modo y origen
    let videoContent = '';
    
    if (!videoSource || !videoRef) {
      // Sin v√≠deo configurado
      videoContent = `
        <div class="video-preview-container">
          <div class="video-preview-placeholder">
            <span class="icon">üé¨</span>
            <span class="text">Configura el origen y referencia del v√≠deo para ver el preview</span>
          </div>
        </div>
      `;
    } else if (displayMode === 'collapsed') {
      // Modo colapsado: mostrar bot√≥n
      videoContent = `
        <div class="video-preview-container" style="background: linear-gradient(135deg, #1e1e2f 0%, #0a0a0f 100%);">
          <button class="video-collapsed-btn" onclick="alert('En runtime, esto expandir√≠a el v√≠deo')">
            ‚ñ∂Ô∏è Ver v√≠deo
          </button>
          <p class="text-xs text-slate-500 mt-3">Click para ver (modo colapsado)</p>
        </div>
      `;
    } else if (videoSource === 'youtube' && youtubeId) {
      // YouTube inline
      videoContent = `
        <div class="video-preview-container" style="padding: 0;">
          <iframe 
            class="video-preview-youtube"
            src="https://www.youtube.com/embed/${youtubeId}?rel=0"
            title="YouTube video player"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen>
          </iframe>
        </div>
      `;
    } else if (videoSource === 'internal') {
      // V√≠deo interno: placeholder con ID
      videoContent = `
        <div class="video-preview-container">
          <div class="video-preview-placeholder">
            <span class="icon">üé•</span>
            <span class="text">V√≠deo interno</span>
            <code style="background: #334155; padding: 4px 8px; border-radius: 4px; font-size: 11px; margin-top: 8px;">${escapeHtml(videoRef)}</code>
          </div>
        </div>
      `;
    } else {
      // Fallback
      videoContent = `
        <div class="video-preview-container">
          <div class="video-preview-placeholder">
            <span class="icon">‚ùì</span>
            <span class="text">Origen desconocido: ${escapeHtml(videoSource)}</span>
          </div>
        </div>
      `;
    }
    
    return `
      <div class="screen-video-preview">
        <!-- Simulaci√≥n de pantalla m√≥vil -->
        <div class="mobile-frame">
          <div class="mobile-content">
            ${props.title ? `
              <h1 class="preview-title">${escapeHtml(props.title)}</h1>
            ` : ''}
            
            ${props.description ? `
              <p class="preview-subtitle" style="font-size: 15px; margin-bottom: 16px;">${escapeHtml(props.description)}</p>
            ` : ''}
            
            ${videoContent}
            
            ${props.declared_duration_minutes ? `
              <div class="video-duration-badge">
                <span>‚è±Ô∏è</span>
                <span>${props.declared_duration_minutes} min</span>
              </div>
            ` : ''}
            
            <!-- Bot√≥n de acci√≥n simulado -->
            <button class="preview-action-btn">Continuar</button>
          </div>
        </div>
        
        <!-- Info del template -->
        <div class="preview-info mt-4">
          <span class="text-xs text-slate-500">
            Template: <code>screen_video</code> ‚Ä¢ 
            Step: <code>${editorState.selectedStepId}</code> ‚Ä¢ 
            Modo: <code>${displayMode}</code>
            ${videoSource ? ` ‚Ä¢ Origen: <code>${videoSource}</code>` : ''}
          </span>
        </div>
      </div>
    `;
  }
  
  // Renderizar preview
  async function renderPreview() {
    console.log('[Editor] renderPreview called');
    console.log('[Editor] renderPreview - selectedStepId:', editorState.selectedStepId);
    const container = document.getElementById('preview-container');
    const step = editorState.definition.steps[editorState.selectedStepId];
    
    if (!step) {
      console.log('[Editor] renderPreview - no step found, showing placeholder');
      container.innerHTML = '<div class="p-8 text-center text-slate-400"><p>Selecciona un step para ver el preview</p></div>';
      return;
    }
    
    console.log('[Editor] renderPreview - rendering preview for step:', editorState.selectedStepId);
    
    // ============================================================================
    // PREVIEW ESPEC√çFICO PARA screen_text
    // ============================================================================
    if (step.screen_template_id === 'screen_text') {
      container.innerHTML = renderScreenTextPreview(step);
      return;
    }
    
    // ============================================================================
    // PREVIEW ESPEC√çFICO PARA screen_video
    // ============================================================================
    if (step.screen_template_id === 'screen_video') {
      container.innerHTML = renderScreenVideoPreview(step);
      return;
    }
    
    // ============================================================================
    // PREVIEW ESPEC√çFICO PARA screen_audio
    // ============================================================================
    if (step.screen_template_id === 'screen_audio') {
      container.innerHTML = renderScreenAudioPreview(step);
      return;
    }
    
    // ============================================================================
    // PREVIEW ESPEC√çFICO PARA screen_choice
    // ============================================================================
    if (step.screen_template_id === 'screen_choice') {
      container.innerHTML = renderScreenChoicePreview(step);
      return;
    }
    
    // ============================================================================
    // PREVIEW GEN√âRICO PARA OTROS TEMPLATES
    // ============================================================================
    container.innerHTML = `
      <div class="p-8">
        <h3 class="text-lg font-semibold mb-4">Preview: ${editorState.selectedStepId}</h3>
        <div class="bg-slate-100 p-4 rounded">
          <p class="text-sm text-slate-600 mb-2"><strong>Screen Template:</strong> ${step.screen_template_id || 'N/A'}</p>
          <p class="text-sm text-slate-600 mb-2"><strong>Step Type:</strong> ${step.step_type || 'N/A'}</p>
          <pre class="text-xs bg-slate-200 p-3 rounded overflow-auto">${JSON.stringify(step.props || {}, null, 2)}</pre>
        </div>
        <p class="text-xs text-slate-500 mt-4">Nota: El preview completo con renderHtml se implementar√° en la siguiente fase.</p>
      </div>
    `;
  }
  
  // ============================================================================
  // FUNCIONES DE ACTUALIZACI√ìN (BLINDAJE v2)
  // ============================================================================
  // 
  // PRINCIPIO: markDirty() + tryScheduleSave() en lugar de guardarDraft() directo
  // Esto permite que el editor est√© en estado inv√°lido sin romper nada.
  //
  
  function actualizarStepType() {
    const stepTypeId = document.getElementById('config-step-type').value;
    const step = editorState.definition.steps[editorState.selectedStepId];
    
    // Si se cambia a motor, inicializar campos espec√≠ficos
    if (stepTypeId === 'motor') {
      step.type = 'motor';
      step.step_type = 'motor';
      // Limpiar campos que no aplican para motor
      delete step.screen_template_id;
      delete step.props;
      delete step.capture;
      // Inicializar campos del motor si no existen
      if (!step.motor_key) step.motor_key = '';
      if (!step.motor_version) step.motor_version = undefined;
      if (!step.inputs) step.inputs = {};
    } else {
      // Si se cambia de motor a otro tipo, limpiar campos del motor
      if (step.type === 'motor') {
        delete step.type;
        delete step.motor_key;
        delete step.motor_version;
        delete step.inputs;
        selectedMotorData = null; // Resetear motor seleccionado
      }
      step.step_type = stepTypeId || undefined;
    }
    
    markDirty();
    tryScheduleSave();
    renderStepConfig();
  }
  
  function actualizarScreenTemplate() {
    const screenTemplateId = document.getElementById('config-screen-template').value;
    editorState.definition.steps[editorState.selectedStepId].screen_template_id = screenTemplateId;
    markDirty();
    tryScheduleSave();
    renderStepConfig();
    renderPreview();
  }
  
  function actualizarProp(key, value) {
    if (!editorState.definition.steps[editorState.selectedStepId].props) {
      editorState.definition.steps[editorState.selectedStepId].props = {};
    }
    editorState.definition.steps[editorState.selectedStepId].props[key] = value;
    markDirty();
    tryScheduleSave();
    renderPreview();
  }
  
  function actualizarCapture() {
    const capture = document.getElementById('config-capture').value;
    editorState.definition.steps[editorState.selectedStepId].capture = capture || undefined;
    markDirty();
    tryScheduleSave();
  }
  
  // BLINDAJE v2: a√±adirBranch NO guarda inmediatamente porque el edge est√° incompleto
  function a√±adirBranch() {
    const stepId = editorState.selectedStepId;
    editorState.definition.edges.push({
      from_step_id: stepId,
      to_step_id: '',  // ‚ö†Ô∏è Incompleto - NO intentar guardar
      condition: null
    });
    markDirty(); // Marcamos dirty pero NO llamamos tryScheduleSave()
    renderStepConfig();
    
    // Mostrar aviso visual
    mostrarAvisoEdgeIncompleto();
  }
  
  function mostrarAvisoEdgeIncompleto() {
    const messagesContainer = document.getElementById('validation-messages');
    if (messagesContainer) {
      messagesContainer.innerHTML = `
        <div class="validation-warning">
          ‚ö†Ô∏è Branch incompleto: selecciona un "To Step" para poder guardar
        </div>
      `;
    }
  }
  
  function actualizarBranchTo(idx, toStepId) {
    const stepId = editorState.selectedStepId;
    const edges = editorState.definition.edges.filter(e => e.from_step_id === stepId);
    if (edges[idx]) {
      edges[idx].to_step_id = toStepId;
      markDirty();
      // Ahora s√≠, el edge puede estar completo
      if (toStepId) {
        tryScheduleSave();
        // Limpiar aviso
        document.getElementById('validation-messages').innerHTML = '';
      }
    }
  }
  
  function actualizarBranchCondition(idx, conditionType) {
    const stepId = editorState.selectedStepId;
    const edges = editorState.definition.edges.filter(e => e.from_step_id === stepId);
    if (edges[idx]) {
      edges[idx].condition = conditionType ? { type: conditionType } : null;
      markDirty();
      tryScheduleSave();
    }
  }
  
  function eliminarBranch(idx) {
    const stepId = editorState.selectedStepId;
    const edges = editorState.definition.edges.filter(e => e.from_step_id === stepId);
    const edgeToRemove = edges[idx];
    if (edgeToRemove) {
      const globalIdx = editorState.definition.edges.indexOf(edgeToRemove);
      editorState.definition.edges.splice(globalIdx, 1);
      markDirty();
      tryScheduleSave();
      renderStepConfig();
    }
  }
  
  // BLINDAJE v2: a√±adirEvent NO guarda inmediatamente porque el event est√° incompleto
  function a√±adirEvent() {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (!step.emit_events) {
      step.emit_events = [];
    }
    step.emit_events.push({
      type: '',  // ‚ö†Ô∏è Incompleto
      payload: {}
    });
    markDirty(); // NO llamamos tryScheduleSave()
    renderStepConfig();
  }
  
  function actualizarEventType(idx, eventType) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (step.emit_events && step.emit_events[idx]) {
      step.emit_events[idx].type = eventType;
      markDirty();
      if (eventType) {
        tryScheduleSave();
      }
    }
  }
  
  function actualizarEventPayload(idx, payloadJson) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (step.emit_events && step.emit_events[idx]) {
      try {
        step.emit_events[idx].payload = JSON.parse(payloadJson);
        markDirty();
        tryScheduleSave();
      } catch (e) {
        console.error('Error parseando JSON:', e);
        // NO guardamos si el JSON es inv√°lido
      }
    }
  }
  
  function eliminarEvent(idx) {
    const step = editorState.definition.steps[editorState.selectedStepId];
    if (step.emit_events) {
      step.emit_events.splice(idx, 1);
      markDirty();
      tryScheduleSave();
      renderStepConfig();
    }
  }
  
  // ============================================================================
  // GUARDAR DRAFT (BLINDAJE v2)
  // ============================================================================
  // 
  // PRINCIPIOS:
  // 1. SIEMPRE validar antes de intentar guardar
  // 2. Si no es v√°lido, NO enviar a la API
  // 3. Mostrar errores claros al usuario
  // 4. Actualizar estado del editor
  //
  
  async function guardarDraft() {
    // BLINDAJE v2: Verificar validez antes de guardar
    const validation = validateDefinitionForDraft(editorState.definition);
    if (!validation.valid) {
      console.warn('No se puede guardar draft inv√°lido:', validation.errors);
      editorState.valid = false;
      editorState.validationErrors = validation.errors;
      updateStatusIndicator();
      
      // Mostrar errores en UI
      const messagesContainer = document.getElementById('validation-messages');
      if (messagesContainer) {
        messagesContainer.innerHTML = validation.errors.map(e => 
          `<div class="validation-error">‚ùå ${e}</div>`
        ).join('');
      }
      return false;
    }
    
    // Evitar guardados concurrentes
    if (editorState.isSaving) {
      console.log('Ya hay un guardado en progreso, esperando...');
      return false;
    }
    
    editorState.isSaving = true;
    updateStatusIndicator();
    
    // LOG TEMPORAL: Mostrar order enviado
    const stepsSent = editorState.definition?.steps || {};
    const orderSent = Object.keys(stepsSent).reduce((acc, stepId) => {
      const step = stepsSent[stepId];
      acc[stepId] = typeof step?.order === 'number' ? step.order : 'undefined';
      return acc;
    }, {});
    console.log('üì§ Order enviado al servidor:', orderSent);
    
    try {
      const response = await fetch(`/admin/api/recorridos/${encodeURIComponent(editorState.recorridoId)}/draft`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          definition_json: editorState.definition
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMsg = errorData.error || `Error ${response.status}`;
        const details = errorData.details?.errors || [];
        
        throw new Error(errorMsg + (details.length ? `\n${details.join('\n')}` : ''));
      }
      
      const data = await response.json();
      
      // Comparar order enviado vs recibido para detectar modificaciones del servidor
      const stepsReceived = data.draft?.definition_json?.steps || {};
      const orderReceived = Object.keys(stepsReceived).reduce((acc, stepId) => {
        const step = stepsReceived[stepId];
        acc[stepId] = typeof step?.order === 'number' ? step.order : 'undefined';
        return acc;
      }, {});
      
      // Comparar order enviado vs recibido
      const orderChanged = Object.keys(orderSent).some(stepId => {
        const sent = orderSent[stepId];
        const received = orderReceived[stepId];
        return sent !== received;
      });
      
      if (orderChanged) {
        console.warn('‚ö†Ô∏è ADVERTENCIA: El servidor modific√≥ el order de los steps:', {
          enviado: orderSent,
          recibido: orderReceived,
          mensaje: 'Esto no deber√≠a ocurrir. Verificar normalizeRecorridoDefinition() en el servidor.'
        });
      } else {
        console.log('‚úÖ Order preservado correctamente:', orderReceived);
      }
      
      // Actualizar estado
      editorState.dirty = false;
      editorState.lastSavedAt = new Date();
      editorState.validationErrors = [];
      
      // Actualizar definition con la versi√≥n normalizada del servidor
      if (data.draft?.definition_json) {
        editorState.definition = data.draft.definition_json;
      }
      
      console.log('‚úÖ Draft guardado exitosamente:', data.draft?.draft_id);
      
      // Limpiar mensajes de error
      const messagesContainer = document.getElementById('validation-messages');
      if (messagesContainer) {
        messagesContainer.innerHTML = `
          <div class="validation-success">‚úÖ Guardado a las ${new Date().toLocaleTimeString()}</div>
        `;
        // Limpiar mensaje despu√©s de 3 segundos
        setTimeout(() => {
          if (messagesContainer.querySelector('.validation-success')) {
            messagesContainer.innerHTML = '';
          }
        }, 3000);
      }
      
      updateStatusIndicator();
      return true;
      
    } catch (error) {
      console.error('Error guardando draft:', error);
      
      // Mostrar error en UI
      const messagesContainer = document.getElementById('validation-messages');
      if (messagesContainer) {
        messagesContainer.innerHTML = `
          <div class="validation-error">
            ‚ùå Error guardando: ${error.message.replace(/\n/g, '<br>')}
          </div>
        `;
      }
      
      updateStatusIndicator();
      return false;
      
    } finally {
      editorState.isSaving = false;
      updateStatusIndicator();
    }
  }
  
  // Bot√≥n para forzar guardado manual
  async function forzarGuardado() {
    const validation = validateDefinitionForDraft(editorState.definition);
    if (!validation.valid) {
      alert(
        '‚ùå No se puede guardar porque hay errores:\n\n' + 
        validation.errors.join('\n')
      );
      return;
    }
    
    const success = await guardarDraft();
    if (success) {
      alert('‚úÖ Guardado exitosamente');
    }
  }
  
  // ============================================================================
  // VALIDAR RECORRIDO (BLINDAJE v2)
  // ============================================================================
  // 
  // Muestra errores y warnings de forma clara.
  // Usa validaci√≥n completa del backend (con registries)
  //
  async function validarRecorrido() {
    const messagesContainer = document.getElementById('validation-messages');
    messagesContainer.innerHTML = '<p class="text-slate-400">üîÑ Validando con el servidor...</p>';
    
    // Primero validaci√≥n local r√°pida
    const localValidation = validateDefinitionForDraft(editorState.definition);
    if (!localValidation.valid) {
      let html = '<div class="validation-error">‚úó Errores locales (no se envi√≥ al servidor):</div>';
      localValidation.errors.forEach(error => {
        html += `<div class="validation-error">‚ùå ${error}</div>`;
      });
      messagesContainer.innerHTML = html;
      return;
    }
    
    try {
      const response = await fetch(`/admin/api/recorridos/${encodeURIComponent(editorState.recorridoId)}/validate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          definition_json: editorState.definition
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Error ${response.status}`);
      }
      
      const validation = await response.json();
      
      let html = '';
      
      if (validation.valid) {
        html += '<div class="validation-success">‚úÖ El recorrido es v√°lido y listo para publicar</div>';
      } else {
        html += '<div class="validation-error">‚ùå El recorrido tiene errores y NO se puede publicar</div>';
      }
      
      if (validation.errors && validation.errors.length > 0) {
        html += '<div class="mt-2 text-sm text-white font-semibold">Errores:</div>';
        validation.errors.forEach(error => {
          html += `<div class="validation-error">‚Ä¢ ${error}</div>`;
        });
      }
      
      if (validation.warnings && validation.warnings.length > 0) {
        html += '<div class="mt-2 text-sm text-white font-semibold">Warnings (no bloqueantes):</div>';
        validation.warnings.forEach(warning => {
          html += `<div class="validation-warning">‚Ä¢ ${warning}</div>`;
        });
      }
      
      messagesContainer.innerHTML = html;
      
    } catch (error) {
      console.error('Error validando:', error);
      messagesContainer.innerHTML = `<div class="validation-error">Error validando: ${error.message}</div>`;
    }
  }
  
  // ============================================================================
  // PUBLICAR RECORRIDO (BLINDAJE v2)
  // ============================================================================
  // 
  // PRINCIPIO: El backend MANDA
  // - Validaci√≥n completa en backend con validateRecorridoDefinition(isPublish: true)
  // - Frontend muestra errores estructurados
  // - NO intenta "arreglar" nada
  //
  async function publicarRecorrido() {
    // Primero, asegurarse de que no hay cambios sin guardar
    if (editorState.dirty) {
      const validation = validateDefinitionForDraft(editorState.definition);
      if (!validation.valid) {
        alert(
          '‚ùå Hay cambios sin guardar que contienen errores:\n\n' +
          validation.errors.join('\n') +
          '\n\nCorrige los errores antes de publicar.'
        );
        return;
      }
      
      // Intentar guardar primero
      const saved = await guardarDraft();
      if (!saved) {
        alert('‚ùå No se pudo guardar el draft. Corrige los errores antes de publicar.');
        return;
      }
    }
    
    const releaseNotes = prompt('Release notes (opcional):');
    
    try {
      const response = await fetch(`/admin/api/recorridos/${encodeURIComponent(editorState.recorridoId)}/publish`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          release_notes: releaseNotes || null
        })
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        // BLINDAJE v2: Mostrar errores estructurados del backend
        let errorMessage = data.error || `Error ${response.status}`;
        
        if (data.details?.errors?.length > 0) {
          errorMessage += '\n\nüìã Errores de validaci√≥n:\n';
          errorMessage += data.details.errors.map(e => `‚Ä¢ ${e}`).join('\n');
        }
        
        if (data.details?.warnings?.length > 0) {
          errorMessage += '\n\n‚ö†Ô∏è Warnings:\n';
          errorMessage += data.details.warnings.map(w => `‚Ä¢ ${w}`).join('\n');
        }
        
        throw new Error(errorMessage);
      }
      
      // √âxito
      let successMessage = `‚úÖ Recorrido publicado exitosamente como versi√≥n ${data.version.version}`;
      
      if (data.validation?.warnings?.length > 0) {
        successMessage += '\n\n‚ö†Ô∏è Warnings (no bloqueantes):\n';
        successMessage += data.validation.warnings.map(w => `‚Ä¢ ${w}`).join('\n');
      }
      
      alert(successMessage);
      
      // Recargar para actualizar estado
      await cargarRecorrido();
      
    } catch (error) {
      console.error('Error publicando:', error);
      alert(`‚ùå Error publicando:\n\n${error.message}`);
    }
  }
  
  /* ============================================================================
   * FUNCIONALIDAD DE REDIMENSIONAMIENTO DEL PANEL DE STEPS
   * ============================================================================
   */
  
  let isResizing = false;
  let previousPanelWidth = null;
  
  function initPanelResizer() {
    const resizer = document.getElementById('panel-resizer');
    const panel = document.getElementById('steps-panel');
    
    if (!resizer || !panel) return;
    
    // Cargar ancho guardado
    const savedWidth = localStorage.getItem('stepsPanelWidth');
    if (savedWidth) {
      const width = parseInt(savedWidth, 10);
      if (width >= 200 && width <= 500) {
        panel.style.setProperty('--steps-panel-width', `${width}px`);
        panel.style.width = `${width}px`;
      }
    }
    
    // Cargar estado colapsado
    const isCollapsed = localStorage.getItem('stepsPanelCollapsed') === 'true';
    if (isCollapsed) {
      previousPanelWidth = savedWidth ? parseInt(savedWidth, 10) : 280;
      panel.classList.add('collapsed');
      updateToggleButton(true);
    }
    
    // Event listeners para drag
    resizer.addEventListener('mousedown', startResize);
    document.addEventListener('mousemove', handleResize);
    document.addEventListener('mouseup', stopResize);
  }
  
  function startResize(e) {
    if (e.button !== 0) return; // Solo bot√≥n izquierdo
    
    const panel = document.getElementById('steps-panel');
    if (!panel || panel.classList.contains('collapsed')) return; // No redimensionar si est√° colapsado
    
    isResizing = true;
    const resizer = document.getElementById('panel-resizer');
    
    if (resizer && panel) {
      resizer.classList.add('resizing');
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    }
    
    e.preventDefault();
  }
  
  function handleResize(e) {
    if (!isResizing) return;
    
    const panel = document.getElementById('steps-panel');
    if (!panel) return;
    
    // Calcular nuevo ancho basado en la posici√≥n del mouse
    const rect = panel.getBoundingClientRect();
    const newWidth = e.clientX - rect.left;
    
    // Aplicar l√≠mites
    const minWidth = 200;
    const maxWidth = 500;
    const clampedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
    
    // Actualizar ancho
    panel.style.setProperty('--steps-panel-width', `${clampedWidth}px`);
    panel.style.width = `${clampedWidth}px`;
    
    // Guardar en localStorage
    localStorage.setItem('stepsPanelWidth', clampedWidth.toString());
  }
  
  function stopResize() {
    if (!isResizing) return;
    
    isResizing = false;
    const resizer = document.getElementById('panel-resizer');
    
    if (resizer) {
      resizer.classList.remove('resizing');
    }
    
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  }
  
  function toggleStepsPanel() {
    const panel = document.getElementById('steps-panel');
    if (!panel) return;
    
    const isCollapsed = panel.classList.contains('collapsed');
    
    if (isCollapsed) {
      // Expandir: restaurar ancho previo
      panel.classList.remove('collapsed');
      const width = previousPanelWidth || 280;
      panel.style.setProperty('--steps-panel-width', `${width}px`);
      panel.style.width = `${width}px`;
      localStorage.setItem('stepsPanelWidth', width.toString());
      localStorage.setItem('stepsPanelCollapsed', 'false');
      updateToggleButton(false);
    } else {
      // Colapsar: guardar ancho actual y reducir a 48px
      const currentWidth = panel.offsetWidth;
      previousPanelWidth = currentWidth;
      panel.classList.add('collapsed');
      localStorage.setItem('stepsPanelCollapsed', 'true');
      updateToggleButton(true);
    }
  }
  
  function updateToggleButton(isCollapsed) {
    const btn = document.getElementById('toggle-steps-panel-btn');
    if (btn) {
      btn.textContent = isCollapsed ? '‚ñ∂' : '‚óÄ';
      btn.title = isCollapsed ? 'Expandir panel' : 'Colapsar panel';
    }
  }
  
  /* ============================================================================
   * REDIMENSIONAMIENTO DEL PANEL DERECHO DE CONFIGURACI√ìN (AXE)
   * ============================================================================
   */
  
  let isResizingRightPanel = false;
  
  function initRightPanelResizer() {
    const resizer = document.getElementById('panel-resizer-right');
    const panel = document.getElementById('config-panel-container');
    
    if (!resizer || !panel) return;
    
    // Cargar ancho guardado desde localStorage
    const savedWidth = localStorage.getItem('axe.editor.rightPanelWidth');
    if (savedWidth) {
      const width = parseInt(savedWidth, 10);
      const minWidth = 320;
      
      // Obtener el contenedor padre para calcular maxWidth correctamente
      const container = panel.closest('#lista-view-container');
      const maxWidth = container 
        ? Math.floor(container.getBoundingClientRect().width * 0.65) 
        : Math.floor(window.innerWidth * 0.65); // Fallback al viewport
      
      if (width >= minWidth && width <= maxWidth) {
        panel.style.setProperty('--config-panel-width', `${width}px`);
        panel.style.width = `${width}px`;
      }
    }
    
    // Event listeners para drag
    resizer.addEventListener('mousedown', startRightPanelResize);
    document.addEventListener('mousemove', handleRightPanelResize);
    document.addEventListener('mouseup', stopRightPanelResize);
  }
  
  function startRightPanelResize(e) {
    if (e.button !== 0) return; // Solo bot√≥n izquierdo
    
    const panel = document.getElementById('config-panel-container');
    if (!panel) return;
    
    isResizingRightPanel = true;
    const resizer = document.getElementById('panel-resizer-right');
    
    if (resizer && panel) {
      resizer.classList.add('resizing');
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    }
    
    e.preventDefault();
  }
  
  function handleRightPanelResize(e) {
    if (!isResizingRightPanel) return;
    
    const panel = document.getElementById('config-panel-container');
    if (!panel) return;
    
    // Obtener el contenedor padre (lista-view-container)
    const container = panel.closest('#lista-view-container');
    if (!container) return;
    
    // Calcular nuevo ancho basado en la posici√≥n del mouse desde el borde derecho del contenedor
    const containerRect = container.getBoundingClientRect();
    const newWidth = containerRect.right - e.clientX;
    
    // Aplicar l√≠mites
    const minWidth = 320;
    const maxWidth = Math.floor(containerRect.width * 0.65); // 65% del ancho del contenedor
    const clampedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
    
    // Actualizar ancho
    panel.style.setProperty('--config-panel-width', `${clampedWidth}px`);
    panel.style.width = `${clampedWidth}px`;
    
    // Guardar en localStorage
    localStorage.setItem('axe.editor.rightPanelWidth', clampedWidth.toString());
  }
  
  function stopRightPanelResize() {
    if (!isResizingRightPanel) return;
    
    isResizingRightPanel = false;
    const resizer = document.getElementById('panel-resizer-right');
    
    if (resizer) {
      resizer.classList.remove('resizing');
    }
    
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  }
  
  // ============================================================================
  // PREVIEW DE STEPS
  // ============================================================================
  
  /**
   * Preview de un step espec√≠fico
   */
  async function previewStep(stepId) {
    if (!editorState.definition || !editorState.definition.steps || !editorState.definition.steps[stepId]) {
      alert('Step no encontrado');
      return;
    }
    
    const step = editorState.definition.steps[stepId];
    mostrarModalPreview(stepId, step);
  }
  
  /**
   * Muestra modal con preview del step
   */
  function mostrarModalPreview(stepId, step) {
    let modal = document.getElementById('preview-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'preview-modal';
      modal.className = 'preview-modal';
      modal.innerHTML = `
        <div class="preview-modal-overlay" onclick="cerrarModalPreview()"></div>
        <div class="preview-modal-content">
          <div class="preview-modal-header">
            <h2>Preview: ${stepId}</h2>
            <div class="preview-modal-actions">
              <select id="preview-mock-mode" class="preview-mock-select">
                <option value="">Sin mock</option>
                <option value="rapida">R√°pida</option>
                <option value="basica">B√°sica</option>
                <option value="profunda">Profunda</option>
                <option value="maestro">Maestro</option>
              </select>
              <button onclick="cerrarModalPreview()" class="preview-close-btn">‚úï</button>
            </div>
          </div>
          <div class="preview-modal-body">
            <div id="preview-loading" class="preview-loading">Cargando preview...</div>
            <div id="preview-content" class="preview-content"></div>
            <div id="preview-warnings" class="preview-warnings"></div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      if (!document.getElementById('preview-modal-styles')) {
        const style = document.createElement('style');
        style.id = 'preview-modal-styles';
        style.textContent = `
          .preview-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000; display: flex; align-items: center; justify-content: center; }
          .preview-modal-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.7); }
          .preview-modal-content { position: relative; background: #1e293b; border-radius: 12px; width: 90%; max-width: 800px; max-height: 90vh; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5); }
          .preview-modal-header { padding: 20px; border-bottom: 1px solid #334155; display: flex; justify-content: space-between; align-items: center; }
          .preview-modal-header h2 { color: #fff; font-size: 18px; margin: 0; }
          .preview-modal-actions { display: flex; gap: 10px; align-items: center; }
          .preview-mock-select { padding: 6px 12px; background: #334155; color: #fff; border: 1px solid #475569; border-radius: 6px; font-size: 14px; }
          .preview-close-btn { padding: 6px 12px; background: #7f1d1d; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 18px; }
          .preview-close-btn:hover { background: #991b1b; }
          .preview-modal-body { padding: 20px; overflow-y: auto; flex: 1; }
          .preview-loading { text-align: center; color: #94a3b8; padding: 40px; }
          .preview-content { background: var(--bg-primary, #fff); border-radius: 8px; padding: 20px; min-height: 200px; color: var(--text-primary, #000); }
          .preview-content[data-theme="dark-classic"] { background: #0f172a; color: #f1f5f9; }
          .preview-content[data-theme="light-classic"] { background: #ffffff; color: #1e293b; }
          .preview-warnings { margin-top: 16px; padding: 12px; background: #78350f; border-radius: 6px; color: #fcd34d; font-size: 14px; }
          .preview-warnings:empty { display: none; }
        `;
        document.head.appendChild(style);
      }
    }
    
    modal.style.display = 'flex';
    cargarPreviewStep(stepId);
    
    const mockSelect = document.getElementById('preview-mock-mode');
    if (mockSelect) {
      mockSelect.onchange = () => cargarPreviewStep(stepId);
    }
  }
  
  /**
   * Carga el preview del step desde el servidor
   */
  async function cargarPreviewStep(stepId) {
    const loadingEl = document.getElementById('preview-loading');
    const contentEl = document.getElementById('preview-content');
    const warningsEl = document.getElementById('preview-warnings');
    
    if (loadingEl) loadingEl.style.display = 'block';
    if (contentEl) contentEl.innerHTML = '';
    if (warningsEl) warningsEl.innerHTML = '';
    
    try {
      const mockSelect = document.getElementById('preview-mock-mode');
      const mockMode = mockSelect ? mockSelect.value : '';
      
      const mock = {};
      if (mockMode) {
        mock.nivel_efectivo = mockMode === 'rapida' ? 1 : mockMode === 'basica' ? 3 : mockMode === 'profunda' ? 5 : 7;
        mock.tipo_limpieza = mockMode;
      }
      
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/preview-step`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          step_id: stepId,
          mock: mock
        })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || `Error ${response.status}`);
      }
      
      const data = await response.json();
      
      if (!data.ok) {
        throw new Error(data.error?.message || 'Error generando preview');
      }
      
      if (contentEl && data.html) {
        // AXE v0.6.9: Guardar HTML original para poder re-aplicar tema
        contentEl.dataset.originalHtml = data.html;
        
        // Aplicar tema seleccionado al preview
        const temaSeleccionado = getTemaPreviewSeleccionado();
        const htmlConTema = aplicarTemaAPreview(data.html, temaSeleccionado);
        contentEl.innerHTML = htmlConTema;
        
        // Aplicar data-theme al contenedor tambi√©n para CSS
        contentEl.setAttribute('data-theme', temaSeleccionado);
      } else if (contentEl) {
        contentEl.innerHTML = '<p class="text-muted">No hay HTML disponible. RenderSpec:</p><pre>' + JSON.stringify(data.render_spec, null, 2) + '</pre>';
      }
      
      if (warningsEl && data.warnings && data.warnings.length > 0) {
        warningsEl.innerHTML = '<strong>‚ö†Ô∏è Advertencias:</strong><ul>' + 
          data.warnings.map(w => `<li>${w}</li>`).join('') + 
          '</ul>';
      }
      
    } catch (error) {
      console.error('Error cargando preview:', error);
      if (contentEl) {
        contentEl.innerHTML = `<p class="text-red-600">Error: ${error.message}</p>`;
      }
    } finally {
      if (loadingEl) loadingEl.style.display = 'none';
    }
  }
  
  /**
   * Obtiene el tema de preview seleccionado desde localStorage (AXE v0.6.9)
   * @returns {string} ID del tema ('dark-classic' por defecto)
   */
  function getTemaPreviewSeleccionado() {
    const temaGuardado = localStorage.getItem('adminThemePreview');
    return temaGuardado || 'dark-classic';
  }
  
  /**
   * Cambia el tema de preview y lo guarda en localStorage (AXE v0.6.9)
   * @param {string} themeId - ID del tema ('dark-classic' o 'light-classic')
   */
  function cambiarTemaPreview(themeId) {
    localStorage.setItem('adminThemePreview', themeId);
    
    // Si hay un preview activo, recargarlo con el nuevo tema
    const contentEl = document.getElementById('preview-content');
    if (contentEl && contentEl.innerHTML.trim() !== '') {
      const htmlOriginal = contentEl.dataset.originalHtml || contentEl.innerHTML;
      const htmlConTema = aplicarTemaAPreview(htmlOriginal, themeId);
      contentEl.innerHTML = htmlConTema;
    }
  }
  
  /**
   * Aplica un tema al HTML del preview (AXE v0.6.9)
   * Envuelve el HTML con data-theme y variables CSS can√≥nicas
   * @param {string} html - HTML del preview
   * @param {string} themeId - ID del tema
   * @returns {string} HTML con tema aplicado
   */
  function aplicarTemaAPreview(html, themeId) {
    if (!html || typeof html !== 'string') return html;
    
    // Si el HTML ya tiene data-theme, actualizarlo
    if (html.includes('data-theme=')) {
      html = html.replace(/data-theme="[^"]*"/gi, `data-theme="${themeId}"`);
    } else {
      // Si no tiene data-theme, a√±adirlo al elemento ra√≠z m√°s externo
      // Buscar el primer elemento HTML o div que parezca contenedor principal
      if (html.includes('<html')) {
        html = html.replace(/<html([^>]*)>/i, `<html$1 data-theme="${themeId}">`);
      } else if (html.includes('<body')) {
        html = html.replace(/<body([^>]*)>/i, `<body$1 data-theme="${themeId}">`);
      } else {
        // Si no hay html/body, envolver en div con data-theme
        html = `<div data-theme="${themeId}">${html}</div>`;
      }
    }
    
    // Asegurar que el contenedor del preview tenga variables CSS del tema
    // (el servidor deber√≠a enviar esto, pero si no, lo a√±adimos como fallback)
    if (!html.includes('theme-variables.css')) {
      // No a√±adir CSS inline porque puede interferir, confiar en que el servidor lo incluye
    }
    
    return html;
  }
  
  /**
   * Cierra el modal de preview
   */
  function cerrarModalPreview() {
    const modal = document.getElementById('preview-modal');
    if (modal) {
      modal.style.display = 'none';
    }
  }
  
  // SPRINT AXE v0.3: Preview Harness Unificado
  let previewHarness = null;
  
  function initPreviewHarness() {
    const container = document.getElementById('preview-harness-container');
    if (!container) return;
    
    // Cargar CSS del Preview Harness
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = '/css/preview-harness.css';
    document.head.appendChild(link);
    
    // Cargar JS del Preview Harness
    const script = document.createElement('script');
    script.src = '/js/preview-harness.js';
    script.onload = async () => {
      // Inicializar Preview Harness
      if (window.PreviewHarness) {
        previewHarness = new window.PreviewHarness('preview-harness-container', {
          previewEndpoint: '/admin/api/recorridos',
          recorridoId: editorState.recorridoId,
          stepId: editorState.selectedStepId || null
        });
        
        // Actualizar cuando cambie el step
        const originalRenderPreview = renderPreview;
        renderPreview = async function() {
          if (previewHarness && editorState.selectedStepId) {
            // Usar Preview Harness
            container.style.display = 'block';
            document.getElementById('preview-container').style.display = 'none';
            
            previewHarness.setStepId(editorState.selectedStepId);
            previewHarness.setRecorridoId(editorState.recorridoId);
            
            // Auto-refresh si hay un step seleccionado
            if (editorState.selectedStepId) {
              await previewHarness.refreshPreview();
            }
          } else {
            // Usar preview legacy
            container.style.display = 'none';
            document.getElementById('preview-container').style.display = 'block';
            await originalRenderPreview();
          }
        };
      }
    };
    document.head.appendChild(script);
  }

  // ============================================================================
  // VISTA CANVAS v1 (AXE v0.6.3)
  // ============================================================================
  
  let canvasViewState = {
    active: true,  // AXE v0.6.11: Canvas es vista por defecto
    canvas: null,
    source: null,  // 'derived' | 'persisted' | null
    warnings: [],
    lastSavedCanvas: null,  // Canvas guardado para detectar cambios
    dirty: false   // ¬øHay cambios sin guardar?
  };
  
  /**
   * Toggle del panel JSON (colapsable)
   */
  function toggleJsonPanel() {
    const jsonPanel = document.getElementById('canvas-json-panel');
    const toggleBtn = document.getElementById('toggle-json-btn');
    
    if (!jsonPanel) return;
    
    const isVisible = jsonPanel.style.display !== 'none';
    jsonPanel.style.display = isVisible ? 'none' : 'block';
    
    if (toggleBtn) {
      toggleBtn.textContent = isVisible ? 'üìÑ JSON' : 'üìÑ Ocultar JSON';
    }
  }
  
  /**
   * Toggle pantalla completa del editor visual
   */
  function toggleFullscreenCanvas() {
    const viewer = document.getElementById('canvas-viewer');
    if (!viewer) return;
    
    const container = viewer.closest('.bg-slate-800');
    if (!container) return;
    
    if (!document.fullscreenElement) {
      // Entrar en pantalla completa
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      }
    } else {
      // Salir de pantalla completa
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
  }
  
  /**
   * Toggle entre Vista Canvas (por defecto) y Vista Lista (AXE v0.6.11)
   */
  function toggleVistaCanvas() {
    canvasViewState.active = !canvasViewState.active;
    const listaView = document.getElementById('lista-view-container');
    const canvasView = document.getElementById('canvas-view-container');
    const toggleBtn = document.getElementById('toggle-vista-btn');
    const toggleLabel = document.getElementById('toggle-vista-label');
    
    if (canvasViewState.active) {
      // Mostrar Canvas
      listaView.style.display = 'none';
      canvasView.style.display = 'block';
      toggleLabel.textContent = 'üìã Lista';
      cargarCanvas();
    } else {
      // Mostrar Lista
      listaView.style.display = 'flex';
      canvasView.style.display = 'none';
      toggleLabel.textContent = 'üé® Canvas';
    }
  }
  
  /**
   * Carga el canvas desde el servidor
   */
  async function cargarCanvas() {
    if (!editorState.recorridoId) {
      alert('No hay recorrido cargado');
      return;
    }
    
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas`, {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || `Error ${response.status}`);
      }
      
      const data = await response.json();
      canvasViewState.canvas = data.canvas;
      canvasViewState.source = data.source;
      canvasViewState.warnings = data.warnings || [];
      
      // Guardar canvas original para detectar cambios (AXE v0.6.11)
      if (data.source === 'persisted') {
        canvasViewState.lastSavedCanvas = JSON.stringify(data.canvas, null, 2);
        canvasViewState.dirty = false;
      } else {
        canvasViewState.lastSavedCanvas = null;
        canvasViewState.dirty = false;  // DERIVED no se considera dirty hasta que se edite
      }
      
      // Actualizar badge de estado (AXE v0.6.11)
      actualizarCanvasStateBadge();
      
      // Mostrar warnings
      mostrarCanvasWarnings();
      
      // Actualizar editor JSON
      const jsonEditor = document.getElementById('canvas-json-editor');
      if (jsonEditor) {
        jsonEditor.value = JSON.stringify(data.canvas, null, 2);
      }
      
      // Actualizar viewer (preservando selecci√≥n si el nodo a√∫n existe)
      const selectedNodeId = window.canvasSelectionState?.selectedNodeId;
      if (selectedNodeId && !data.canvas.nodes?.find(n => n.id === selectedNodeId)) {
        if (window.canvasSelectionState) {
          window.canvasSelectionState.selectedNodeId = null;
        }
      }
      renderCanvasViewer(data.canvas);
      
      // Actualizar diagn√≥stico autom√°ticamente al cargar
      actualizarDiagnostico();
      
    } catch (error) {
      console.error('Error cargando canvas:', error);
      mostrarToast(`Error cargando canvas: ${error.message}`, 'error');
    }
  }
  
  /**
   * Muestra warnings del canvas
   */
  function mostrarCanvasWarnings() {
    const warningsEl = document.getElementById('canvas-warnings');
    if (!warningsEl) return;
    
    if (canvasViewState.warnings.length === 0) {
      warningsEl.innerHTML = '';
      return;
    }
    
    warningsEl.innerHTML = `
      <div class="bg-yellow-900 border border-yellow-700 rounded-lg p-4">
        <h4 class="text-yellow-200 font-semibold mb-2">‚ö†Ô∏è Advertencias</h4>
        <ul class="text-yellow-100 text-sm list-disc list-inside">
          ${canvasViewState.warnings.map(w => `<li>${w}</li>`).join('')}
        </ul>
      </div>
    `;
  }
  
  /**
   * Actualiza el diagn√≥stico del canvas (AXE v0.6.9)
   */
  async function actualizarDiagnostico() {
    const diagnosticoEl = document.getElementById('canvas-diagnostico');
    if (!diagnosticoEl) return;
    
    // Obtener canvas actual (del editor o del estado)
    let canvas = canvasViewState.canvas;
    
    // Si no hay canvas en estado, intentar parsear del editor
    if (!canvas) {
      const jsonEditor = document.getElementById('canvas-json-editor');
      if (jsonEditor && jsonEditor.value) {
        try {
          canvas = JSON.parse(jsonEditor.value);
        } catch (e) {
          diagnosticoEl.innerHTML = '<p class="text-slate-400 text-sm">Canvas inv√°lido en el editor JSON</p>';
          return;
        }
      } else {
        diagnosticoEl.innerHTML = '<p class="text-slate-400 text-sm">Carga un canvas para ver diagn√≥sticos</p>';
        return;
      }
    }
    
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      
      // Usar POST para analizar el canvas del editor (puede no estar guardado)
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/analyze`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || `Error ${response.status}`);
      }
      
      const data = await response.json();
      renderDiagnostico(data.warnings || [], data.infos || []);
      
      // Tambi√©n actualizar sugerencias si est√°n disponibles
      if (data.suggestions) {
        renderSugerencias(data.suggestions || []);
      }
      
    } catch (error) {
      console.error('Error analizando canvas:', error);
      diagnosticoEl.innerHTML = `<p class="axe-panel-error">Error: ${error.message}</p>`;
    }
  }
  
  /**
   * Actualiza las sugerencias pedag√≥gicas del canvas (AXE v0.6.10)
   */
  async function actualizarSugerencias() {
    const sugerenciasEl = document.getElementById('canvas-sugerencias');
    if (!sugerenciasEl) return;
    
    // Obtener canvas actual (del editor o del estado)
    let canvas = canvasViewState.canvas;
    
    // Si no hay canvas en estado, intentar parsear del editor
    if (!canvas) {
      const jsonEditor = document.getElementById('canvas-json-editor');
      if (jsonEditor && jsonEditor.value) {
        try {
          canvas = JSON.parse(jsonEditor.value);
        } catch (e) {
          sugerenciasEl.innerHTML = '<p class="axe-panel-item__text">Canvas inv√°lido en el editor JSON</p>';
          return;
        }
      } else {
        sugerenciasEl.innerHTML = '<p class="axe-panel-item__text">Carga un canvas para ver sugerencias</p>';
        return;
      }
    }
    
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      
      // Usar POST para analizar el canvas del editor (puede no estar guardado)
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/analyze`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || `Error ${response.status}`);
      }
      
      const data = await response.json();
      renderSugerencias(data.suggestions || []);
      
    } catch (error) {
      console.error('Error obteniendo sugerencias:', error);
      sugerenciasEl.innerHTML = `<p class="axe-panel-error">Error: ${error.message}</p>`;
    }
  }
  
  /**
   * Renderiza el panel de sugerencias pedag√≥gicas (AXE v0.6.10)
   */
  function renderSugerencias(suggestions) {
    const sugerenciasEl = document.getElementById('canvas-sugerencias');
    if (!sugerenciasEl) return;
    
    if (suggestions.length === 0) {
      sugerenciasEl.innerHTML = '<p class="axe-panel-empty">‚úÖ No hay sugerencias pedag√≥gicas en este momento</p>';
      return;
    }
    
    // Agrupar por tipo y prioridad
    const byType = {
      pedagogical: suggestions.filter(s => s.type === 'pedagogical'),
      rhythm: suggestions.filter(s => s.type === 'rhythm'),
      clarity: suggestions.filter(s => s.type === 'clarity')
    };
    
    // Agrupar por prioridad dentro de cada tipo
    const byPriority = {
      high: suggestions.filter(s => s.priority === 'high'),
      medium: suggestions.filter(s => s.priority === 'medium'),
      low: suggestions.filter(s => s.priority === 'low')
    };
    
    let html = '';
    
    // Mostrar primero las de alta prioridad
    if (byPriority.high.length > 0) {
      html += '<div class="mb-4">';
      html += '<h4 class="axe-panel-section-title axe-panel-section-title--high">üî¥ Alta Prioridad</h4>';
      html += '<div class="axe-panel-items">';
      
      for (const suggestion of byPriority.high) {
        const categoryIcon = {
          intention: 'üí°',
          decision: '‚ùì',
          ending: 'üèÅ',
          sequence: 'üìè',
          balance: '‚öñÔ∏è',
          meta: 'üìù'
        }[suggestion.category] || 'üí≠';
        
        const clickableClass = suggestion.node_id ? 'axe-panel-item--clickable' : '';
        const onClickAttr = suggestion.node_id ? `onclick="seleccionarNodoDiagnostico('${suggestion.node_id}')"` : '';
        
        html += `<div class="axe-panel-item axe-panel-item--high ${clickableClass}" ${onClickAttr}>`;
        html += `<div class="flex items-start gap-2">`;
        html += `<span class="axe-panel-item__icon">${categoryIcon}</span>`;
        html += `<div class="flex-1">`;
        html += `<p class="axe-panel-item__text">${escapeHtml(suggestion.message)}</p>`;
        if (suggestion.node_id) {
          html += `<p class="axe-panel-item__text text-xs mt-1">Click para seleccionar nodo: <code class="axe-panel-item__badge axe-panel-item__badge--high">${suggestion.node_id}</code></p>`;
        }
        html += `</div>`;
        html += `</div>`;
        html += `</div>`;
      }
      
      html += '</div>';
      html += '</div>';
    }
    
    // Luego las de prioridad media
    if (byPriority.medium.length > 0) {
      html += '<div class="mb-4">';
      html += '<h4 class="axe-panel-section-title axe-panel-section-title--medium">üü° Prioridad Media</h4>';
      html += '<div class="axe-panel-items">';
      
      for (const suggestion of byPriority.medium) {
        const categoryIcon = {
          intention: 'üí°',
          decision: '‚ùì',
          ending: 'üèÅ',
          sequence: 'üìè',
          balance: '‚öñÔ∏è',
          meta: 'üìù'
        }[suggestion.category] || 'üí≠';
        
        const clickableClass = suggestion.node_id ? 'axe-panel-item--clickable' : '';
        const onClickAttr = suggestion.node_id ? `onclick="seleccionarNodoDiagnostico('${suggestion.node_id}')"` : '';
        
        html += `<div class="axe-panel-item axe-panel-item--medium ${clickableClass}" ${onClickAttr}>`;
        html += `<div class="flex items-start gap-2">`;
        html += `<span class="axe-panel-item__icon">${categoryIcon}</span>`;
        html += `<div class="flex-1">`;
        html += `<p class="axe-panel-item__text">${escapeHtml(suggestion.message)}</p>`;
        if (suggestion.node_id) {
          html += `<p class="axe-panel-item__text text-xs mt-1">Click para seleccionar nodo: <code class="axe-panel-item__badge axe-panel-item__badge--medium">${suggestion.node_id}</code></p>`;
        }
        html += `</div>`;
        html += `</div>`;
        html += `</div>`;
      }
      
      html += '</div>';
      html += '</div>';
    }
    
    // Finalmente las de baja prioridad
    if (byPriority.low.length > 0) {
      html += '<div>';
      html += '<h4 class="axe-panel-section-title axe-panel-section-title--low">üîµ Prioridad Baja</h4>';
      html += '<div class="axe-panel-items">';
      
      for (const suggestion of byPriority.low) {
        const categoryIcon = {
          intention: 'üí°',
          decision: '‚ùì',
          ending: 'üèÅ',
          sequence: 'üìè',
          balance: '‚öñÔ∏è',
          meta: 'üìù'
        }[suggestion.category] || 'üí≠';
        
        const clickableClass = suggestion.node_id ? 'axe-panel-item--clickable' : '';
        const onClickAttr = suggestion.node_id ? `onclick="seleccionarNodoDiagnostico('${suggestion.node_id}')"` : '';
        
        html += `<div class="axe-panel-item axe-panel-item--low ${clickableClass}" ${onClickAttr}>`;
        html += `<div class="flex items-start gap-2">`;
        html += `<span class="axe-panel-item__icon">${categoryIcon}</span>`;
        html += `<div class="flex-1">`;
        html += `<p class="axe-panel-item__text">${escapeHtml(suggestion.message)}</p>`;
        if (suggestion.node_id) {
          html += `<p class="axe-panel-item__text text-xs mt-1">Click para seleccionar nodo: <code class="axe-panel-item__badge axe-panel-item__badge--low">${suggestion.node_id}</code></p>`;
        }
        html += `</div>`;
        html += `</div>`;
        html += `</div>`;
      }
      
      html += '</div>';
      html += '</div>';
    }
    
    sugerenciasEl.innerHTML = html;
  }
  
  /**
   * Renderiza el panel de diagn√≥stico
   */
  function renderDiagnostico(warnings, infos) {
    const diagnosticoEl = document.getElementById('canvas-diagnostico');
    if (!diagnosticoEl) return;
    
    if (warnings.length === 0 && infos.length === 0) {
      diagnosticoEl.innerHTML = '<p class="axe-panel-empty">‚úÖ No se encontraron observaciones</p>';
      return;
    }
    
    let html = '';
    
    // Agrupar por tipo
    const warningsByType = {
      structural: warnings.filter(d => d.type === 'structural'),
      pedagogical: warnings.filter(d => d.type === 'pedagogical'),
      rhythm: warnings.filter(d => d.type === 'rhythm')
    };
    
    const infosByType = {
      structural: infos.filter(d => d.type === 'structural'),
      pedagogical: infos.filter(d => d.type === 'pedagogical'),
      rhythm: infos.filter(d => d.type === 'rhythm')
    };
    
    // Renderizar warnings
    if (warnings.length > 0) {
      html += '<div class="mb-4">';
      html += '<h4 class="axe-panel-section-title axe-panel-section-title--warning">‚ö†Ô∏è Advertencias</h4>';
      html += '<div class="axe-panel-items axe-panel-items--compact">';
      
      for (const warning of warnings) {
        const typeLabel = {
          structural: 'üîß',
          pedagogical: 'üìö',
          rhythm: '‚è±Ô∏è'
        }[warning.type] || '‚ö†Ô∏è';
        
        const clickableClass = warning.node_id ? 'axe-panel-item--clickable' : '';
        const onClickAttr = warning.node_id ? `onclick="seleccionarNodoDiagnostico('${warning.node_id}')"` : '';
        
        html += `<div class="axe-panel-item axe-panel-item--warning ${clickableClass}" ${onClickAttr}>`;
        html += `<div class="flex items-start gap-2">`;
        html += `<span class="axe-panel-item__icon">${typeLabel}</span>`;
        html += `<span class="axe-panel-item__text flex-1">${escapeHtml(warning.message)}</span>`;
        if (warning.node_id) {
          html += `<span class="axe-panel-item__text text-xs">‚Üí <code class="axe-panel-item__badge axe-panel-item__badge--warning">${warning.node_id}</code></span>`;
        }
        html += `</div>`;
        html += `</div>`;
      }
      
      html += '</div>';
      html += '</div>';
    }
    
    // Renderizar infos
    if (infos.length > 0) {
      html += '<div>';
      html += '<h4 class="axe-panel-section-title axe-panel-section-title--info">‚ÑπÔ∏è Informaci√≥n</h4>';
      html += '<div class="axe-panel-items axe-panel-items--compact">';
      
      for (const info of infos) {
        const typeLabel = {
          structural: 'üîß',
          pedagogical: 'üìö',
          rhythm: '‚è±Ô∏è'
        }[info.type] || '‚ÑπÔ∏è';
        
        const clickableClass = info.node_id ? 'axe-panel-item--clickable' : '';
        const onClickAttr = info.node_id ? `onclick="seleccionarNodoDiagnostico('${info.node_id}')"` : '';
        
        html += `<div class="axe-panel-item axe-panel-item--info ${clickableClass}" ${onClickAttr}>`;
        html += `<div class="flex items-start gap-2">`;
        html += `<span class="axe-panel-item__icon">${typeLabel}</span>`;
        html += `<span class="axe-panel-item__text flex-1">${escapeHtml(info.message)}</span>`;
        if (info.node_id) {
          html += `<span class="axe-panel-item__text text-xs">‚Üí <code class="axe-panel-item__badge axe-panel-item__badge--info">${info.node_id}</code></span>`;
        }
        html += `</div>`;
        html += `</div>`;
      }
      
      html += '</div>';
      html += '</div>';
    }
    
    diagnosticoEl.innerHTML = html;
  }
  
  /**
   * Selecciona un nodo cuando se hace click en un diagn√≥stico
   */
  function seleccionarNodoDiagnostico(nodeId) {
    // Buscar el nodo en el viewer y resaltarlo
    const canvas = canvasViewState.canvas;
    if (!canvas) return;
    
    const node = canvas.nodes?.find(n => n.id === nodeId);
    if (!node) {
      mostrarToast(`Nodo '${nodeId}' no encontrado`, 'warning');
      return;
    }
    
    // Actualizar selecci√≥n en el viewer
    if (window.canvasSelectionState) {
      window.canvasSelectionState.selectedNodeId = nodeId;
    }
    
    // Re-renderizar viewer para mostrar selecci√≥n
    renderCanvasViewer(canvas);
    
    // Scroll al nodo en el viewer si es posible
    const viewerEl = document.getElementById('canvas-viewer');
    if (viewerEl) {
      const nodeEl = viewerEl.querySelector(`[data-node-id="${nodeId}"]`);
      if (nodeEl) {
        nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Resaltar temporalmente
        nodeEl.classList.add('ring-2', 'ring-yellow-400');
        setTimeout(() => {
          nodeEl.classList.remove('ring-2', 'ring-yellow-400');
        }, 2000);
      }
    }
    
    mostrarToast(`Nodo '${nodeId}' seleccionado`, 'info');
  }
  
  /**
   * Helper para escapar HTML
   */
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  /**
   * Determina las acciones sem√°nticas permitidas para un nodo (AXE v0.6.5)
   * 
   * @param {Object} node - Nodo del canvas
   * @param {Object} canvas - CanvasDefinition completo (para contexto)
   * @returns {Array} Array de objetos { action, label, icon, description, enabled }
   */
  function getSemanticActionsForNode(node, canvas) {
    if (!node || !canvas) return [];
    
    const nodeType = node.type || 'screen';
    const actions = [];
    
    // insertNodeAfter: v√°lida para cualquier nodo excepto end
    if (nodeType !== 'end') {
      actions.push({
        action: 'insertNodeAfter',
        label: 'Insertar despu√©s',
        icon: '‚ûï',
        description: 'Inserta un nuevo nodo despu√©s de este',
        enabled: true
      });
    }
    
    // convertNodeToDecision: v√°lida solo para screen
    if (nodeType === 'screen') {
      actions.push({
        action: 'convertNodeToDecision',
        label: 'Convertir a decisi√≥n',
        icon: 'üîÄ',
        description: 'Convierte este nodo en una decisi√≥n con opciones',
        enabled: true
      });
    }
    
    // markAsStart: v√°lida para cualquier nodo excepto end
    if (nodeType !== 'end') {
      const isAlreadyStart = nodeType === 'start';
      actions.push({
        action: 'markAsStart',
        label: isAlreadyStart ? 'Ya es inicio' : 'Marcar como inicio',
        icon: 'üöÄ',
        description: isAlreadyStart ? 'Este nodo ya es el nodo de inicio' : 'Marca este nodo como punto de entrada',
        enabled: !isAlreadyStart
      });
    }
    
    // markAsEnd: v√°lida para cualquier nodo excepto start
    if (nodeType !== 'start') {
      const isAlreadyEnd = nodeType === 'end';
      actions.push({
        action: 'markAsEnd',
        label: isAlreadyEnd ? 'Ya es fin' : 'Marcar como fin',
        icon: 'üèÅ',
        description: isAlreadyEnd ? 'Este nodo ya es un nodo de fin' : 'Marca este nodo como punto de salida',
        enabled: !isAlreadyEnd
      });
    }
    
    // duplicateSubgraph: v√°lida para cualquier nodo
    actions.push({
      action: 'duplicateSubgraph',
      label: 'Duplicar subgrafo',
      icon: 'üìã',
      description: 'Duplica este nodo y todos los nodos alcanzables desde √©l',
      enabled: true,
      isMacro: false
    });
    
    // Separador visual entre acciones simples y macros
    actions.push({
      action: '_separator',
      label: '---',
      icon: '',
      description: '',
      enabled: false,
      isMacro: false,
      isSeparator: true
    });
    
    // MACROS COMPUESTAS (AXE v0.6.6)
    // insertStandardEnding: v√°lida para cualquier nodo excepto end
    if (nodeType !== 'end') {
      actions.push({
        action: 'insertStandardEnding',
        label: 'Insertar finalizaci√≥n est√°ndar',
        icon: '‚ú®',
        description: 'Inserta un nodo de finalizaci√≥n est√°ndar despu√©s de este nodo',
        enabled: true,
        isMacro: true
      });
    }
    
    // createGuidedChoice: v√°lida para screen (lo convierte a decision con nodos despu√©s)
    if (nodeType === 'screen') {
      actions.push({
        action: 'createGuidedChoice',
        label: 'Crear decisi√≥n guiada',
        icon: 'üéØ',
        description: 'Convierte este nodo en decisi√≥n y crea nodos despu√©s de cada opci√≥n',
        enabled: true,
        isMacro: true
      });
    }
    
    // createBranchingPath: v√°lida para cualquier nodo excepto end
    if (nodeType !== 'end') {
      actions.push({
        action: 'createBranchingPath',
        label: 'Crear ramificaci√≥n',
        icon: 'üå≥',
        description: 'Crea una estructura de ramificaci√≥n con m√∫ltiples ramas',
        enabled: true,
        isMacro: true
      });
    }
    
    // createLinearSequence: v√°lida para cualquier nodo excepto end
    if (nodeType !== 'end') {
      actions.push({
        action: 'createLinearSequence',
        label: 'Crear secuencia lineal',
        icon: 'üìù',
        description: 'Crea una secuencia lineal de nodos despu√©s de este',
        enabled: true,
        isMacro: true
      });
    }
    
    return actions;
  }
  
  /**
   * Renderiza el canvas viewer en modo READ-ONLY (AXE v0.6.11)
   * Solo visualizaci√≥n, sin acciones de edici√≥n
   */
  function renderCanvasViewerReadOnly(canvas) {
    const viewer = document.getElementById('canvas-viewer');
    if (!viewer || !canvas) return;
    
    let html = '<div class="space-y-4">';
    
    // Mensaje de modo READ-ONLY
    html += `
      <div class="bg-blue-900 border border-blue-700 rounded-lg p-3 mb-4">
        <p class="text-blue-200 text-sm">
          <strong>üìñ Modo Navegaci√≥n (READ-ONLY)</strong> ‚Äî Solo visualizaci√≥n del flujo
        </p>
      </div>
    `;
    
    // Nodos como tarjetas en grid (NO clickeables)
    html += '<div><h4 class="text-white font-semibold mb-2">Nodos del Flujo</h4>';
    html += '<div class="grid grid-cols-2 md:grid-cols-3 gap-2">';
    for (const node of canvas.nodes || []) {
      // Badge de tipo
      let typeBadge = '';
      if (node.type === 'start') {
        typeBadge = '<span class="px-1.5 py-0.5 bg-green-600 text-white text-xs rounded ml-1">START</span>';
      } else if (node.type === 'end') {
        typeBadge = '<span class="px-1.5 py-0.5 bg-orange-600 text-white text-xs rounded ml-1">END</span>';
      } else if (node.type === 'decision') {
        typeBadge = '<span class="px-1.5 py-0.5 bg-purple-600 text-white text-xs rounded ml-1">DECISION</span>';
      }
      
      html += `
        <div class="border border-slate-700 bg-slate-800 rounded p-2">
          <div class="flex items-center justify-between">
            <div class="text-white font-medium text-sm">${node.id}</div>
            ${typeBadge}
          </div>
          <div class="text-slate-400 text-xs mt-1">${node.type}</div>
          ${node.label ? `<div class="text-slate-300 text-xs mt-1">${node.label}</div>` : ''}
        </div>
      `;
    }
    html += '</div></div>';
    
    // Edges como lista (mostrando el flujo)
    html += '<div><h4 class="text-white font-semibold mb-2">Flujo (Edges)</h4>';
    html += '<div class="space-y-1">';
    for (const edge of canvas.edges || []) {
      html += `
        <div class="bg-slate-800 border border-slate-700 rounded p-2 text-sm">
          <span class="text-white">${edge.from_node_id}</span>
          <span class="text-slate-400"> ‚Üí </span>
          <span class="text-white">${edge.to_node_id}</span>
          ${edge.type ? `<span class="text-slate-400 text-xs ml-2">[${edge.type}]</span>` : ''}
          ${edge.label ? `<span class="text-slate-300 text-xs ml-2">(${edge.label})</span>` : ''}
        </div>
      `;
    }
    html += '</div></div>';
    
    html += '</div>';
    viewer.innerHTML = html;
  }
  
  /**
   * Actualiza el panel contextual lateral (AXE v0.6.9)
   * Renderiza acciones, macros, meta, diagn√≥stico y propiedades del nodo seleccionado
   */
  function actualizarPanelContextual(canvas) {
    const panelContent = document.getElementById('canvas-contextual-panel-content');
    if (!panelContent || !canvas) return;
    
    // Estado de selecci√≥n
    if (!window.canvasSelectionState) {
      window.canvasSelectionState = { selectedNodeId: null };
    }
    
    const selectedNodeId = window.canvasSelectionState.selectedNodeId;
    const selectedNode = selectedNodeId 
      ? (canvas.nodes || []).find(n => n.id === selectedNodeId)
      : null;
    
    let html = '';
    
    if (selectedNode) {
      const actions = getSemanticActionsForNode(selectedNode, canvas);
      html += `
        <div class="bg-indigo-900 border-2 border-indigo-500 rounded-lg p-4 mb-4">
          <div class="flex justify-between items-start mb-3">
            <div>
              <h4 class="text-white font-semibold text-lg">Nodo seleccionado: ${selectedNode.id}</h4>
              <p class="text-indigo-200 text-sm mt-1">
                Tipo: <span class="font-mono">${selectedNode.type}</span>
                ${selectedNode.label ? ` ‚Ä¢ ${selectedNode.label}` : ''}
              </p>
            </div>
            <button 
              onclick="deseleccionarNodo()" 
              class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-sm rounded transition-colors"
              title="Deseleccionar nodo"
            >
              ‚úï
            </button>
          </div>
          <div class="space-y-2">
            <p class="text-indigo-200 text-sm font-medium mb-2">Acciones disponibles:</p>
            <div class="space-y-3">
              <!-- Acciones simples -->
              <div>
                <p class="text-indigo-300 text-xs font-medium mb-1.5">Acciones simples:</p>
                <div class="grid grid-cols-1 gap-2">
      `;
      
      let hasSimpleActions = false;
      let hasMacros = false;
      
      for (const action of actions) {
        if (action.isSeparator) {
          // Separador visual
          if (hasSimpleActions && !hasMacros) {
            html += `
                </div>
              </div>
              <!-- Macros compuestas -->
              <div>
                <p class="text-indigo-300 text-xs font-medium mb-1.5">
                  <span class="px-1.5 py-0.5 bg-purple-600 text-white text-xs rounded mr-1">MACRO</span>
                  Acciones compuestas:
                </p>
                <div class="grid grid-cols-1 gap-2">
            `;
            hasMacros = true;
          }
          continue;
        }
        
        if (!action.isMacro) {
          hasSimpleActions = true;
        } else {
          hasMacros = true;
        }
        
        const buttonClass = action.enabled
          ? action.isMacro
            ? 'w-full px-3 py-2 bg-purple-600 hover:bg-purple-700 text-white text-sm font-medium rounded transition-colors flex items-center gap-2 border border-purple-400'
            : 'w-full px-3 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium rounded transition-colors flex items-center gap-2'
          : 'w-full px-3 py-2 bg-slate-700 text-slate-400 text-sm font-medium rounded cursor-not-allowed flex items-center gap-2';
        
        html += `
          <button 
            onclick="${action.enabled ? `ejecutarAccionSemanticaContextual('${action.action}', '${selectedNode.id}')` : ''}"
            class="${buttonClass}"
            title="${action.description}"
            ${action.enabled ? '' : 'disabled'}
          >
            <span>${action.icon}</span>
            <span>${action.label}</span>
            ${action.isMacro ? '<span class="text-xs opacity-75 ml-auto">‚ö°</span>' : ''}
          </button>
        `;
      }
      
      // Cerrar divs si hay macros
      if (hasMacros) {
        html += `
                </div>
              </div>
        `;
      } else {
        html += `
                </div>
        `;
      }
      
      // Editor de Meta (AXE v0.6.8: metadatos pedag√≥gicos de intenci√≥n)
      html += `
          </div>
          <div class="border-t border-indigo-700 pt-3 mt-3">
            <p class="text-indigo-200 text-sm font-medium mb-2">üìù Metadatos Sem√°nticos (Meta):</p>
            <div class="space-y-2">
              <textarea 
                id="node-meta-editor" 
                class="w-full h-32 bg-slate-900 text-slate-100 font-mono text-xs p-2 rounded border border-slate-700 resize-none"
                placeholder='{"intention": "objetivo pedag√≥gico", "notes": "notas internas"}'
              >${selectedNode.meta ? JSON.stringify(selectedNode.meta, null, 2) : ''}</textarea>
              <div class="flex gap-2">
                <button 
                  onclick="guardarMetaNodo('${selectedNode.id}')" 
                  class="px-3 py-1.5 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded transition-colors"
                  title="Guardar meta del nodo"
                >
                  üíæ Guardar Meta
                </button>
                <button 
                  onclick="limpiarMetaNodo('${selectedNode.id}')" 
                  class="px-3 py-1.5 bg-red-600 hover:bg-red-700 text-white text-sm font-medium rounded transition-colors"
                  title="Eliminar meta del nodo"
                >
                  üóëÔ∏è Limpiar Meta
                </button>
              </div>
              <p class="text-indigo-300 text-xs">
                Meta es opcional y no afecta el runtime. √ösalo para notas pedag√≥gicas, intenciones, etc.
              </p>
            </div>
          </div>
          <div class="border-t border-indigo-700 pt-3 mt-3">
            <p class="text-indigo-200 text-sm font-medium mb-2">üóëÔ∏è Eliminar Nodo:</p>
            <button 
              onclick="deleteSelectedNode()" 
              class="w-full px-3 py-2 bg-red-600 hover:bg-red-700 text-white text-sm font-medium rounded transition-colors"
              title="Eliminar este nodo (Delete/Backspace)"
            >
              üóëÔ∏è Eliminar nodo "${selectedNode.id}"
            </button>
            <p class="text-indigo-300 text-xs mt-2">
              Elimina el nodo y sus conexiones. Si es START o √∫ltimo END, se reparar√° autom√°ticamente.
            </p>
          </div>
        </div>
      `;
    } else {
      html += `
        <div class="bg-slate-800 border border-slate-600 rounded-lg p-4">
          <div class="flex items-start gap-3">
            <span class="text-2xl">üí°</span>
            <div>
              <p class="text-slate-200 text-sm font-semibold mb-1">Editor Visual AXE v1.0</p>
              <p class="text-slate-300 text-sm">
                <strong>Arrastra los nodos</strong> para moverlos. <strong>Haz clic en un nodo</strong> para seleccionarlo y ver acciones sem√°nticas.
              </p>
              <p class="text-slate-400 text-xs mt-2">
                Usa <strong>Alt + rueda</strong> para hacer zoom. Arrastra el fondo para mover el canvas. Rueda sin teclas = scroll normal.
              </p>
            </div>
          </div>
        </div>
      `;
    }
    
    panelContent.innerHTML = html;
  }
  
  /**
   * Renderiza el canvas viewer con UI sem√°ntica contextual (AXE v0.6.5)
   * AXE v0.6.9: Panel contextual movido a aside lateral sticky
   */
  function renderCanvasViewer(canvas) {
    const viewer = document.getElementById('canvas-viewer');
    if (!viewer || !canvas) return;
    
    // Estado de selecci√≥n
    if (!window.canvasSelectionState) {
      window.canvasSelectionState = { selectedNodeId: null };
    }
    
    // Obtener selectedNodeId de forma segura (tolerante a null)
    const selectedNodeId = window.canvasSelectionState?.selectedNodeId ?? null;
    
    // AXE v0.6.9: Actualizar panel contextual lateral (ya no se renderiza aqu√≠)
    actualizarPanelContextual(canvas);
    
    let html = '<div class="space-y-4">';
    
    // EDITOR VISUAL: Canvas con nodos posicionados y edges SVG (AXE v0.7.0)
    // Estado de pan/zoom para el canvas visual
    if (!window.canvasVisualState) {
      window.canvasVisualState = {
        panX: 0,
        panY: 0,
        zoom: 1,
        isDragging: false,
        dragStartX: 0,
        dragStartY: 0,
        dragNodeId: null,
        dragOffsetX: 0,
        dragOffsetY: 0,
        isPanning: false,
        panStartX: 0,
        panStartY: 0,
        snappingEnabled: false,
        snapGrid: 20  // Tama√±o de la grilla para snapping
      };
    }
    
    html += `
      <div class="bg-slate-800 rounded-lg p-4 mb-4">
        <div class="flex justify-between items-center mb-2">
          <h4 class="text-white font-semibold">Editor Visual</h4>
          <div class="flex gap-2">
            <button onclick="toggleSnapping()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" id="snap-toggle-btn" title="Activar/Desactivar snapping">
              üìê Snap: OFF
            </button>
            <button onclick="resetCanvasView()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Resetear vista">
              üîÑ Reset Vista
            </button>
            <button onclick="zoomOutCanvas()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Alejar">
              ‚ûñ
            </button>
            <span class="text-slate-400 text-xs px-2 py-1" id="zoom-level">100%</span>
            <button onclick="zoomInCanvas()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Acercar">
              ‚ûï
            </button>
          </div>
        </div>
        <div 
          id="canvas-visual-container" 
          class="relative bg-slate-900 rounded border border-slate-700 overflow-hidden"
          style="width: 100%; height: calc(100vh - 450px); min-height: 600px; cursor: grab;"
          onmousedown="handleCanvasMouseDown(event)"
          onmousemove="handleCanvasMouseMove(event)"
          onmouseup="handleCanvasMouseUp(event)"
          onmouseleave="handleCanvasMouseUp(event)"
        >
          <!-- SVG para edges (debajo de nodos) -->
          <svg 
            id="canvas-edges-svg" 
            class="absolute inset-0 pointer-events-none"
            style="z-index: 1;"
          >
          </svg>
          
          <!-- Contenedor de nodos con transform para pan/zoom -->
          <div 
            id="canvas-nodes-container" 
            class="absolute inset-0"
            style="transform: translate(${window.canvasVisualState.panX}px, ${window.canvasVisualState.panY}px) scale(${window.canvasVisualState.zoom}); transform-origin: 0 0;"
          >
    `;
    
    // Renderizar nodos con position absoluta
    for (const node of canvas.nodes || []) {
      const pos = node.position || { x: 0, y: 0 };
      const isSelected = selectedNodeId === node.id;
      
      // Badge de tipo
      let typeBadge = '';
      let nodeColor = 'bg-slate-700';
      if (node.type === 'start') {
        typeBadge = '<span class="px-1.5 py-0.5 bg-green-600 text-white text-xs rounded">START</span>';
        nodeColor = 'bg-green-700';
      } else if (node.type === 'end') {
        typeBadge = '<span class="px-1.5 py-0.5 bg-orange-600 text-white text-xs rounded">END</span>';
        nodeColor = 'bg-orange-700';
      } else if (node.type === 'decision') {
        typeBadge = '<span class="px-1.5 py-0.5 bg-purple-600 text-white text-xs rounded">DECISION</span>';
        nodeColor = 'bg-purple-700';
      }
      
      const borderClass = isSelected 
        ? 'border-2 border-indigo-400 shadow-lg shadow-indigo-500/50' 
        : 'border border-slate-600';
      
      html += `
        <div 
          id="node-${node.id}"
          data-node-id="${node.id}"
          class="absolute ${nodeColor} ${borderClass} rounded-lg p-3 min-w-[120px] cursor-move select-none"
          style="left: ${pos.x}px; top: ${pos.y}px; z-index: 10;"
          onmousedown="handleNodeMouseDown(event, '${node.id}')"
          onclick="handleNodeClick(event, '${node.id}')"
        >
          <div class="flex items-center justify-between gap-2 mb-1">
            <div class="text-white font-semibold text-sm truncate">${node.id}</div>
            ${typeBadge}
          </div>
          <div class="text-slate-300 text-xs">${node.type}</div>
          ${node.label ? `<div class="text-slate-200 text-xs mt-1 truncate">${node.label}</div>` : ''}
        </div>
      `;
    }
    
    html += `
          </div>
        </div>
      </div>
    `;
    
    html += '</div>';
    viewer.innerHTML = html;
    
    // Renderizar edges SVG despu√©s de que el HTML est√© en el DOM
    setTimeout(() => {
      renderCanvasEdges(canvas);
    }, 0);
  }
  
  /**
   * Renderiza edges como l√≠neas SVG (AXE v0.7.0)
   */
  function renderCanvasEdges(canvas) {
    const svg = document.getElementById('canvas-edges-svg');
    if (!svg || !canvas) return;
    
    // Limpiar SVG
    svg.innerHTML = '';
    
    // Obtener dimensiones del contenedor
    const container = document.getElementById('canvas-visual-container');
    if (!container) return;
    
    const containerRect = container.getBoundingClientRect();
    svg.setAttribute('width', containerRect.width);
    svg.setAttribute('height', containerRect.height);
    
    // Agregar defs con marcador de flecha si no existe
    let defs = svg.querySelector('defs');
    if (!defs) {
      defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '10');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3, 0 6');
      polygon.setAttribute('fill', '#64748b');
      
      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.appendChild(defs);
    }
    
    // Renderizar cada edge
    for (const edge of canvas.edges || []) {
      const fromNodeEl = document.getElementById(`node-${edge.from_node_id}`);
      const toNodeEl = document.getElementById(`node-${edge.to_node_id}`);
      
      if (!fromNodeEl || !toNodeEl) {
        // Fallback: usar posiciones del JSON si los elementos no existen
        const fromNode = canvas.nodes?.find(n => n.id === edge.from_node_id);
        const toNode = canvas.nodes?.find(n => n.id === edge.to_node_id);
        if (!fromNode || !toNode) continue;
        
        const fromPos = fromNode.position || { x: 0, y: 0 };
        const toPos = toNode.position || { x: 0, y: 0 };
        
        const panX = window.canvasVisualState?.panX || 0;
        const panY = window.canvasVisualState?.panY || 0;
        const zoom = window.canvasVisualState?.zoom || 1;
        
        const x1 = fromPos.x * zoom + panX + 60;
        const y1 = fromPos.y * zoom + panY + 40;
        const x2 = toPos.x * zoom + panX + 60;
        const y2 = toPos.y * zoom + panY + 40;
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', '#64748b');
        line.setAttribute('stroke-width', '2');
        line.setAttribute('marker-end', 'url(#arrowhead)');
        svg.appendChild(line);
        continue;
      }
      
      // Obtener posiciones reales del DOM (m√°s preciso)
      const fromRect = fromNodeEl.getBoundingClientRect();
      const toRect = toNodeEl.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      
      // Calcular centros de los nodos en coordenadas del contenedor
      const fromCenterX = fromRect.left - containerRect.left + fromRect.width / 2;
      const fromCenterY = fromRect.top - containerRect.top + fromRect.height / 2;
      const toCenterX = toRect.left - containerRect.left + toRect.width / 2;
      const toCenterY = toRect.top - containerRect.top + toRect.height / 2;
      
      // Crear l√≠nea SVG
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', fromCenterX);
      line.setAttribute('y1', fromCenterY);
      line.setAttribute('x2', toCenterX);
      line.setAttribute('y2', toCenterY);
      line.setAttribute('stroke', '#64748b');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('marker-end', 'url(#arrowhead)');
      line.setAttribute('class', 'canvas-edge');
      
      svg.appendChild(line);
    }
  }
  
  /**
   * Maneja el inicio del drag de un nodo (AXE v0.7.0)
   */
  function handleNodeMouseDown(event, nodeId) {
    event.stopPropagation();
    
    if (!window.canvasVisualState) {
      window.canvasVisualState = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    const nodeEl = document.getElementById(`node-${nodeId}`);
    if (!nodeEl) return;
    
    const container = document.getElementById('canvas-visual-container');
    if (!container) return;
    const containerRect = container.getBoundingClientRect();
    
    window.canvasVisualState.isDragging = true;
    window.canvasVisualState.dragNodeId = nodeId;
    window.canvasVisualState.dragStartX = event.clientX;
    window.canvasVisualState.dragStartY = event.clientY;
    
    // Calcular offset desde el mouse hasta la esquina del nodo
    const panX = window.canvasVisualState.panX || 0;
    const panY = window.canvasVisualState.panY || 0;
    const zoom = window.canvasVisualState.zoom || 1;
    
    const nodePos = nodeEl.style.left ? parseInt(nodeEl.style.left) : 0;
    const nodeTop = nodeEl.style.top ? parseInt(nodeEl.style.top) : 0;
    
    window.canvasVisualState.dragOffsetX = (event.clientX - containerRect.left - panX) / zoom - nodePos;
    window.canvasVisualState.dragOffsetY = (event.clientY - containerRect.top - panY) / zoom - nodeTop;
    
    // Cambiar cursor
    container.style.cursor = 'grabbing';
    nodeEl.style.cursor = 'grabbing';
  }
  
  /**
   * Maneja el movimiento del mouse durante drag (AXE v0.7.0) - Mejorado con snapping
   */
  function handleCanvasMouseMove(event) {
    if (!window.canvasVisualState) return;
    
    // Si se est√° arrastrando un nodo
    if (window.canvasVisualState.isDragging && window.canvasVisualState.dragNodeId) {
      const container = document.getElementById('canvas-visual-container');
      if (!container) return;
      const containerRect = container.getBoundingClientRect();
      
      const panX = window.canvasVisualState.panX || 0;
      const panY = window.canvasVisualState.panY || 0;
      const zoom = window.canvasVisualState.zoom || 1;
      
      // Calcular nueva posici√≥n del nodo
      let newX = (event.clientX - containerRect.left - panX) / zoom - window.canvasVisualState.dragOffsetX;
      let newY = (event.clientY - containerRect.top - panY) / zoom - window.canvasVisualState.dragOffsetY;
      
      // Aplicar snapping si est√° habilitado
      newX = applySnapping(newX);
      newY = applySnapping(newY);
      
      // Asegurar que no salga de los l√≠mites
      newX = Math.max(0, newX);
      newY = Math.max(0, newY);
      
      const nodeEl = document.getElementById(`node-${window.canvasVisualState.dragNodeId}`);
      if (nodeEl) {
        nodeEl.style.left = `${newX}px`;
        nodeEl.style.top = `${newY}px`;
        
        // Actualizar edges en tiempo real
        const jsonEditor = document.getElementById('canvas-json-editor');
        if (jsonEditor && jsonEditor.value) {
          try {
            const canvas = JSON.parse(jsonEditor.value);
            renderCanvasEdges(canvas);
          } catch (e) {
            // Ignorar errores de parsing
          }
        }
      }
    }
    // Si se est√° haciendo pan del canvas
    else if (window.canvasVisualState.isPanning) {
      window.canvasVisualState.panX = event.clientX - window.canvasVisualState.panStartX;
      window.canvasVisualState.panY = event.clientY - window.canvasVisualState.panStartY;
      
      const container = document.getElementById('canvas-nodes-container');
      if (container) {
        const panX = window.canvasVisualState.panX || 0;
        const panY = window.canvasVisualState.panY || 0;
        const zoom = window.canvasVisualState.zoom || 1;
        container.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
      }
      
      // Re-renderizar edges
      const jsonEditor = document.getElementById('canvas-json-editor');
      if (jsonEditor && jsonEditor.value) {
        try {
          const canvas = JSON.parse(jsonEditor.value);
          renderCanvasEdges(canvas);
        } catch (e) {
          // Ignorar errores
        }
      }
    }
  }
  
  /**
   * Maneja el fin del drag (AXE v0.7.0)
   */
  function handleCanvasMouseUp(event) {
    if (!window.canvasVisualState) return;
    
    const container = document.getElementById('canvas-visual-container');
    if (container) {
      container.style.cursor = 'grab';
    }
    
    // Si se estaba arrastrando un nodo
    if (window.canvasVisualState.isDragging && window.canvasVisualState.dragNodeId) {
      const nodeEl = document.getElementById(`node-${window.canvasVisualState.dragNodeId}`);
      if (nodeEl) {
        nodeEl.style.cursor = 'move';
      }
      
      // Actualizar posici√≥n en el canvas JSON
      updateNodePositionInCanvas(window.canvasVisualState.dragNodeId);
      
      window.canvasVisualState.isDragging = false;
      window.canvasVisualState.dragNodeId = null;
    }
    
    // Si se estaba haciendo pan
    if (window.canvasVisualState.isPanning) {
      window.canvasVisualState.isPanning = false;
    }
  }
  
  /**
   * Actualiza la posici√≥n de un nodo en el canvas JSON y marca como DIRTY (AXE v0.7.0)
   * Mejorado con autoguardado
   */
  function updateNodePositionInCanvas(nodeId) {
    const nodeEl = document.getElementById(`node-${nodeId}`);
    if (!nodeEl) return;
    
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor || !jsonEditor.value) return;
    
    try {
      const canvas = JSON.parse(jsonEditor.value);
      const node = canvas.nodes?.find(n => n.id === nodeId);
      if (!node) return;
      
      const x = parseInt(nodeEl.style.left) || 0;
      const y = parseInt(nodeEl.style.top) || 0;
      
      // Actualizar posici√≥n
      if (!node.position) {
        node.position = { x: 0, y: 0 };
      }
      node.position.x = x;
      node.position.y = y;
      
      // Actualizar JSON editor
      jsonEditor.value = JSON.stringify(canvas, null, 2);
      
      // Marcar como DIRTY
      canvasViewState.dirty = true;
      actualizarCanvasStateBadge();
      
      // Re-renderizar edges
      renderCanvasEdges(canvas);
      
      // Autoguardado en draft (debounced)
      debouncedAutoSaveCanvas();
      
    } catch (error) {
      console.error('Error actualizando posici√≥n del nodo:', error);
    }
  }
  
  /**
   * Debounce para autoguardado (evita guardar en cada movimiento)
   */
  let autoSaveTimeout = null;
  function debouncedAutoSaveCanvas() {
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
    }
    
    autoSaveTimeout = setTimeout(async () => {
      await autoSaveCanvas();
    }, 2000); // Guardar 2 segundos despu√©s del √∫ltimo cambio
  }
  
  /**
   * Autoguardado del canvas en draft
   * Sincroniza posiciones del DOM al JSON antes de guardar
   */
  async function autoSaveCanvas() {
    if (!editorState.recorridoId) return;
    
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor || !jsonEditor.value) return;
    
    try {
      // Sincronizar todas las posiciones del DOM al JSON antes de guardar
      const canvas = JSON.parse(jsonEditor.value);
      
      // Actualizar posiciones de todos los nodos desde el DOM
      for (const node of canvas.nodes || []) {
        const nodeEl = document.getElementById(`node-${node.id}`);
        if (nodeEl) {
          const x = parseInt(nodeEl.style.left) || 0;
          const y = parseInt(nodeEl.style.top) || 0;
          
          if (!node.position) {
            node.position = { x: 0, y: 0 };
          }
          node.position.x = x;
          node.position.y = y;
        }
      }
      
      // Actualizar JSON editor con posiciones sincronizadas
      jsonEditor.value = JSON.stringify(canvas, null, 2);
      
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas })
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.ok) {
          canvasViewState.canvas = data.canvas_normalized || data.canvas;
          canvasViewState.dirty = false;
          canvasViewState.lastSavedCanvas = JSON.stringify(data.canvas_normalized || data.canvas, null, 2);
          actualizarCanvasStateBadge();
          // Toast silencioso (no interrumpe)
          mostrarToast('üíæ Guardado autom√°tico', 'success', 1500);
        }
      }
    } catch (error) {
      console.error('Error en autoguardado:', error);
      // No mostrar error al usuario para no interrumpir el flujo
    }
  }
  
  /**
   * Maneja clic en nodo (selecci√≥n) (AXE v0.7.0)
   */
  function handleNodeClick(event, nodeId) {
    // Solo seleccionar si no hubo drag
    if (window.canvasVisualState && window.canvasVisualState.isDragging) {
      return;
    }
    
    event.stopPropagation();
    seleccionarNodo(nodeId);
  }
  
  /**
   * Maneja mouse down en el canvas (pan) (AXE v0.7.0)
   */
  function handleCanvasMouseDown(event) {
    // Solo hacer pan si no se est√° arrastrando un nodo
    if (event.target.id && event.target.id.startsWith('node-')) {
      return;
    }
    
    if (!window.canvasVisualState) {
      window.canvasVisualState = { panX: 0, panY: 0, zoom: 1 };
    }
    
    window.canvasVisualState.isPanning = true;
    window.canvasVisualState.panStartX = event.clientX - window.canvasVisualState.panX;
    window.canvasVisualState.panStartY = event.clientY - window.canvasVisualState.panY;
  }
  
  /**
   * Maneja wheel para zoom (AXE v0.7.0) - Mejorado
   * Solo hace zoom si Alt est√° pulsado; sin Alt permite scroll normal del navegador
   */
  function handleCanvasWheel(event) {
    // Sin Alt: permitir scroll normal del navegador (NO interceptar)
    if (!event.altKey) {
      return;
    }
    
    // Con Alt: interceptar y hacer zoom del canvas
    event.preventDefault();
    event.stopPropagation();
    
    if (!window.canvasVisualState) {
      window.canvasVisualState = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    const delta = event.deltaY > 0 ? 0.9 : 1.1;
    window.canvasVisualState.zoom = Math.max(0.3, Math.min(3, window.canvasVisualState.zoom * delta));
    
    // Actualizar display de zoom
    updateZoomDisplay();
    
    // Actualizar transform
    const container = document.getElementById('canvas-nodes-container');
    if (container) {
      const panX = window.canvasVisualState.panX || 0;
      const panY = window.canvasVisualState.panY || 0;
      const zoom = window.canvasVisualState.zoom || 1;
      container.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
    }
    
    // Re-renderizar edges
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (jsonEditor && jsonEditor.value) {
      try {
        const canvas = JSON.parse(jsonEditor.value);
        renderCanvasEdges(canvas);
      } catch (e) {
        // Ignorar errores
      }
    }
  }
  
  /**
   * Actualiza el display del nivel de zoom
   */
  function updateZoomDisplay() {
    const zoomLevel = document.getElementById('zoom-level');
    if (zoomLevel && window.canvasVisualState) {
      const zoom = Math.round((window.canvasVisualState.zoom || 1) * 100);
      zoomLevel.textContent = `${zoom}%`;
    }
  }
  
  /**
   * Toggle snapping de nodos
   */
  function toggleSnapping() {
    if (!window.canvasVisualState) {
      window.canvasVisualState = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    window.canvasVisualState.snappingEnabled = !window.canvasVisualState.snappingEnabled;
    
    const snapBtn = document.getElementById('snap-toggle-btn');
    if (snapBtn) {
      snapBtn.textContent = `üìê Snap: ${window.canvasVisualState.snappingEnabled ? 'ON' : 'OFF'}`;
      snapBtn.classList.toggle('bg-indigo-600', window.canvasVisualState.snappingEnabled);
    }
  }
  
  /**
   * Aplica snapping a una coordenada
   */
  function applySnapping(value) {
    if (!window.canvasVisualState || !window.canvasVisualState.snappingEnabled) {
      return value;
    }
    const grid = window.canvasVisualState.snapGrid || 20;
    return Math.round(value / grid) * grid;
  }
  
  /**
   * Resetear vista del canvas (AXE v0.7.0) - Mejorado
   */
  function resetCanvasView() {
    if (!window.canvasVisualState) {
      window.canvasVisualState = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    window.canvasVisualState.panX = 0;
    window.canvasVisualState.panY = 0;
    window.canvasVisualState.zoom = 1;
    updateZoomDisplay();
    
    const container = document.getElementById('canvas-nodes-container');
    if (container) {
      container.style.transform = 'translate(0px, 0px) scale(1)';
    }
    
    // Re-renderizar edges
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (jsonEditor && jsonEditor.value) {
      try {
        const canvas = JSON.parse(jsonEditor.value);
        renderCanvasEdges(canvas);
      } catch (e) {
        // Ignorar errores
      }
    }
  }
  
  /**
   * Zoom in (AXE v0.7.0) - Mejorado
   */
  function zoomInCanvas() {
    if (!window.canvasVisualState) {
      window.canvasVisualState = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    window.canvasVisualState.zoom = Math.min(3, (window.canvasVisualState.zoom || 1) * 1.2);
    updateZoomDisplay();
    
    const container = document.getElementById('canvas-nodes-container');
    if (container) {
      const panX = window.canvasVisualState.panX || 0;
      const panY = window.canvasVisualState.panY || 0;
      const zoom = window.canvasVisualState.zoom || 1;
      container.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
    }
    
    // Re-renderizar edges
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (jsonEditor && jsonEditor.value) {
      try {
        const canvas = JSON.parse(jsonEditor.value);
        renderCanvasEdges(canvas);
      } catch (e) {
        // Ignorar errores
      }
    }
  }
  
  /**
   * Zoom out (AXE v0.7.0) - Mejorado
   */
  function zoomOutCanvas() {
    if (!window.canvasVisualState) {
      window.canvasVisualState = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    window.canvasVisualState.zoom = Math.max(0.3, (window.canvasVisualState.zoom || 1) * 0.8);
    updateZoomDisplay();
    
    const container = document.getElementById('canvas-nodes-container');
    if (container) {
      const panX = window.canvasVisualState.panX || 0;
      const panY = window.canvasVisualState.panY || 0;
      const zoom = window.canvasVisualState.zoom || 1;
      container.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
    }
    
    // Re-renderizar edges
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (jsonEditor && jsonEditor.value) {
      try {
        const canvas = JSON.parse(jsonEditor.value);
        renderCanvasEdges(canvas);
      } catch (e) {
        // Ignorar errores
      }
    }
  }
  
  /**
   * Selecciona un nodo para mostrar acciones contextuales (AXE v0.6.5)
   */
  function seleccionarNodo(nodeId) {
    if (!window.canvasSelectionState) {
      window.canvasSelectionState = { selectedNodeId: null };
    }
    window.canvasSelectionState.selectedNodeId = nodeId;
    
    // Re-renderizar viewer para mostrar acciones
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (jsonEditor) {
      try {
        const canvas = JSON.parse(jsonEditor.value);
        renderCanvasViewer(canvas);
      } catch (error) {
        console.error('Error parseando canvas:', error);
      }
    }
  }
  
  /**
   * Deselecciona el nodo actual (AXE v0.6.5)
   */
  function deseleccionarNodo() {
    if (window.canvasSelectionState) {
      window.canvasSelectionState.selectedNodeId = null;
    }
    
    // Re-renderizar viewer
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (jsonEditor) {
      try {
        const canvas = JSON.parse(jsonEditor.value);
        renderCanvasViewer(canvas);
      } catch (error) {
        console.error('Error parseando canvas:', error);
      }
    }
  }
  
  /**
   * Guarda meta del nodo seleccionado (AXE v0.6.8)
   */
  function guardarMetaNodo(nodeId) {
    const jsonEditor = document.getElementById('canvas-json-editor');
    const metaEditor = document.getElementById('node-meta-editor');
    
    if (!jsonEditor || !metaEditor) {
      mostrarToast('Error: No se encontraron los editores', 'error');
      return;
    }
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    // Parsear meta del editor
    const metaText = metaEditor.value.trim();
    let meta = null;
    
    if (metaText) {
      try {
        meta = JSON.parse(metaText);
        // Validar que sea un objeto
        if (typeof meta !== 'object' || meta === null || Array.isArray(meta)) {
          mostrarToast('Meta debe ser un objeto JSON v√°lido', 'error');
          return;
        }
      } catch (error) {
        mostrarToast(`Error parseando meta: ${error.message}`, 'error');
        return;
      }
    }
    
    // Buscar y actualizar el nodo
    const node = (canvas.nodes || []).find(n => n.id === nodeId);
    if (!node) {
      mostrarToast(`Nodo '${nodeId}' no encontrado`, 'error');
      return;
    }
    
    // Actualizar meta
    if (meta && Object.keys(meta).length > 0) {
      node.meta = meta;
    } else {
      // Si meta est√° vac√≠o, eliminarlo
      delete node.meta;
    }
    
    // Actualizar JSON editor
    jsonEditor.value = JSON.stringify(canvas, null, 2);
    
    // Re-renderizar viewer
    renderCanvasViewer(canvas);
    
    mostrarToast('Meta guardado correctamente', 'success');
  }
  
  /**
   * Limpia meta del nodo seleccionado (AXE v0.6.8)
   */
  function limpiarMetaNodo(nodeId) {
    const jsonEditor = document.getElementById('canvas-json-editor');
    const metaEditor = document.getElementById('node-meta-editor');
    
    if (!jsonEditor || !metaEditor) {
      mostrarToast('Error: No se encontraron los editores', 'error');
      return;
    }
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    // Buscar y eliminar meta del nodo
    const node = (canvas.nodes || []).find(n => n.id === nodeId);
    if (!node) {
      mostrarToast(`Nodo '${nodeId}' no encontrado`, 'error');
      return;
    }
    
    // Eliminar meta
    delete node.meta;
    
    // Limpiar editor
    metaEditor.value = '';
    
    // Actualizar JSON editor
    jsonEditor.value = JSON.stringify(canvas, null, 2);
    
    // Re-renderizar viewer
    renderCanvasViewer(canvas);
    
    mostrarToast('Meta eliminado correctamente', 'success');
  }
  
  /**
   * Ejecuta una acci√≥n sem√°ntica contextual (simple o macro)
   * AXE v0.6.6 - Soporta macros compuestas
   * 
   * @param {string} action - Nombre de la acci√≥n o macro
   * @param {string} nodeId - ID del nodo sobre el cual ejecutar la acci√≥n
   */
  async function ejecutarAccionSemanticaContextual(action, nodeId) {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    // Determinar si es una macro
    const macros = [
      'insertStandardEnding',
      'createGuidedChoice',
      'createBranchingPath',
      'createLinearSequence'
    ];
    const isMacro = macros.includes(action);
    
    // Preparar par√°metros seg√∫n la acci√≥n
    let params = { nodeId };
    
    // Para macros, los par√°metros van en options
    if (isMacro) {
      params.options = {};
      
      // insertStandardEnding: opciones simples
      if (action === 'insertStandardEnding') {
        const label = prompt('Label del ending (opcional, default: "Finalizaci√≥n"):', '') || undefined;
        const templateId = prompt('Template ID (opcional, default: "ending"):', '') || undefined;
        if (label) params.options.label = label;
        if (templateId) params.options.templateId = templateId;
      }
      
      // createGuidedChoice: opciones m√°s complejas
      else if (action === 'createGuidedChoice') {
        const addEnding = confirm('¬øA√±adir ending despu√©s de cada opci√≥n?');
        params.options.addEnding = addEnding;
        // Por ahora usamos defaults, en el futuro se podr√≠a pedir choices personalizados
      }
      
      // createBranchingPath: opciones de ramificaci√≥n
      else if (action === 'createBranchingPath') {
        const branchCount = parseInt(prompt('N√∫mero de ramas (2-5):', '2') || '2', 10);
        const decisionLabel = prompt('Label de la decisi√≥n (opcional):', '') || undefined;
        if (decisionLabel) params.options.decisionLabel = decisionLabel;
        
        // Crear branches b√°sicas
        params.options.branches = [];
        for (let i = 0; i < Math.min(Math.max(2, branchCount), 5); i++) {
          const branchLabel = prompt(`Label de la rama ${i + 1}:`, `Rama ${i + 1}`) || `Rama ${i + 1}`;
          params.options.branches.push({
            label: branchLabel,
            choiceLabel: branchLabel,
            addEnding: false
          });
        }
      }
      
      // createLinearSequence: opciones de secuencia
      else if (action === 'createLinearSequence') {
        const nodeCount = parseInt(prompt('N√∫mero de nodos en la secuencia (1-5):', '2') || '2', 10);
        const addEnding = confirm('¬øA√±adir ending al final?');
        params.options.addEnding = addEnding;
        
        // Crear nodos b√°sicos
        params.options.nodes = [];
        for (let i = 0; i < Math.min(Math.max(1, nodeCount), 5); i++) {
          const nodeLabel = prompt(`Label del nodo ${i + 1}:`, `Nodo ${i + 1}`) || `Nodo ${i + 1}`;
          params.options.nodes.push({
            label: nodeLabel,
            type: 'screen',
            props: { screen_template_id: 'blank' }
          });
        }
      }
    }
    
    // Para insertNodeAfter, necesitamos datos del nuevo nodo
    else if (action === 'insertNodeAfter') {
      const newNodeId = prompt('ID del nuevo nodo (opcional, se generar√° si est√° vac√≠o):', '') || '';
      const nodeType = prompt('Tipo del nodo (screen, decision, condition, delay):', 'screen') || 'screen';
      const nodeLabel = prompt('Label del nodo (opcional):', '') || '';
      
      params.newNode = {
        id: newNodeId || undefined,
        type: nodeType,
        label: nodeLabel || undefined,
        position: { x: 0, y: 0 },
        props: {}
      };
    }
    
    // Ejecutar acci√≥n usando el helper existente
    const resultCanvas = await ejecutarAccionSemantica(action, params);
    
    if (resultCanvas) {
      // Deseleccionar nodo despu√©s de la acci√≥n
      deseleccionarNodo();
    }
  }
  
  /**
   * Valida el canvas sin guardar
   */
  async function validarCanvas() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/validate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || `Error ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.valid) {
        let message = '‚úÖ Canvas v√°lido';
        if (data.warnings && data.warnings.length > 0) {
          message += ` (${data.warnings.length} advertencia${data.warnings.length > 1 ? 's' : ''})`;
        }
        mostrarToast(message, 'success');
        
        // Mostrar warnings en consola si hay
        if (data.warnings && data.warnings.length > 0) {
          console.log('Advertencias del canvas:', data.warnings);
        }
      } else {
        let message = '‚ùå Canvas inv√°lido';
        if (data.errors && data.errors.length > 0) {
          message += ` (${data.errors.length} error${data.errors.length > 1 ? 'es' : ''})`;
        }
        mostrarToast(message, 'error');
        
        // Mostrar errores en consola
        if (data.errors && data.errors.length > 0) {
          console.error('Errores del canvas:', data.errors);
        }
        if (data.warnings && data.warnings.length > 0) {
          console.warn('Advertencias del canvas:', data.warnings);
        }
      }
      
    } catch (error) {
      console.error('Error validando canvas:', error);
      mostrarToast(`Error validando canvas: ${error.message}`, 'error');
    }
  }
  
  /**
   * Guarda el canvas en el draft
   */
  async function guardarCanvas() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || `Error ${response.status}`);
      }
      
      const data = await response.json();
      
      if (!data.ok) {
        let message = '‚ùå No se puede guardar canvas:\n\n';
        if (data.errors && data.errors.length > 0) {
          message += 'Errores:\n' + data.errors.map(e => `- ${e}`).join('\n');
        }
        if (data.warnings && data.warnings.length > 0) {
          message += '\n\nAdvertencias:\n' + data.warnings.map(w => `- ${w}`).join('\n');
        }
        mostrarToast(message, 'error');
        return;
      }
      
      // Actualizar estado (AXE v0.6.11)
      canvasViewState.canvas = data.canvas_normalized;
      canvasViewState.source = 'persisted';
      canvasViewState.warnings = data.warnings || [];
      canvasViewState.lastSavedCanvas = JSON.stringify(data.canvas_normalized, null, 2);
      canvasViewState.dirty = false;  // Limpiar DIRTY tras guardar
      
      // Actualizar badge de estado
      actualizarCanvasStateBadge();
      
      // Actualizar editor JSON con el canvas normalizado
      const jsonEditor = document.getElementById('canvas-json-editor');
      if (jsonEditor) {
        jsonEditor.value = JSON.stringify(data.canvas_normalized, null, 2);
      }
      
      // Actualizar viewer (preservando selecci√≥n si el nodo a√∫n existe)
      const selectedNodeId = window.canvasSelectionState?.selectedNodeId;
      if (selectedNodeId && !data.canvas_normalized.nodes?.find(n => n.id === selectedNodeId)) {
        if (window.canvasSelectionState) {
          window.canvasSelectionState.selectedNodeId = null;
        }
      }
      renderCanvasViewer(data.canvas_normalized);
      mostrarCanvasWarnings();
      
      // Actualizar diagn√≥stico despu√©s de guardar (AXE v0.6.9)
      actualizarDiagnostico();
      
      // Mostrar toast de √©xito
      mostrarToast('‚úÖ Canvas guardado exitosamente', 'success');
      
      // Recargar canvas para refrescar estado completo
      await cargarCanvas();
      
    } catch (error) {
      console.error('Error guardando canvas:', error);
      alert(`Error guardando canvas: ${error.message}`);
    }
  }
  
  /**
   * Sistema de Toasts - Mejorado con duraci√≥n
   */
  function mostrarToast(mensaje, tipo = 'info', duracion = 5000) {
    const container = document.getElementById('toast-container');
    if (!container) return;
    
    container.style.display = 'block';
    
    const toast = document.createElement('div');
    const bgColor = tipo === 'success' ? 'bg-green-600' : tipo === 'error' ? 'bg-red-600' : 'bg-blue-600';
    toast.className = `${bgColor} text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-2 min-w-[300px] max-w-[500px]`;
    toast.innerHTML = `
      <span>${mensaje}</span>
      <button onclick="this.parentElement.remove()" class="ml-auto text-white hover:text-gray-200">‚úï</button>
    `;
    
    container.appendChild(toast);
    
    // Auto-remover despu√©s de la duraci√≥n especificada
    if (duracion > 0) {
      setTimeout(() => {
        if (toast.parentElement) {
          toast.remove();
        }
        if (container.children.length === 0) {
          container.style.display = 'none';
        }
      }, duracion);
    }
    
    container.appendChild(toast);
    
    // Auto-remover despu√©s de 5 segundos
    setTimeout(() => {
      if (toast.parentElement) {
        toast.remove();
      }
      if (container.children.length === 0) {
        container.style.display = 'none';
      }
    }, 5000);
  }
  
  /**
   * A√±ade un nodo al canvas
   */
  async function a√±adirNodoCanvas() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    if (!canvas.nodes) canvas.nodes = [];
    
    const nodeId = prompt('ID del nodo (ej: node1):');
    if (!nodeId) return;
    
    // Verificar que no exista
    if (canvas.nodes.find(n => n.id === nodeId)) {
      mostrarToast(`El nodo "${nodeId}" ya existe`, 'error');
      return;
    }
    
    const nodeType = prompt('Tipo del nodo (ej: step, start, end):', 'step');
    if (!nodeType) return;
    
    const nodeLabel = prompt('Label del nodo (opcional):', '') || '';
    
    const newNode = {
      id: nodeId,
      type: nodeType,
      label: nodeLabel,
      position: { x: Math.random() * 400, y: Math.random() * 300 },
      props: {}
    };
    
    canvas.nodes.push(newNode);
    
    // Actualizar editor
    jsonEditor.value = JSON.stringify(canvas, null, 2);
    
    // Actualizar viewer
    renderCanvasViewer(canvas);
    
    // Actualizar estado en memoria
    canvasViewState.canvas = canvas;
    
    // Validar canvas (sin bloquear, solo feedback)
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/validate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas })
      });
      
      if (response.ok) {
        const data = await response.json();
        if (!data.valid && data.errors && data.errors.length > 0) {
          mostrarToast(`‚ö†Ô∏è Nodo a√±adido, pero hay ${data.errors.length} error${data.errors.length > 1 ? 'es' : ''} de validaci√≥n`, 'error');
        }
      }
    } catch (error) {
      // Ignorar errores de validaci√≥n en acciones estructurales
    }
    
    mostrarToast(`‚úÖ Nodo "${nodeId}" a√±adido`, 'success');
  }
  
  /**
   * Elimina un nodo del canvas (AXE v0.6.9)
   * 
   * - Usa el nodo seleccionado (o prompt si no hay)
   * - Confirmaci√≥n especial si es START o √∫ltimo END
   * - Si borras START: auto markAsStart sobre otro nodo
   * - Si borras √∫ltimo END: insertar end est√°ndar (macro)
   * - Validar + normalizar despu√©s
   * - Marcar DIRTY
   */
  async function eliminarNodoCanvas(nodeIdParam = null) {
    // Obtener canvas actual (desde estado o JSON editor)
    let canvas = canvasViewState.canvas;
    if (!canvas) {
      const jsonEditor = document.getElementById('canvas-json-editor');
      if (!jsonEditor) {
        mostrarToast('No hay canvas cargado', 'error');
        return;
      }
      try {
        canvas = JSON.parse(jsonEditor.value);
      } catch (error) {
        mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
        return;
      }
    }
    
    if (!canvas.nodes || canvas.nodes.length === 0) {
      mostrarToast('No hay nodos para eliminar', 'error');
      return;
    }
    
    // Determinar qu√© nodo eliminar
    let nodeId = nodeIdParam;
    if (!nodeId) {
      // Usar nodo seleccionado si existe
      nodeId = window.canvasSelectionState?.selectedNodeId;
      if (!nodeId) {
        nodeId = prompt('ID del nodo a eliminar:');
        if (!nodeId) return;
      }
    }
    
    // Buscar el nodo
    const node = canvas.nodes.find(n => n.id === nodeId);
    if (!node) {
      mostrarToast(`Nodo "${nodeId}" no encontrado`, 'error');
      return;
    }
    
    // Verificar si es START o √∫ltimo END
    const isStart = node.type === 'start';
    const endNodes = canvas.nodes.filter(n => n.type === 'end');
    const isLastEnd = endNodes.length === 1 && node.type === 'end';
    
    // Confirmaci√≥n especial para START o √∫ltimo END
    if (isStart) {
      const confirmed = confirm(
        `‚ö†Ô∏è ADVERTENCIA: Est√°s borrando el nodo START.\n\n` +
        `Esto puede romper el flujo. Si contin√∫as, se intentar√° marcar otro nodo como START autom√°ticamente.\n\n` +
        `¬øDeseas continuar?`
      );
      if (!confirmed) return;
    } else if (isLastEnd) {
      const confirmed = confirm(
        `‚ö†Ô∏è ADVERTENCIA: Est√°s borrando el √∫ltimo nodo END.\n\n` +
        `Esto puede romper el flujo. Si contin√∫as, se intentar√° insertar un END est√°ndar autom√°ticamente.\n\n` +
        `¬øDeseas continuar?`
      );
      if (!confirmed) return;
    } else {
      // Confirmaci√≥n normal
      const confirmed = confirm(`¬øEliminar el nodo "${nodeId}"?`);
      if (!confirmed) return;
    }
    
    // Crear copia del canvas para modificar
    const newCanvas = JSON.parse(JSON.stringify(canvas));
    
    // Eliminar nodo
    const nodeIndex = newCanvas.nodes.findIndex(n => n.id === nodeId);
    newCanvas.nodes.splice(nodeIndex, 1);
    
    // Eliminar edges que referencian este nodo
    if (newCanvas.edges) {
      newCanvas.edges = newCanvas.edges.filter(
        e => e.from_node_id !== nodeId && e.to_node_id !== nodeId
      );
    }
    
    // Si era el entry_node_id, necesitamos un nuevo start
    let finalCanvas = newCanvas;
    if (newCanvas.entry_node_id === nodeId) {
      // Buscar otro nodo para marcar como start (preferir uno conectado)
      const connectedNode = newCanvas.nodes.find(n => {
        // Buscar nodo que tenga edges entrantes o salientes (est√° conectado)
        const hasIncoming = newCanvas.edges.some(e => e.to_node_id === n.id);
        const hasOutgoing = newCanvas.edges.some(e => e.from_node_id === n.id);
        return (hasIncoming || hasOutgoing) && n.type !== 'end';
      });
      
      if (connectedNode) {
        // Marcar como start usando acci√≥n sem√°ntica
        try {
          const encodedId = encodeURIComponent(editorState.recorridoId);
          const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/action`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify({
              canvas: newCanvas,
              action: 'markAsStart',
              params: { nodeId: connectedNode.id }
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.ok && data.canvas) {
              finalCanvas = data.canvas;
            }
          }
        } catch (error) {
          console.warn('Error marcando nuevo start, usando fallback:', error);
          // Fallback: usar el primer nodo disponible
          if (finalCanvas.nodes.length > 0) {
            finalCanvas.entry_node_id = finalCanvas.nodes[0].id;
            finalCanvas.nodes[0].type = 'start';
          }
        }
      } else if (finalCanvas.nodes.length > 0) {
        // Fallback: usar el primer nodo
        finalCanvas.entry_node_id = finalCanvas.nodes[0].id;
        finalCanvas.nodes[0].type = 'start';
      }
    }
    
    // Si era el √∫ltimo END, insertar un end est√°ndar
    if (isLastEnd && finalCanvas.nodes.filter(n => n.type === 'end').length === 0) {
      // Encontrar el nodo "leaf" m√°s profundo (sin edges salientes)
      const leafNodes = finalCanvas.nodes.filter(n => {
        if (n.type === 'start' || n.type === 'end') return false;
        const outgoingEdges = finalCanvas.edges.filter(e => e.from_node_id === n.id);
        return outgoingEdges.length === 0;
      });
      
      if (leafNodes.length > 0) {
        // Usar el primer leaf node encontrado
        const targetNode = leafNodes[0];
        
        try {
          const encodedId = encodeURIComponent(editorState.recorridoId);
          const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/action`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify({
              canvas: finalCanvas,
              action: 'insertStandardEnding',
              params: {
                nodeId: targetNode.id,
                options: {}
              }
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.ok && data.canvas) {
              finalCanvas = data.canvas;
            }
          }
        } catch (error) {
          console.warn('Error insertando ending est√°ndar, continuando sin end:', error);
        }
      }
    }
    
    // Actualizar canvas en el estado
    canvasViewState.canvas = finalCanvas;
    canvasViewState.dirty = true;
    
    // Actualizar JSON editor si existe
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (jsonEditor) {
      jsonEditor.value = JSON.stringify(finalCanvas, null, 2);
    }
    
    // Actualizar viewer
    renderCanvasViewer(finalCanvas);
    
    // Deseleccionar nodo si estaba seleccionado
    if (window.canvasSelectionState?.selectedNodeId === nodeId) {
      window.canvasSelectionState.selectedNodeId = null;
      actualizarPanelContextual(finalCanvas);
    }
    
    // Validar canvas (sin bloquear, solo feedback)
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/validate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas: finalCanvas })
      });
      
      if (response.ok) {
        const data = await response.json();
        if (!data.valid && data.errors && data.errors.length > 0) {
          mostrarToast(`‚ö†Ô∏è Nodo eliminado, pero hay ${data.errors.length} error${data.errors.length > 1 ? 'es' : ''} de validaci√≥n`, 'warning');
        } else {
          mostrarToast(`‚úÖ Nodo "${nodeId}" eliminado correctamente`, 'success');
        }
      }
    } catch (error) {
      // Ignorar errores de validaci√≥n, pero mostrar √©xito de todas formas
      mostrarToast(`‚úÖ Nodo "${nodeId}" eliminado`, 'success');
    }
    
    // Actualizar badge de estado DIRTY
    actualizarCanvasStateBadge();
  }
  
  /**
   * Funci√≥n helper para deleteSelectedNode (alias m√°s claro)
   */
  async function deleteSelectedNode() {
    await eliminarNodoCanvas();
  }
  
  /**
   * A√±ade un edge al canvas
   */
  async function a√±adirEdgeCanvas() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    if (!canvas.edges) canvas.edges = [];
    if (!canvas.nodes || canvas.nodes.length === 0) {
      mostrarToast('No hay nodos. A√±ade nodos primero.', 'error');
      return;
    }
    
    const fromNodeId = prompt('ID del nodo origen:');
    if (!fromNodeId) return;
    
    // Verificar que existe
    if (!canvas.nodes.find(n => n.id === fromNodeId)) {
      mostrarToast(`Nodo origen "${fromNodeId}" no existe`, 'error');
      return;
    }
    
    const toNodeId = prompt('ID del nodo destino:');
    if (!toNodeId) return;
    
    // Verificar que existe
    if (!canvas.nodes.find(n => n.id === toNodeId)) {
      mostrarToast(`Nodo destino "${toNodeId}" no existe`, 'error');
      return;
    }
    
    // Verificar que no exista ya
    if (canvas.edges.find(e => e.from_node_id === fromNodeId && e.to_node_id === toNodeId)) {
      mostrarToast(`Edge de "${fromNodeId}" a "${toNodeId}" ya existe`, 'error');
      return;
    }
    
    const edgeType = prompt('Tipo del edge (opcional, ej: default, conditional):', 'default') || 'default';
    const edgeLabel = prompt('Label del edge (opcional):', '') || '';
    
    const newEdge = {
      from_node_id: fromNodeId,
      to_node_id: toNodeId,
      type: edgeType,
      label: edgeLabel || undefined
    };
    
    if (!newEdge.label) delete newEdge.label;
    
    canvas.edges.push(newEdge);
    
    // Actualizar editor
    jsonEditor.value = JSON.stringify(canvas, null, 2);
    
    // Actualizar viewer
    renderCanvasViewer(canvas);
    
    // Actualizar estado en memoria
    canvasViewState.canvas = canvas;
    
    // Validar canvas (sin bloquear, solo feedback)
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/validate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas })
      });
      
      if (response.ok) {
        const data = await response.json();
        if (!data.valid && data.errors && data.errors.length > 0) {
          mostrarToast(`‚ö†Ô∏è Edge a√±adido, pero hay ${data.errors.length} error${data.errors.length > 1 ? 'es' : ''} de validaci√≥n`, 'error');
        }
      }
    } catch (error) {
      // Ignorar errores de validaci√≥n en acciones estructurales
    }
    
    mostrarToast(`‚úÖ Edge de "${fromNodeId}" a "${toNodeId}" a√±adido`, 'success');
  }
  
  /**
   * Elimina un edge del canvas
   */
  async function eliminarEdgeCanvas() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    if (!canvas.edges || canvas.edges.length === 0) {
      mostrarToast('No hay edges para eliminar', 'error');
      return;
    }
    
    const fromNodeId = prompt('ID del nodo origen:');
    if (!fromNodeId) return;
    
    const toNodeId = prompt('ID del nodo destino:');
    if (!toNodeId) return;
    
    const edgeIndex = canvas.edges.findIndex(
      e => e.from_node_id === fromNodeId && e.to_node_id === toNodeId
    );
    
    if (edgeIndex === -1) {
      mostrarToast(`Edge de "${fromNodeId}" a "${toNodeId}" no encontrado`, 'error');
      return;
    }
    
    // Eliminar edge
    canvas.edges.splice(edgeIndex, 1);
    
    // Actualizar editor
    jsonEditor.value = JSON.stringify(canvas, null, 2);
    
    // Actualizar viewer
    renderCanvasViewer(canvas);
    
    // Actualizar estado en memoria
    canvasViewState.canvas = canvas;
    
    // Validar canvas (sin bloquear, solo feedback)
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/validate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas })
      });
      
      if (response.ok) {
        const data = await response.json();
        if (!data.valid && data.errors && data.errors.length > 0) {
          mostrarToast(`‚ö†Ô∏è Edge eliminado, pero hay ${data.errors.length} error${data.errors.length > 1 ? 'es' : ''} de validaci√≥n`, 'error');
        }
      }
    } catch (error) {
      // Ignorar errores de validaci√≥n en acciones estructurales
    }
    
    mostrarToast(`‚úÖ Edge de "${fromNodeId}" a "${toNodeId}" eliminado`, 'success');
  }
  
  /**
   * Ejecuta una acci√≥n sem√°ntica sobre el canvas (AXE v0.6.4)
   * Helper gen√©rico que llama al endpoint de acciones
   */
  async function ejecutarAccionSemantica(action, params) {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return null;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return null;
    }
    
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/action`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas, action, params })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || `Error ${response.status}`);
      }
      
      const data = await response.json();
      
      if (!data.ok) {
        let message = '‚ùå Error ejecutando acci√≥n:\n\n';
        if (data.errors && data.errors.length > 0) {
          message += 'Errores:\n' + data.errors.map(e => `- ${e}`).join('\n');
        }
        mostrarToast(message, 'error');
        return null;
      }
      
      // Actualizar editor con el canvas resultante
      jsonEditor.value = JSON.stringify(data.canvas, null, 2);
      
      // Actualizar viewer (preservando selecci√≥n si el nodo a√∫n existe)
      const selectedNodeId = window.canvasSelectionState?.selectedNodeId;
      if (selectedNodeId && !data.canvas.nodes?.find(n => n.id === selectedNodeId)) {
        // Si el nodo seleccionado ya no existe, deseleccionar
        if (window.canvasSelectionState) {
          window.canvasSelectionState.selectedNodeId = null;
        }
      }
      renderCanvasViewer(data.canvas);
      
      // Actualizar estado en memoria
      canvasViewState.canvas = data.canvas;
      
      // Mostrar warnings si hay
      if (data.warnings && data.warnings.length > 0) {
        console.warn('Advertencias:', data.warnings);
        mostrarToast(`‚úÖ Acci√≥n ejecutada (${data.warnings.length} advertencia${data.warnings.length > 1 ? 's' : ''})`, 'success');
      } else {
        mostrarToast('‚úÖ Acci√≥n ejecutada correctamente', 'success');
      }
      
      return data.canvas;
    } catch (error) {
      console.error('Error ejecutando acci√≥n sem√°ntica:', error);
      mostrarToast(`Error ejecutando acci√≥n: ${error.message}`, 'error');
      return null;
    }
  }
  
  /**
   * Inserta un nodo despu√©s de otro (AXE v0.6.4)
   */
  async function insertNodeAfterAction() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    if (!canvas.nodes || canvas.nodes.length === 0) {
      mostrarToast('No hay nodos en el canvas', 'error');
      return;
    }
    
    const nodeId = prompt('ID del nodo despu√©s del cual insertar:');
    if (!nodeId) return;
    
    // Verificar que existe
    if (!canvas.nodes.find(n => n.id === nodeId)) {
      mostrarToast(`Nodo "${nodeId}" no existe`, 'error');
      return;
    }
    
    // Solicitar datos del nuevo nodo
    const newNodeId = prompt('ID del nuevo nodo (opcional, se generar√° si est√° vac√≠o):', '') || '';
    const nodeType = prompt('Tipo del nodo (screen, decision, condition, delay):', 'screen') || 'screen';
    const nodeLabel = prompt('Label del nodo (opcional):', '') || '';
    
    const newNode = {
      id: newNodeId || undefined, // Se generar√° en el backend si est√° vac√≠o
      type: nodeType,
      label: nodeLabel || undefined,
      position: { x: 0, y: 0 }, // Se ajustar√° en el backend
      props: {}
    };
    
    await ejecutarAccionSemantica('insertNodeAfter', {
      nodeId,
      newNode
    });
  }
  
  /**
   * Convierte un nodo a decisi√≥n (AXE v0.6.4)
   */
  async function convertToDecisionAction() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    if (!canvas.nodes || canvas.nodes.length === 0) {
      mostrarToast('No hay nodos en el canvas', 'error');
      return;
    }
    
    const nodeId = prompt('ID del nodo a convertir a decisi√≥n:');
    if (!nodeId) return;
    
    // Verificar que existe
    if (!canvas.nodes.find(n => n.id === nodeId)) {
      mostrarToast(`Nodo "${nodeId}" no existe`, 'error');
      return;
    }
    
    await ejecutarAccionSemantica('convertNodeToDecision', {
      nodeId
    });
  }
  
  /**
   * Marca un nodo como start (AXE v0.6.4)
   */
  async function markAsStartAction() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    if (!canvas.nodes || canvas.nodes.length === 0) {
      mostrarToast('No hay nodos en el canvas', 'error');
      return;
    }
    
    const nodeId = prompt('ID del nodo a marcar como inicio:');
    if (!nodeId) return;
    
    // Verificar que existe
    if (!canvas.nodes.find(n => n.id === nodeId)) {
      mostrarToast(`Nodo "${nodeId}" no existe`, 'error');
      return;
    }
    
    await ejecutarAccionSemantica('markAsStart', {
      nodeId
    });
  }
  
  /**
   * Marca un nodo como end (AXE v0.6.4)
   */
  async function markAsEndAction() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    if (!canvas.nodes || canvas.nodes.length === 0) {
      mostrarToast('No hay nodos en el canvas', 'error');
      return;
    }
    
    const nodeId = prompt('ID del nodo a marcar como fin:');
    if (!nodeId) return;
    
    // Verificar que existe
    if (!canvas.nodes.find(n => n.id === nodeId)) {
      mostrarToast(`Nodo "${nodeId}" no existe`, 'error');
      return;
    }
    
    await ejecutarAccionSemantica('markAsEnd', {
      nodeId
    });
  }
  
  /**
   * Duplica un subgrafo completo (AXE v0.6.4)
   */
  async function duplicateSubgraphAction() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    if (!canvas.nodes || canvas.nodes.length === 0) {
      mostrarToast('No hay nodos en el canvas', 'error');
      return;
    }
    
    const nodeId = prompt('ID del nodo ra√≠z del subgrafo a duplicar:');
    if (!nodeId) return;
    
    // Verificar que existe
    if (!canvas.nodes.find(n => n.id === nodeId)) {
      mostrarToast(`Nodo "${nodeId}" no existe`, 'error');
      return;
    }
    
    await ejecutarAccionSemantica('duplicateSubgraph', {
      nodeId
    });
  }
  
  /**
   * Convierte canvas a recorrido (preview, no persiste)
   */
  async function convertirCanvasARecorrido() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    let canvas;
    try {
      canvas = JSON.parse(jsonEditor.value);
    } catch (error) {
      mostrarToast(`Error parseando JSON: ${error.message}`, 'error');
      return;
    }
    
    try {
      const encodedId = encodeURIComponent(editorState.recorridoId);
      const response = await fetch(`/admin/api/recorridos/${encodedId}/canvas/convert-to-recorrido`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ canvas })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || `Error ${response.status}`);
      }
      
      const data = await response.json();
      
      // Mostrar resultado
      const resultEl = document.getElementById('canvas-conversion-result');
      if (resultEl) {
        resultEl.style.display = 'block';
        resultEl.innerHTML = `
          <h4 class="text-white font-semibold mb-2">Recorrido Convertido (Preview)</h4>
          <pre class="bg-slate-900 text-slate-100 p-4 rounded text-xs overflow-auto max-h-96">${JSON.stringify(data.recorrido_definition, null, 2)}</pre>
          ${data.warnings && data.warnings.length > 0 ? `
            <div class="mt-2 text-yellow-200 text-sm">
              <strong>Advertencias:</strong>
              <ul class="list-disc list-inside mt-1">
                ${data.warnings.map(w => `<li>${w}</li>`).join('')}
              </ul>
            </div>
          ` : ''}
        `;
      }
      
    } catch (error) {
      console.error('Error convirtiendo canvas:', error);
      mostrarToast(`Error convirtiendo canvas: ${error.message}`, 'error');
    }
  }

  /**
   * Actualiza el badge de estado del canvas (AXE v0.6.11)
   * Estados: DERIVED, PERSISTED, DIRTY
   */
  function actualizarCanvasStateBadge() {
    const stateBadge = document.getElementById('canvas-state-badge');
    if (!stateBadge) return;
    
    // Detectar cambios en el editor JSON
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (jsonEditor && jsonEditor.value) {
      try {
        const currentCanvas = JSON.stringify(JSON.parse(jsonEditor.value), null, 2);
        if (canvasViewState.lastSavedCanvas && currentCanvas !== canvasViewState.lastSavedCanvas) {
          canvasViewState.dirty = true;
        }
      } catch (e) {
        // JSON inv√°lido, no actualizar estado
      }
    }
    
    // Determinar estado a mostrar
    let state, label, className, title;
    
    if (canvasViewState.dirty) {
      state = 'DIRTY';
      label = 'DIRTY';
      className = 'px-2 py-1 bg-orange-900 text-orange-200 rounded text-xs font-semibold';
      title = 'Hay cambios sin guardar en el canvas';
    } else if (canvasViewState.source === 'persisted') {
      state = 'PERSISTED';
      label = 'PERSISTED';
      className = 'px-2 py-1 bg-green-900 text-green-200 rounded text-xs font-semibold';
      title = 'Canvas guardado en draft';
    } else if (canvasViewState.source === 'derived') {
      state = 'DERIVED';
      label = 'DERIVED';
      className = 'px-2 py-1 bg-yellow-900 text-yellow-200 rounded text-xs font-semibold';
      title = 'Canvas derivado desde definition_json (no persistido)';
    } else {
      stateBadge.style.display = 'none';
      return;
    }
    
    stateBadge.style.display = 'inline-block';
    stateBadge.textContent = label;
    stateBadge.className = className;
    stateBadge.title = title;
  }
  
  /**
   * Detecta cambios en el editor JSON del canvas (AXE v0.6.11)
   */
  function detectarCambiosCanvas() {
    const jsonEditor = document.getElementById('canvas-json-editor');
    if (!jsonEditor) return;
    
    try {
      const currentCanvas = JSON.stringify(JSON.parse(jsonEditor.value), null, 2);
      if (canvasViewState.lastSavedCanvas && currentCanvas !== canvasViewState.lastSavedCanvas) {
        canvasViewState.dirty = true;
        actualizarCanvasStateBadge();
      } else if (canvasViewState.lastSavedCanvas && currentCanvas === canvasViewState.lastSavedCanvas) {
        canvasViewState.dirty = false;
        actualizarCanvasStateBadge();
      }
    } catch (e) {
      // JSON inv√°lido, no actualizar
    }
  }
  
  /**
   * Flujo AXE: Editar (AXE v0.6.11)
   * Activa el modo de edici√≥n (ya est√° activo por defecto en Canvas)
   */
  function editarRecorrido() {
    // Asegurar que estamos en vista Canvas
    if (!canvasViewState.active) {
      toggleVistaCanvas();
    }
    mostrarToast('Modo edici√≥n activo', 'info');
  }
  
  /**
   * Flujo AXE: Guardar (AXE v0.6.11)
   * Guarda el canvas actual
   */
  async function guardarRecorrido() {
    await guardarCanvas();
    // El estado DIRTY se limpia autom√°ticamente en guardarCanvas
  }
  
  /**
   * Flujo AXE: Publicar (AXE v0.6.11)
   * Reutiliza la funci√≥n existente publicarRecorrido
   */
  // La funci√≥n publicarRecorrido ya existe, no necesitamos crear una nueva
  
  /**
   * Maneja shortcuts de teclado en el editor (AXE v0.6.9)
   * - Delete/Backspace: Eliminar nodo seleccionado
   */
  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (event) => {
      // Solo procesar si no estamos escribiendo en un input/textarea
      const activeElement = document.activeElement;
      const isInputFocused = activeElement && (
        activeElement.tagName === 'INPUT' ||
        activeElement.tagName === 'TEXTAREA' ||
        activeElement.isContentEditable
      );
      
      if (isInputFocused) {
        return; // No procesar shortcuts si estamos escribiendo
      }
      
      // Delete o Backspace: Eliminar nodo seleccionado
      if ((event.key === 'Delete' || event.key === 'Backspace') && window.canvasSelectionState?.selectedNodeId) {
        event.preventDefault();
        deleteSelectedNode();
      }
    });
  }
  
  // Inicializar al cargar
  document.addEventListener('DOMContentLoaded', () => {
    // Configurar shortcuts de teclado
    setupKeyboardShortcuts();
    
    // AXE v0.6.9: Cargar tema de preview desde localStorage
    const temaGuardado = getTemaPreviewSeleccionado();
    const themeSelector = document.getElementById('theme-selector');
    if (themeSelector) {
      themeSelector.value = temaGuardado;
    }
    
    const editor = document.getElementById('recorridos-editor');
    if (!editor) {
      console.error('[Editor] DOMContentLoaded: ERROR - Elemento #recorridos-editor no encontrado');
      // Fail-open: mostrar mensaje visible
      const body = document.body;
      if (body) {
        body.innerHTML = `
          <div style="padding: 40px; background: #1e293b; color: #fca5a5; font-family: sans-serif;">
            <h1 style="color: #ef4444; margin-bottom: 20px;">‚ö†Ô∏è Error cargando editor de recorridos</h1>
            <p>No se pudo encontrar el contenedor del editor. Por favor, recarga la p√°gina.</p>
            <p style="margin-top: 20px; font-size: 0.9em; color: #94a3b8;">Si el problema persiste, verifica la consola del navegador para m√°s detalles.</p>
          </div>
        `;
      }
      return;
    }
    console.log('[Editor] DOMContentLoaded: calling initEditor()');
    initEditor().catch(err => {
      console.error('[Editor] DOMContentLoaded: ERROR in initEditor():', err);
      // Fail-open: mostrar mensaje visible
      const stepsListEl = document.getElementById('steps-list');
      if (stepsListEl) {
        stepsListEl.innerHTML = `<p class="text-red-400 text-sm">‚ö†Ô∏è Error inicializando editor: ${err.message}</p>`;
      }
    });
    initPanelResizer();
    initRightPanelResizer();
    initPreviewHarness();
    
    // AXE v0.6.11: Cargar canvas autom√°ticamente si estamos en vista Canvas (por defecto)
    if (canvasViewState.active) {
      cargarCanvas().catch(err => {
        console.error('[Editor] Error cargando canvas inicial:', err);
      });
    }
    
    // AXE v0.6.11: Detectar cambios peri√≥dicamente en el editor JSON
    setInterval(() => {
      if (canvasViewState.active) {
        detectarCambiosCanvas();
      }
    }, 1000);  // Verificar cada segundo
    
    // Inicializar zoom display
    updateZoomDisplay();
    
    // Configurar wheel listener para zoom (solo con Alt)
    const canvasContainer = document.getElementById('canvas-visual-container');
    if (canvasContainer) {
      // Usar { passive: false } para poder llamar preventDefault cuando Alt est√© pulsado
      canvasContainer.addEventListener('wheel', handleCanvasWheel, { passive: false });
    }
    
    // Listener para cambios de pantalla completa
    document.addEventListener('fullscreenchange', () => {
      const fullscreenBtn = document.querySelector('[onclick="toggleFullscreenCanvas()"]');
      if (fullscreenBtn) {
        if (document.fullscreenElement) {
          fullscreenBtn.textContent = '‚õ∂ Salir Pantalla Completa';
        } else {
          fullscreenBtn.textContent = '‚õ∂ Pantalla Completa';
        }
      }
    });
    
    // Tambi√©n para webkit y ms
    document.addEventListener('webkitfullscreenchange', () => {
      const fullscreenBtn = document.querySelector('[onclick="toggleFullscreenCanvas()"]');
      if (fullscreenBtn) {
        if (document.webkitFullscreenElement) {
          fullscreenBtn.textContent = '‚õ∂ Salir Pantalla Completa';
        } else {
          fullscreenBtn.textContent = '‚õ∂ Pantalla Completa';
        }
      }
    });
    
    // ============================================================================
    // PREVIEW PANEL CON IFRAME (AXE v5.16.0)
    // ============================================================================
    
    let previewPanelOpen = false;
    let previewIframe = null;
    let currentThemeKey = 'auto';
    let currentThemeCatalog = [];
    
    /**
     * Toggle del panel preview
     */
    window.togglePreviewPanel = function() {
      const container = document.getElementById('preview-panel-container');
      if (!container) return;
      
      previewPanelOpen = !previewPanelOpen;
      container.style.display = previewPanelOpen ? 'block' : 'none';
      
      if (previewPanelOpen) {
        previewIframe = document.getElementById('preview-iframe');
        if (previewIframe) {
          // Esperar a que el iframe cargue y luego enviar snapshot
          previewIframe.onload = () => {
            setTimeout(() => {
              updatePreviewSnapshot();
            }, 500);
          };
        }
      }
    };
    
    /**
     * Actualiza el snapshot del preview
     */
    async function updatePreviewSnapshot() {
      if (!previewIframe || !previewPanelOpen) return;
      
      try {
        // Obtener snapshot del recorrido actual
        const snapshot = buildRecorridoSnapshot();
        
        // Obtener CSS tokens del tema seleccionado
        const themeTokensCssText = await getThemeTokensCssText(currentThemeKey);
        
        // Enviar mensaje al iframe
        previewIframe.contentWindow.postMessage({
          type: 'RECORRIDO_PREVIEW_UPDATE',
          payload: {
            theme: {
              key: currentThemeKey,
              label: currentThemeCatalog.find(t => t.key === currentThemeKey)?.label || currentThemeKey
            },
            themeTokensCssText,
            snapshot
          }
        }, '*');
        
      } catch (error) {
        console.error('[Editor] Error actualizando preview snapshot:', error);
      }
    }
    
    /**
     * Construye snapshot del recorrido para el preview
     * AXE v5.16.0: Incluye contextMock para preview de steps que lo requieren
     */
    function buildRecorridoSnapshot() {
      try {
        const recorrido = editorState.recorrido || {};
        const flow = recorrido.flow || {};
        const steps = flow.steps || {};
        const selectedStepId = editorState.selectedStepId;
        
        // Obtener step seleccionado
        let selectedStep = null;
        if (selectedStepId) {
          if (Array.isArray(steps)) {
            selectedStep = steps.find(s => s.id === selectedStepId || s.step_id === selectedStepId);
          } else if (typeof steps === 'object') {
            selectedStep = steps[selectedStepId] || steps[selectedStepId.toString()];
          }
        }
        
        // Generar contextMock seg√∫n el tipo de step
        const contextMock = generateContextMock(selectedStep);
        
        return {
          recorrido: {
            id: recorrido.id || editorState.recorridoId,
            name: recorrido.name || 'Recorrido sin nombre',
            version: recorrido.version || 'draft',
            status: recorrido.status || 'draft'
          },
          selected_step_id: selectedStepId,
          steps: steps,
          entry_step_id: flow.entry_step_id,
          contextMock: contextMock
        };
      } catch (error) {
        console.error('[Editor] Error construyendo snapshot:', error);
        return {
          recorrido: { id: null, name: 'Error', version: 'draft', status: 'draft' },
          selected_step_id: null,
          steps: {},
          entry_step_id: null,
          contextMock: {}
        };
      }
    }
    
    /**
     * Genera contextMock para el preview seg√∫n el tipo de step
     * AXE v5.16.0: Preparado para motor_post_limpieza_seleccion
     * 
     * @param {Object} step - Step seleccionado
     * @returns {Object} contextMock con preparations y limits
     */
    function generateContextMock(step) {
      if (!step) return {};
      
      const stepType = step.type || step.screen_template_id;
      
      // Si es screen_checklist_preparacion, generar mock de preparations
      if (stepType === 'screen_checklist_preparacion') {
        // Mock de preparations (el motor real generar√° estas desde la BD)
        const mockPreparations = [
          {
            id: 'prep-1',
            title: 'Preparaci√≥n de espacio',
            description: 'Prepara tu espacio f√≠sico para la pr√°ctica',
            mandatory: true,
            estimated_minutes: 5
          },
          {
            id: 'prep-2',
            title: 'Respiraci√≥n consciente',
            description: 'Realiza 3 respiraciones profundas',
            mandatory: false,
            estimated_minutes: 2
          },
          {
            id: 'prep-3',
            title: 'Intenci√≥n clara',
            description: 'Define tu intenci√≥n para esta pr√°ctica',
            mandatory: false,
            estimated_minutes: 3
          },
          {
            id: 'prep-4',
            title: 'Protecci√≥n energ√©tica',
            description: 'Visualiza una burbuja de luz protectora',
            mandatory: true,
            estimated_minutes: 2
          }
        ];
        
        // Mock de limits (el motor real determinar√° estos valores)
        const mockLimits = {
          min: 2,  // M√≠nimo 2 preparaciones (las obligatorias)
          max: 4   // M√°ximo todas las disponibles
        };
        
        return {
          preparations: mockPreparations,
          limits: mockLimits
        };
      }
      
      // Para otros tipos de steps, retornar objeto vac√≠o
      return {};
    }
    
    /**
     * Obtiene CSS tokens del tema
     */
    async function getThemeTokensCssText(themeKey) {
      try {
        // Si es auto/light-classic/dark-classic, usar Theme Resolver
        if (themeKey === 'auto' || themeKey === 'light-classic' || themeKey === 'dark-classic') {
          // Para temas del sistema, generar CSS directamente
          const { resolveTheme } = await import('/src/core/theme/theme-resolver.js');
          const { themeTokensToCss } = await import('/src/core/theme/theme-tokens-to-css.js');
          const themeEffective = resolveTheme({ theme_id: themeKey === 'auto' ? null : themeKey });
          return themeTokensToCss(themeEffective);
        }
        
        // Si es theme:<theme_key>:<version>, cargar desde themes-v3
        if (themeKey.startsWith('theme:')) {
          const parts = themeKey.split(':');
          if (parts.length >= 3) {
            const themeId = parts[1];
            const version = parseInt(parts[2]);
            
            // Cargar versi√≥n desde API
            const response = await fetch(`/admin/api/themes-v3/${themeId}/versions/${version}`);
            if (response.ok) {
              const data = await response.json();
              if (data.ok && data.version && data.version.definition_json) {
                const { getThemeDefinitionCssText } = await import('/src/core/theme/theme-tokens-to-css.js');
                return getThemeDefinitionCssText(data.version.definition_json);
              }
            }
          }
        }
        
        // Fallback: usar dark-classic
        const { resolveTheme } = await import('/src/core/theme/theme-resolver.js');
        const { themeTokensToCss } = await import('/src/core/theme/theme-tokens-to-css.js');
        const themeEffective = resolveTheme({ theme_id: 'dark-classic' });
        return themeTokensToCss(themeEffective);
        
      } catch (error) {
        console.error('[Editor] Error obteniendo theme tokens:', error);
        // Fallback absoluto
        return ':root { --bg-main: #1e293b; --text-primary: #f1f5f9; }';
      }
    }
    
    /**
     * Cambia el tema de preview (modificado para v5.16.0)
     */
    window.cambiarTemaPreview = async function(themeKey) {
      currentThemeKey = themeKey;
      localStorage.setItem('ap_recorridos_editor_theme_pref', themeKey);
      
      // Actualizar preview si est√° abierto
      if (previewPanelOpen) {
        await updatePreviewSnapshot();
      }
    };
    
    /**
     * Inicializa el selector de temas con cat√°logo
     */
    async function initThemeSelector() {
      try {
        // Cargar cat√°logo directamente (sin import din√°mico por compatibilidad)
        const response = await fetch('/admin/api/themes/catalog');
        if (response.ok) {
          const data = await response.json();
          if (data.ok && Array.isArray(data.items)) {
            currentThemeCatalog = data.items;
            
            // Actualizar select con opciones del cat√°logo
            const select = document.getElementById('theme-selector');
            if (select) {
              // Limpiar opciones existentes (excepto la primera si existe)
              const currentValue = select.value;
              select.innerHTML = '';
              
              for (const item of data.items) {
                const option = document.createElement('option');
                option.value = item.key;
                option.textContent = item.label;
                select.appendChild(option);
              }
              
              // Restaurar valor guardado
              const savedPref = localStorage.getItem('ap_recorridos_editor_theme_pref');
              if (savedPref && Array.from(select.options).find(opt => opt.value === savedPref)) {
                select.value = savedPref;
                currentThemeKey = savedPref;
              } else if (currentValue && Array.from(select.options).find(opt => opt.value === currentValue)) {
                select.value = currentValue;
                currentThemeKey = currentValue;
              }
            }
          }
        }
      } catch (error) {
        console.error('[Editor] Error inicializando theme selector:', error);
        // Fail-open: mantener selector b√°sico
      }
    }
    
    // Inicializar theme selector cuando el DOM est√© listo
    setTimeout(initThemeSelector, 2000);
    
    // Actualizar preview cuando cambia el step seleccionado (hook en selectStep si existe)
    if (typeof window.selectStep === 'function') {
      const originalSelectStep = window.selectStep;
      window.selectStep = async function(...args) {
        const result = await originalSelectStep.apply(this, args);
        if (previewPanelOpen) {
          setTimeout(updatePreviewSnapshot, 300);
        }
        return result;
      };
    }
    
    // Hook en renderPreview para actualizar preview panel
    if (typeof window.renderPreview === 'function') {
      const originalRenderPreview = window.renderPreview;
      window.renderPreview = async function(...args) {
        const result = await originalRenderPreview.apply(this, args);
        if (previewPanelOpen) {
          setTimeout(updatePreviewSnapshot, 300);
        }
        return result;
      };
    }
  });
</script>

