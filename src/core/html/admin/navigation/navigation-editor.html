<!-- 
  EDITOR DE NAVEGACIONES - Layout Can√≥nico v2
  ESTRUCTURA:
  - .editor-layout: Contenedor flex column que ocupa todo el espacio disponible
  - .editor-topbar: Header del editor (position: relative, NO fixed)
  - .editor-body: Contenido principal (flex: 1, overflow: auto) con 3 columnas
-->
<div class="navigation-editor editor-layout" id="navigation-editor" data-navigation-id="{{NAVIGATION_ID}}">
  <!-- Header del editor (NO fixed, forma parte del layout) -->
  <div class="editor-topbar bg-slate-800 border-b border-slate-700 px-6 py-4">
    <div class="flex justify-between items-center">
      <div class="flex items-center gap-4">
        <a href="/admin/navigation" class="text-slate-400 hover:text-white" title="Volver al listado">‚Üê</a>
        <select id="navigation-selector" onchange="cambiarNavegacion()" class="px-3 py-1 bg-slate-700 text-white rounded text-sm" style="display: none;">
          <option>Cargando...</option>
        </select>
        <h1 class="text-xl font-bold text-white" id="navigation-name">Cargando...</h1>
        <!-- FASE 4.1: Selector de tipo de navegaci√≥n -->
        <select id="navigation-type" onchange="actualizarTipoNavegacion(this.value)" class="px-3 py-1 bg-slate-700 text-white rounded text-sm border border-slate-600" title="Tipo de navegaci√≥n">
          <option value="global">üåê Global</option>
          <option value="contextual">üéØ Contextual</option>
        </select>
        <!-- FASE 4.1: Input context_key (solo si contextual) -->
        <input 
          type="text" 
          id="navigation-context-key" 
          onchange="actualizarContextKey(this.value)" 
          placeholder="context_key (ej: producto:pde)"
          class="px-3 py-1 bg-slate-700 text-white rounded text-sm border border-slate-600" 
          style="display: none; width: 200px;"
          title="Clave de contexto (obligatorio para navegaci√≥n contextual)"
        >
        <span id="publish-status-badge" class="publish-status publish-status--draft" style="display: none;"></span>
        <span id="navigation-status" class="px-2 py-1 bg-yellow-900 text-yellow-200 rounded text-xs">Cargando...</span>
        <span id="dirty-badge" class="px-2 py-1 bg-orange-900 text-orange-200 rounded text-xs font-semibold" style="display: none;">‚óè Cambios sin guardar</span>
        <span id="navigation-version" class="px-2 py-1 bg-slate-600 text-slate-200 rounded text-xs">v-</span>
        <span id="navigation-published-info" class="px-2 py-1 bg-green-900 text-green-200 rounded text-xs" style="display: none;"></span>
      </div>
      <div class="flex items-center gap-2">
        <button onclick="guardarNavegacion()" class="px-4 py-2 bg-slate-600 hover:bg-slate-500 text-white font-medium rounded transition-colors" title="Guardar draft">
          üíæ Guardar
        </button>
        <button onclick="validarNavegacion()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded transition-colors">
          ‚úì Validar
        </button>
        <button onclick="exportarNavegacion()" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white font-medium rounded transition-colors">
          üì§ Exportar
        </button>
        <button onclick="publicarNavegacion()" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-medium rounded transition-colors">
          üöÄ Publicar
        </button>
      </div>
    </div>
    <div id="validation-messages" class="mt-2"></div>
  </div>
  
  <!-- Contenido principal del editor (flex: 1, scroll interno) -->
  <div class="editor-body flex flex-col">
    <!-- Tabs para cambiar vista -->
    <div class="bg-slate-800 border-b border-slate-700 px-6 py-2 flex gap-2">
      <button onclick="setNavigationView('mapa')" id="tab-mapa" class="tab-button active px-4 py-2 text-sm font-medium rounded-t transition-colors">
        üó∫Ô∏è Mapa
      </button>
      <button onclick="setNavigationView('arbol')" id="tab-arbol" class="tab-button px-4 py-2 text-sm font-medium rounded-t transition-colors">
        üå≥ √Årbol
      </button>
      <button onclick="setNavigationView('json')" id="tab-json" class="tab-button px-4 py-2 text-sm font-medium rounded-t transition-colors">
        üìÑ JSON
      </button>
      <button onclick="setNavigationView('preview')" id="tab-preview" class="tab-button px-4 py-2 text-sm font-medium rounded-t transition-colors">
        üëÅÔ∏è Preview Efectivo
      </button>
    </div>
    
    <!-- Contenedor de vistas -->
    <div class="flex-1 flex overflow-hidden">
      <!-- Vista MAPA (default) - CON MOTOR VISUAL AXE -->
      <div id="vista-mapa" class="vista-container flex-1 flex">
        <!-- Columna izquierda: Canvas visual (MOTOR AXE) -->
        <div class="flex-1 bg-slate-900 p-6" style="display: flex; flex-direction: column; min-width: 0;">
          <div class="bg-slate-800 rounded-lg p-4 mb-4">
            <div class="flex justify-between items-center mb-2">
              <h4 class="text-white font-semibold">Editor Visual (Motor AXE)</h4>
              <div class="flex gap-2">
                <button onclick="toggleSnappingNav()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" id="snap-toggle-btn-nav" title="Activar/Desactivar snapping">
                  üìê Snap: OFF
                </button>
                <button onclick="resetCanvasViewNav()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Resetear vista">
                  üîÑ Reset Vista
                </button>
                <button onclick="zoomOutCanvasNav()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Alejar">
                  ‚ûñ
                </button>
                <span class="text-slate-400 text-xs px-2 py-1" id="zoom-level-nav">100%</span>
                <button onclick="zoomInCanvasNav()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Acercar">
                  ‚ûï
                </button>
                <button onclick="a√±adirNodo()" class="px-2 py-1 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded" title="A√±adir nodo">
                  ‚ûï Nodo
                </button>
              </div>
            </div>
            <div 
              id="canvas-visual-container-nav" 
              class="relative bg-slate-900 rounded border border-slate-700 overflow-hidden"
              style="width: 100%; height: calc(100vh - 450px); min-height: 600px; cursor: grab;"
              onmousedown="handleCanvasMouseDownNav(event)"
              onmousemove="handleCanvasMouseMoveNav(event)"
              onmouseup="handleCanvasMouseUpNav(event)"
              onmouseleave="handleCanvasMouseUpNav(event)"
              onwheel="handleCanvasWheelNav(event)"
            >
              <!-- SVG para edges (debajo de nodos) -->
              <svg 
                id="canvas-edges-svg-nav" 
                class="absolute inset-0 pointer-events-none"
                style="z-index: 1;"
              >
              </svg>
              
              <!-- Contenedor de nodos con transform para pan/zoom -->
              <div 
                id="canvas-nodes-container-nav" 
                class="absolute inset-0"
                style="transform: translate(0px, 0px) scale(1); transform-origin: 0 0;"
              >
              </div>
            </div>
          </div>
        </div>
        
        <!-- Columna derecha: Panel contextual (propiedades + preview) -->
        <div class="w-96 bg-slate-950 border-l border-slate-800 overflow-y-auto" style="display: flex; flex-direction: column;">
          <!-- Propiedades del nodo seleccionado -->
          <div class="flex-1 bg-slate-900 overflow-y-auto p-6">
            <div id="node-properties" class="bg-slate-800 rounded-lg shadow-lg p-6">
              <div class="text-center text-slate-400 py-8">
                <p>Selecciona un nodo del canvas para editarlo</p>
                <p class="text-xs mt-2 text-slate-500">
                  üí° Arrastra nodos para moverlos<br/>
                  üí° Alt + rueda para zoom<br/>
                  üí° Arrastra fondo para pan
                </p>
              </div>
            </div>
          </div>
          
          <!-- Preview estructural -->
          <div class="bg-slate-950 border-t border-slate-800 p-4" style="max-height: 300px; overflow-y: auto;">
            <h2 class="text-lg font-semibold text-white mb-4">Preview Estructural</h2>
            <div id="structural-preview" class="bg-slate-900 rounded-lg p-4 font-mono text-xs text-slate-300 overflow-auto">
              <pre id="preview-json" class="whitespace-pre-wrap">Cargando...</pre>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Vista √ÅRBOL -->
      <div id="vista-arbol" class="vista-container flex-1 flex hidden">
        <!-- Columna izquierda: √Årbol expand/collapse -->
        <div class="w-80 bg-slate-950 border-r border-slate-800 overflow-y-auto">
          <div class="p-4">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-lg font-semibold text-white">√Årbol de Nodos</h2>
              <button onclick="a√±adirNodo()" class="px-2 py-1 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded" title="A√±adir nodo">
                ‚ûï
              </button>
            </div>
            <div id="nodes-tree" class="space-y-1">
              <p class="text-slate-400 text-sm">Cargando nodos...</p>
            </div>
          </div>
        </div>
        
        <!-- Columna centro: Propiedades del nodo seleccionado -->
        <div class="flex-1 bg-slate-900 overflow-y-auto p-6">
          <div id="node-properties-arbol" class="bg-slate-800 rounded-lg shadow-lg p-6">
            <div class="text-center text-slate-400 py-8">
              <p>Selecciona un nodo del √°rbol para editarlo</p>
            </div>
          </div>
        </div>
        
        <!-- Columna derecha: Preview estructural -->
        <div class="w-96 bg-slate-950 border-l border-slate-800 overflow-y-auto">
          <div class="p-4">
            <h2 class="text-lg font-semibold text-white mb-4">Preview Estructural</h2>
            <div id="structural-preview-arbol" class="bg-slate-900 rounded-lg p-4 font-mono text-xs text-slate-300 overflow-auto">
              <pre id="preview-json-arbol" class="whitespace-pre-wrap">Cargando...</pre>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Vista JSON (read-only + copiar) -->
      <div id="vista-json" class="vista-container flex-1 hidden">
        <div class="w-full bg-slate-900 overflow-y-auto p-6">
          <div class="flex justify-between items-center mb-4">
            <h2 class="text-lg font-semibold text-white">Vista JSON (Read-Only)</h2>
            <button onclick="copiarJSON()" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded">
              üìã Copiar JSON
            </button>
          </div>
          <div class="bg-slate-950 rounded-lg p-4 font-mono text-xs text-slate-300 overflow-auto">
            <pre id="preview-json-full" class="whitespace-pre-wrap">Cargando...</pre>
          </div>
        </div>
      </div>
      
      <!-- Vista PREVIEW EFECTIVO (FASE 5) -->
      <div id="vista-preview" class="vista-container flex-1 flex hidden">
        <!-- Columna izquierda: Selectores de navegaci√≥n -->
        <div class="w-96 bg-slate-950 border-r border-slate-800 overflow-y-auto p-6">
          <h2 class="text-lg font-semibold text-white mb-4">üëÅÔ∏è Preview Efectivo</h2>
          <p class="text-sm text-slate-400 mb-6">
            Selecciona una navegaci√≥n global base y 0..N navegaciones contextuales para componer la navegaci√≥n efectiva.
          </p>
          
          <!-- Selector de navegaci√≥n global -->
          <div class="mb-6">
            <label class="block text-sm font-medium text-slate-300 mb-2">
              üåê Navegaci√≥n Global (Base)
            </label>
            <select id="preview-global-select" class="w-full px-3 py-2 bg-slate-800 text-white rounded border border-slate-700">
              <option value="">Seleccionar navegaci√≥n global...</option>
            </select>
          </div>
          
          <!-- Selector de navegaciones contextuales -->
          <div class="mb-6">
            <label class="block text-sm font-medium text-slate-300 mb-2">
              üéØ Navegaciones Contextuales (0..N)
            </label>
            <div id="preview-contexts-container" class="space-y-2 mb-2">
              <!-- Se a√±adir√°n din√°micamente -->
            </div>
            <button onclick="a√±adirContextoPreview()" class="w-full px-3 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded">
              ‚ûï A√±adir Contexto
            </button>
          </div>
          
          <!-- Bot√≥n de generar preview -->
          <button onclick="generarPreviewEfectivo()" class="w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white font-medium rounded mb-4">
            üîÑ Generar Preview
          </button>
          
          <!-- Warnings -->
          <div id="preview-warnings" class="hidden">
            <h3 class="text-sm font-semibold text-yellow-300 mb-2">‚ö†Ô∏è Warnings</h3>
            <div id="preview-warnings-list" class="space-y-1 text-xs text-yellow-200 bg-yellow-900/30 rounded p-3 max-h-48 overflow-y-auto">
              <!-- Se a√±adir√°n din√°micamente -->
            </div>
          </div>
        </div>
        
        <!-- Columna derecha: Canvas visual (MOTOR AXE) -->
        <div class="flex-1 bg-slate-900 p-6" style="display: flex; flex-direction: column; min-width: 0;">
          <div class="bg-slate-800 rounded-lg p-4 mb-4">
            <div class="flex justify-between items-center mb-2">
              <h4 class="text-white font-semibold">Preview Efectivo (Motor AXE)</h4>
              <div class="flex gap-2">
                <button onclick="resetCanvasViewPreview()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Resetear vista">
                  üîÑ Reset Vista
                </button>
                <button onclick="zoomOutCanvasPreview()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Alejar">
                  ‚ûñ
                </button>
                <span class="text-slate-400 text-xs px-2 py-1" id="zoom-level-preview">100%</span>
                <button onclick="zoomInCanvasPreview()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded" title="Acercar">
                  ‚ûï
                </button>
              </div>
            </div>
            <div 
              id="canvas-visual-container-preview" 
              class="relative bg-slate-900 rounded border border-slate-700 overflow-hidden"
              style="width: 100%; height: calc(100vh - 450px); min-height: 600px; cursor: grab;"
              onmousedown="handleCanvasMouseDownPreview(event)"
              onmousemove="handleCanvasMouseMovePreview(event)"
              onmouseup="handleCanvasMouseUpPreview(event)"
              onmouseleave="handleCanvasMouseUpPreview(event)"
              onwheel="handleCanvasWheelPreview(event)"
            >
              <!-- SVG para edges (debajo de nodos) -->
              <svg 
                id="canvas-edges-svg-preview" 
                class="absolute inset-0 pointer-events-none"
                style="z-index: 1;"
              >
              </svg>
              
              <!-- Contenedor de nodos con transform para pan/zoom -->
              <div 
                id="canvas-nodes-container-preview" 
                class="absolute inset-0"
                style="transform: translate(0px, 0px) scale(1); transform-origin: 0 0;"
              >
              </div>
            </div>
          </div>
          
          <!-- Panel de Provenance -->
          <div class="bg-slate-800 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">üìç Provenance</h4>
            <div id="preview-provenance" class="text-xs text-slate-300 bg-slate-900 rounded p-3 max-h-32 overflow-y-auto">
              <p class="text-slate-500">Genera un preview para ver la procedencia de nodos y edges</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  /* ============================================================================
   * LAYOUT CAN√ìNICO DEL EDITOR (FIX BUG CR√çTICO UI)
   * ============================================================================
   */
  
  .editor-layout {
    display: flex;
    flex-direction: column;
    height: calc(100vh - 130px);
    overflow: hidden;
  }
  
  .editor-topbar {
    position: relative;
    flex-shrink: 0;
    z-index: 10;
  }
  
  .editor-body {
    flex: 1;
    display: flex;
    overflow: hidden;
    min-height: 0;
  }
  
  .editor-body > div {
    height: 100%;
    min-height: 0;
  }
  
  @media (max-width: 1024px) {
    .editor-layout {
      height: auto;
      min-height: calc(100vh - 130px);
    }
    
    .editor-body {
      flex-direction: column;
      overflow-y: auto;
    }
    
    .editor-body > div {
      height: auto;
      min-height: 300px;
      width: 100% !important;
      flex-shrink: 0;
    }
  }
  
  .navigation-editor {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }
  
  /* Estilos para el √°rbol de nodos */
  .node-item {
    padding: 10px;
    background: #1e293b;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    border: 2px solid transparent;
    margin-bottom: 4px;
  }
  
  .node-item:hover {
    background: #334155;
  }
  
  .node-item.active {
    border-color: #4f46e5;
    background: #334155;
  }
  
  .node-item .node-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
  }
  
  .node-item .node-id {
    font-weight: 600;
    color: #fff;
    font-size: 13px;
    font-family: monospace;
  }
  
  .node-item .node-label {
    color: #cbd5e1;
    font-size: 12px;
    margin-top: 2px;
  }
  
  .node-item .node-kind {
    font-size: 11px;
    color: #94a3b8;
    text-transform: uppercase;
    margin-top: 4px;
  }
  
  .node-item .node-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
  }
  
  .node-item:hover .node-actions {
    opacity: 1;
  }
  
  .node-item .node-actions button {
    padding: 2px 6px;
    font-size: 11px;
    background: #475569;
    border: none;
    border-radius: 4px;
    color: #fff;
    cursor: pointer;
  }
  
  .node-item .node-actions button:hover {
    background: #64748b;
  }
  
  /* Estilos para propiedades de nodo */
  .property-group {
    margin-bottom: 20px;
  }
  
  .property-group label {
    display: block;
    color: #cbd5e1;
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 6px;
  }
  
  .property-group input,
  .property-group select,
  .property-group textarea {
    width: 100%;
    padding: 10px 12px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 6px;
    color: #fff;
    font-size: 14px;
    font-family: inherit;
  }
  
  .property-group input:focus,
  .property-group select:focus,
  .property-group textarea:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
  
  .property-group textarea {
    resize: vertical;
    min-height: 80px;
  }
  
  /* Preview JSON */
  #preview-json {
    font-size: 11px;
    line-height: 1.5;
    color: #cbd5e1;
  }
  
  /* Badges de estado */
  .publish-status {
    display: inline-flex;
    align-items: center;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 600;
  }
  
  .publish-status--ready {
    background: #064e3b;
    color: #6ee7b7;
  }
  
  .publish-status--draft {
    background: #78350f;
    color: #fcd34d;
  }
  
  .publish-status--invalid {
    background: #7f1d1d;
    color: #fca5a5;
  }
  
  /* Tabs de vistas */
  .tab-button {
    background: transparent;
    color: #94a3b8;
    border: none;
    cursor: pointer;
  }
  
  .tab-button:hover {
    color: #cbd5e1;
    background: rgba(255, 255, 255, 0.05);
  }
  
  .tab-button.active {
    color: #fff;
    background: #1e293b;
    border-bottom: 2px solid #4f46e5;
  }
  
  /* Vistas */
  .vista-container {
    display: flex;
  }
  
  .vista-container.hidden {
    display: none;
  }
  
  /* Mapa visual */
  .map-node {
    padding: 12px;
    background: #1e293b;
    border-radius: 8px;
    margin-bottom: 8px;
    cursor: move;
    border: 2px solid transparent;
    transition: all 0.2s;
    position: relative;
  }
  
  .map-node:hover {
    background: #334155;
    border-color: #4f46e5;
  }
  
  .map-node.active {
    border-color: #4f46e5;
    background: #334155;
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
  }
  
  .map-node.dragging {
    opacity: 0.5;
    cursor: grabbing;
  }
  
  .map-node.drag-over {
    border-top: 3px solid #3498db;
    background: #1e3a5f;
  }
  
  .map-node.drop-zone {
    border: 2px dashed #4f46e5;
    background: rgba(79, 70, 229, 0.1);
  }
  
  .map-node.drop-zone-invalid {
    border: 2px dashed #ef4444;
    background: rgba(239, 68, 68, 0.1);
  }
  
  .map-node-children {
    margin-left: 24px;
    margin-top: 8px;
    padding-left: 16px;
    border-left: 2px solid #334155;
  }
  
  /* √Årbol expand/collapse */
  .tree-node {
    padding: 8px;
    background: #1e293b;
    border-radius: 6px;
    margin-bottom: 4px;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.2s;
  }
  
  .tree-node:hover {
    background: #334155;
  }
  
  .tree-node.active {
    border-color: #4f46e5;
    background: #334155;
  }
  
  .tree-node-header {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .tree-node-toggle {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #94a3b8;
    font-size: 12px;
  }
  
  .tree-node-toggle:hover {
    color: #fff;
  }
  
  .tree-node-children {
    margin-left: 28px;
    margin-top: 4px;
  }
  
  .tree-node-children.collapsed {
    display: none;
  }
</style>

<script>
  console.log('BOOT NAV EDITOR', location.pathname);
  // Estado del editor
  const editorState = {
    navigationId: null,
    definition: null,
    tree: null, // Fuente de verdad local: TREE
    selectedNodeId: null,
    dirty: false,
    valid: false,
    isSaving: false,
    validationErrors: [],
    validationWarnings: [],
    currentView: 'mapa', // 'mapa', 'arbol', 'json'
    treeState: {}, // Estado de expand/collapse del √°rbol
    lastSavedAt: null // Timestamp del √∫ltimo guardado
  };
  
  // Toast system simple
  function showToast(message, type = 'success') {
    const toast = document.createElement('div');
    toast.className = `fixed top-4 right-4 px-4 py-3 rounded-lg shadow-lg z-50 ${
      type === 'success' ? 'bg-green-600 text-white' : 
      type === 'error' ? 'bg-red-600 text-white' : 
      'bg-blue-600 text-white'
    }`;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transition = 'opacity 0.3s';
      setTimeout(() => document.body.removeChild(toast), 300);
    }, 3000);
  }
  
  // Marcar como dirty
  function markDirty() {
    if (!editorState.dirty) {
      editorState.dirty = true;
      updateDirtyBadge();
    }
  }
  
  // Actualizar badge de dirty
  function updateDirtyBadge() {
    const badge = document.getElementById('dirty-badge');
    if (badge) {
      if (editorState.dirty) {
        badge.style.display = 'inline-block';
      } else {
        badge.style.display = 'none';
      }
    }
  }
  
  // Inicializar editor
  async function initEditor() {
    console.log('[Editor] STEP 1: initEditor start');
    
    const editor = document.getElementById('navigation-editor');
    if (!editor) {
      console.error('[Editor] STEP 1.1: ERROR - Elemento #navigation-editor no encontrado');
      // Fail-open: mostrar mensaje visible
      const topbar = document.querySelector('.editor-topbar');
      if (topbar) {
        topbar.innerHTML = `
          <div style="padding: 20px; background: #7f1d1d; color: #fca5a5; border-radius: 8px;">
            <h2 style="color: #ef4444; margin-bottom: 10px;">‚ö†Ô∏è Error de inicializaci√≥n</h2>
            <p>No se pudo encontrar el contenedor del editor. Por favor, recarga la p√°gina.</p>
          </div>
        `;
      }
      return;
    }
    
    console.log('[Editor] STEP 2: navigationId =', editor.dataset.navigationId);
    const navigationId = editor.dataset.navigationId;
    
    if (!navigationId) {
      console.error('[Editor] STEP 2.1: ERROR - data-navigation-id no encontrado');
      // Fail-open: mostrar mensaje visible
      const topbar = document.querySelector('.editor-topbar');
      if (topbar) {
        topbar.innerHTML = `
          <div style="padding: 20px; background: #7f1d1d; color: #fca5a5; border-radius: 8px;">
            <h2 style="color: #ef4444; margin-bottom: 10px;">‚ö†Ô∏è Error de inicializaci√≥n</h2>
            <p>No se pudo determinar el ID de navegaci√≥n. Por favor, recarga la p√°gina.</p>
          </div>
        `;
      }
      return;
    }
    
    editorState.navigationId = navigationId;
    console.log('[Editor] STEP 3: navigationId asignado =', editorState.navigationId);
    
    if (editorState.navigationId === 'new') {
      console.log('[Editor] STEP 4: creating new navigation');
      try {
        await crearNuevaNavegacion();
        console.log('[Editor] STEP 5: new navigation created');
      } catch (error) {
        console.error('[Editor] STEP 5.1: ERROR creando navegaci√≥n:', error);
        return;
      }
    } else {
      console.log('[Editor] STEP 4: loading existing navigation');
      try {
        await cargarNavegacion();
        console.log('[Editor] STEP 5: navigation loaded');
      } catch (error) {
        console.error('[Editor] STEP 5.1: ERROR cargando navegaci√≥n:', error);
        // Fail-open: mostrar mensaje visible
        const mapEl = document.getElementById('nodes-map');
        const treeEl = document.getElementById('nodes-tree');
        if (mapEl) mapEl.innerHTML = '<p class="text-red-400 text-sm">‚ö†Ô∏è Error cargando navegaci√≥n. Por favor, recarga la p√°gina.</p>';
        if (treeEl) treeEl.innerHTML = '<p class="text-red-400 text-sm">‚ö†Ô∏è Error cargando navegaci√≥n. Por favor, recarga la p√°gina.</p>';
        return;
      }
    }
    
    // FIX CR√çTICO: Inicializaci√≥n obligatoria de vista
    // Garantizar que el editor arranque SIEMPRE en vista "Mapa"
    console.log('[AXE][NAV_EDITOR] initEditor complete ‚Üí activating default view: mapa');
    setNavigationView('mapa');
    
    console.log('[Editor] STEP 6: initEditor complete');
  }
  
  // Crear nueva navegaci√≥n
  async function crearNuevaNavegacion() {
    const name = prompt('Nombre de la navegaci√≥n:');
    if (!name || !name.trim()) {
      window.location.href = '/admin/navigation';
      return;
    }
    
    const id = prompt(
      `ID t√©cnico de la navegaci√≥n:\n\n` +
      `‚ö†Ô∏è El ID debe ser:\n` +
      `- Solo letras min√∫sculas, n√∫meros, guiones y guiones bajos\n` +
      `- Sin espacios ni acentos`,
      name.toLowerCase().replace(/[^a-z0-9_-]/g, '_')
    );
    
    if (!id || !id.trim()) {
      window.location.href = '/admin/navigation';
      return;
    }
    
    try {
      const response = await fetch('/admin/api/navigation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          navigation_id: id.trim(),
          name: name.trim()
        })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || `Error ${response.status}`);
      }
      
      const data = await response.json();
      if (!data.ok || !data.data) {
        throw new Error('Respuesta inv√°lida del servidor');
      }
      
      editorState.definition = data.data.draft?.draft_json || data.data.draft?.definition_json;
      editorState.navigationId = data.data.navigation?.navigation_id || id.trim();
      editorState.dirty = false;
      
      window.history.replaceState({}, '', `/admin/navigation/${encodeURIComponent(editorState.navigationId)}/edit`);
      
      actualizarUI();
    } catch (error) {
      console.error('Error creando navegaci√≥n:', error);
      alert(`Error creando navegaci√≥n: ${error.message}`);
      window.location.href = '/admin/navigation';
    }
  }
  
  // Cargar lista de navegaciones para selector
  async function cargarListaNavegaciones() {
    try {
      const response = await fetch('/admin/api/navigation', {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.ok && data.data && data.data.navigations) {
          const selector = document.getElementById('navigation-selector');
          if (selector) {
            selector.style.display = 'block';
            selector.innerHTML = data.data.navigations.map(nav => {
              const selected = nav.navigation_id === editorState.navigationId ? 'selected' : '';
              return `<option value="${nav.navigation_id}" ${selected}>${nav.name || nav.navigation_id}</option>`;
            }).join('');
          }
        }
      }
    } catch (error) {
      console.error('Error cargando lista de navegaciones:', error);
    }
  }
  
  // Cambiar navegaci√≥n (con confirmaci√≥n si hay cambios sin guardar)
  function cambiarNavegacion() {
    const selector = document.getElementById('navigation-selector');
    if (!selector) return;
    
    const nuevoId = selector.value;
    if (nuevoId && nuevoId !== editorState.navigationId) {
      if (editorState.dirty) {
        if (!confirm('Tienes cambios sin guardar. ¬øEst√°s seguro de que quieres cambiar de navegaci√≥n? Los cambios se perder√°n.')) {
          // Revertir selector al valor anterior
          selector.value = editorState.navigationId;
          return;
        }
      }
      window.location.href = `/admin/navigation/${encodeURIComponent(nuevoId)}/edit`;
    }
  }
  
  // Prevenir p√©rdida de trabajo al salir
  window.addEventListener('beforeunload', (e) => {
    if (editorState.dirty) {
      e.preventDefault();
      e.returnValue = 'Tienes cambios sin guardar. ¬øEst√°s seguro de que quieres salir?';
      return e.returnValue;
    }
  });
  
  // Cargar navegaci√≥n
  async function cargarNavegacion() {
    console.log('[Editor] STEP 4.1: cargarNavegacion start');
    try {
      const encodedId = encodeURIComponent(editorState.navigationId);
      console.log('[Editor] STEP 4.2: encodedId =', encodedId);
      
      // Cargar lista de navegaciones para selector
      console.log('[Editor] STEP 4.3: loading navigation list');
      await cargarListaNavegaciones();
      console.log('[Editor] STEP 4.4: navigation list loaded');
      
      // Intentar cargar draft primero
      console.log('[Editor] STEP 4.5: fetching draft');
      let response = await fetch(`/admin/api/navigation/${encodedId}/draft`, {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });
      
      console.log('[Editor] STEP 4.6: draft response status =', response.status);
      
      if (response.ok) {
        console.log('[Editor] STEP 4.7: parsing draft JSON');
        const data = await response.json();
        console.log('[Editor] STEP 4.8: draft data received, ok =', data.ok);
        
        if (data.ok && data.data && data.data.draft_json) {
          editorState.definition = data.data.draft_json;
          console.log('[Editor] STEP 4.9: definition assigned from draft, nodes =', editorState.definition?.nodes ? Object.keys(editorState.definition.nodes).length : 0);
          
          // Construir tree desde definition al cargar
          editorState.tree = buildTreeFromDefinition(editorState.definition);
          console.log('[Editor] STEP 4.10: tree built from draft');
        } else {
          console.warn('[Editor] STEP 4.9: WARNING - no draft_json in response');
        }
      } else {
        console.warn('[Editor] STEP 4.7: WARNING - draft fetch failed, status =', response.status);
      }
      
      // Cargar informaci√≥n de versi√≥n publicada
      let publishedVersion = null;
      let publishedAt = null;
      
      console.log('[Editor] STEP 4.11: fetching published');
      response = await fetch(`/admin/api/navigation/${encodedId}/published`, {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });
      
      console.log('[Editor] STEP 4.12: published response status =', response.status);
      
      if (response.ok) {
        console.log('[Editor] STEP 4.13: parsing published JSON');
        const data = await response.json();
        
        if (data.ok && data.data) {
          publishedVersion = data.data.version;
          publishedAt = data.data.published_at;
          
          // Si no hay draft, usar published como referencia
          if (!editorState.definition && data.data.definition_json) {
            console.log('[Editor] STEP 4.14: using published as definition');
            editorState.definition = JSON.parse(JSON.stringify(data.data.definition_json));
            // Construir tree desde definition
            editorState.tree = buildTreeFromDefinition(editorState.definition);
            console.log('[Editor] STEP 4.15: tree built from published');
          }
        }
      } else {
        console.warn('[Editor] STEP 4.13: WARNING - published fetch failed, status =', response.status);
      }
      
      // Actualizar indicador de versi√≥n publicada
      const versionEl = document.getElementById('navigation-version');
      if (versionEl) {
        if (publishedVersion) {
          versionEl.textContent = `v${publishedVersion}`;
          versionEl.className = 'px-2 py-1 bg-green-900 text-green-200 rounded text-xs';
        } else {
          versionEl.textContent = 'Sin publicar';
          versionEl.className = 'px-2 py-1 bg-yellow-900 text-yellow-200 rounded text-xs';
        }
      }
      
      const publishedInfoEl = document.getElementById('navigation-published-info');
      if (publishedInfoEl && publishedAt) {
        const fecha = new Date(publishedAt);
        publishedInfoEl.textContent = `Publicado: ${fecha.toLocaleDateString('es-ES')} ${fecha.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}`;
        publishedInfoEl.style.display = 'inline-block';
      }
      
      console.log('[Editor] STEP 4.16: checking definition before continue');
      if (!editorState.definition) {
        console.error('[Editor] STEP 4.17: ERROR - definition es falsy, fail-open');
        // Fail-open: mostrar mensaje visible
        const mapEl = document.getElementById('nodes-map');
        const treeEl = document.getElementById('nodes-tree');
        if (mapEl) mapEl.innerHTML = '<p class="text-red-400 text-sm">‚ö†Ô∏è No se pudo cargar la navegaci√≥n (fail-open)</p>';
        if (treeEl) treeEl.innerHTML = '<p class="text-red-400 text-sm">‚ö†Ô∏è No se pudo cargar la navegaci√≥n (fail-open)</p>';
        throw new Error('No se pudo cargar la navegaci√≥n');
      }
      
      // Construir tree desde definition si no existe
      if (!editorState.tree) {
        console.log('[Editor] STEP 4.18: building tree from definition');
        editorState.tree = buildTreeFromDefinition(editorState.definition);
        console.log('[Editor] STEP 4.19: tree built');
      }
      
      console.log('[Editor] STEP 4.20: definition ready, nodes =', editorState.definition?.nodes ? Object.keys(editorState.definition.nodes).length : 0);
      
      editorState.dirty = false;
      editorState.lastSavedAt = null;
      updateDirtyBadge();
      
      console.log('[Editor] STEP 4.21: calling actualizarUI()');
      actualizarUI();
      console.log('[Editor] STEP 4.22: actualizarUI() completed');
    } catch (error) {
      console.error('[Editor] STEP 4.23: ERROR cargando navegaci√≥n:', error);
      // Fail-open: mostrar mensaje visible
      const mapEl = document.getElementById('nodes-map');
      const treeEl = document.getElementById('nodes-tree');
      if (mapEl) mapEl.innerHTML = `<p class="text-red-400 text-sm">‚ö†Ô∏è Error cargando navegaci√≥n: ${error.message}</p>`;
      if (treeEl) treeEl.innerHTML = `<p class="text-red-400 text-sm">‚ö†Ô∏è Error cargando navegaci√≥n: ${error.message}</p>`;
      alert(`Error cargando navegaci√≥n: ${error.message}`);
    }
    console.log('[Editor] STEP 4.24: cargarNavegacion end');
  }
  
  // ========================================================================
  // SISTEMA CENTRALIZADO DE VISTAS (FIX CR√çTICO - Editor de Navegaci√≥n)
  // ========================================================================
  
  /**
   * Oculta todas las vistas del editor
   */
  function hideAllNavigationViews() {
    document.querySelectorAll('.vista-container').forEach(el => el.classList.add('hidden'));
  }
  
  /**
   * Actualiza el estado visual de los botones de vista
   * @param {string} view - Vista activa ('mapa', 'arbol', 'json', 'preview')
   */
  function updateViewButtons(view) {
    // Desactivar todas las tabs
    document.querySelectorAll('.tab-button').forEach(el => el.classList.remove('active'));
    
    // Activar tab seleccionada
    const tabEl = document.getElementById(`tab-${view}`);
    if (tabEl) {
      tabEl.classList.add('active');
    }
    
    // Mostrar vista seleccionada
    const vistaEl = document.getElementById(`vista-${view}`);
    if (vistaEl) {
      vistaEl.classList.remove('hidden');
    }
  }
  
  /**
   * Renderiza el contenido de una vista espec√≠fica
   * @param {string} view - Vista a renderizar ('mapa', 'arbol', 'json', 'preview')
   */
  function renderNavigationView(view) {
    console.log('[AXE][NAV_EDITOR] renderNavigationView:', view);
    
    switch (view) {
      case 'mapa':
        renderNodesMap();
        break;
      case 'arbol':
        renderNodesTree();
        break;
      case 'json':
        renderJSONView();
        break;
      case 'preview':
        renderPreviewView();
        break;
      default:
        console.warn('[AXE][NAV_EDITOR] Vista desconocida:', view);
    }
  }
  
  /**
   * Funci√≥n central para cambiar de vista en el editor
   * √önico punto de entrada para cambiar vistas (source of truth)
   * @param {string} view - Vista a activar ('mapa', 'arbol', 'json', 'preview')
   */
  function setNavigationView(view) {
    console.log('[AXE][NAV_EDITOR] setNavigationView:', view);
    
    // Actualizar estado
    editorState.currentView = view;
    
    // Ocultar todas las vistas
    hideAllNavigationViews();
    
    // Actualizar botones y mostrar vista
    updateViewButtons(view);
    
    // Renderizar contenido de la vista
    renderNavigationView(view);
  }
  
  // Mantener compatibilidad con c√≥digo legacy (deprecado)
  function cambiarVista(vista) {
    console.warn('[AXE][NAV_EDITOR] cambiarVista() est√° deprecado, usar setNavigationView()');
    setNavigationView(vista);
  }
  
  // Copiar JSON al portapapeles
  async function copiarJSON() {
    if (!editorState.definition) return;
    
    const json = JSON.stringify(editorState.definition, null, 2);
    try {
      await navigator.clipboard.writeText(json);
      alert('‚úÖ JSON copiado al portapapeles');
    } catch (error) {
      console.error('Error copiando JSON:', error);
      alert('Error al copiar JSON');
    }
  }
  
  // Renderizar vista JSON
  function renderJSONView() {
    const previewEl = document.getElementById('preview-json-full');
    if (!previewEl || !editorState.definition) return;
    
    previewEl.textContent = JSON.stringify(editorState.definition, null, 2);
  }
  
  // Actualizar UI completa
  function actualizarUI() {
    console.log('[Editor] STEP 4.21.1: actualizarUI start');
    
    if (!editorState.definition) {
      console.warn('[Editor] STEP 4.21.2: WARNING - definition es falsy, fail-open');
      // Fail-open: mostrar mensaje visible
      const mapEl = document.getElementById('nodes-map');
      const treeEl = document.getElementById('nodes-tree');
      if (mapEl) mapEl.innerHTML = '<p class="text-red-400 text-sm">‚ö†Ô∏è No hay datos para mostrar (fail-open)</p>';
      if (treeEl) treeEl.innerHTML = '<p class="text-red-400 text-sm">‚ö†Ô∏è No hay datos para mostrar (fail-open)</p>';
      return;
    }
    
    console.log('[Editor] STEP 4.21.3: definition exists, nodes =', editorState.definition?.nodes ? Object.keys(editorState.definition.nodes).length : 0);
    
    // Actualizar nombre
    const nameEl = document.getElementById('navigation-name');
    if (nameEl) {
      nameEl.textContent = editorState.definition.name || editorState.navigationId;
    }
    
    // FASE 4.1: Actualizar tipo de navegaci√≥n y context_key
    const typeEl = document.getElementById('navigation-type');
    if (typeEl) {
      typeEl.value = editorState.definition.type || 'global';
    }
    
    const contextKeyEl = document.getElementById('navigation-context-key');
    if (contextKeyEl) {
      const navType = editorState.definition.type || 'global';
      if (navType === 'contextual') {
        contextKeyEl.style.display = 'inline-block';
        contextKeyEl.value = editorState.definition.context_key || '';
      } else {
        contextKeyEl.style.display = 'none';
        contextKeyEl.value = '';
      }
    }
    
    // Renderizar seg√∫n la vista actual
    console.log('[Editor] STEP 4.21.4: rendering view =', editorState.currentView);
    if (editorState.currentView === 'mapa') {
      console.log('[Editor] STEP 4.21.5: calling renderNodesMap()');
      renderNodesMap();
      console.log('[Editor] STEP 4.21.6: renderNodesMap() completed');
    } else if (editorState.currentView === 'arbol') {
      console.log('[Editor] STEP 4.21.5: calling renderNodesTree()');
      renderNodesTree();
      console.log('[Editor] STEP 4.21.6: renderNodesTree() completed');
    } else if (editorState.currentView === 'json') {
      console.log('[Editor] STEP 4.21.5: calling renderJSONView()');
      renderJSONView();
      console.log('[Editor] STEP 4.21.6: renderJSONView() completed');
    }
    
    // Renderizar preview
    console.log('[Editor] STEP 4.21.7: calling renderPreview()');
    renderPreview();
    console.log('[Editor] STEP 4.21.8: renderPreview() completed');
    
    // Si hay nodo seleccionado en canvas, mostrar propiedades
    const selectedNodeId = window.canvasSelectionStateNav?.selectedNodeId || editorState.selectedNodeId;
    if (selectedNodeId) {
      console.log('[Editor] STEP 4.21.9: rendering node properties');
      renderNodeProperties(selectedNodeId);
    } else {
      // Seleccionar nodo ra√≠z por defecto en canvas
      if (editorState.definition.entry_node_id) {
        console.log('[Editor] STEP 4.21.9: selecting entry node in canvas');
        seleccionarNodoCanvasNav(editorState.definition.entry_node_id);
      }
    }
    
    // Actualizar estado
    updateStatusIndicator();
    console.log('[Editor] STEP 4.21.10: actualizarUI complete');
  }
  
  // ========================================================================
  // FUNCIONES DE SERIALIZACI√ìN (buildTreeFromDefinition / buildDefinitionFromTree)
  // ========================================================================
  
  /**
   * Convierte NavigationDefinition (nodes+edges) ‚Üí √°rbol jer√°rquico
   * @param {Object} definition - NavigationDefinition con nodes y edges
   * @returns {Object} √Årbol con estructura { node, children: [...] }
   */
  function buildTreeFromDefinition(definition) {
    if (!definition || !definition.nodes) return null;
    
    const nodes = definition.nodes;
    const edges = definition.edges || [];
    const entryNodeId = definition.entry_node_id;
    
    // Construir mapa de hijos desde edges
    const childrenMap = {};
    edges.forEach(edge => {
      if (edge.kind === 'child' || !edge.kind) {
        if (!childrenMap[edge.from]) {
          childrenMap[edge.from] = [];
        }
        childrenMap[edge.from].push({
          nodeId: edge.to,
          order: edge.order || 0
        });
      }
    });
    
    // Ordenar hijos por order
    Object.keys(childrenMap).forEach(parentId => {
      childrenMap[parentId].sort((a, b) => (a.order || 0) - (b.order || 0));
    });
    
    // Construir √°rbol recursivamente
    function buildNodeTree(nodeId, visited = new Set()) {
      if (visited.has(nodeId)) {
        console.warn(`Loop detectado en nodo ${nodeId}`);
        return null; // Evitar loops
      }
      visited.add(nodeId);
      
      const node = nodes[nodeId];
      if (!node) return null;
      
      const children = (childrenMap[nodeId] || []).map(child => {
        const childTree = buildNodeTree(child.nodeId, new Set(visited));
        return childTree;
      }).filter(child => child !== null);
      
      return {
        node: { ...node },
        children: children
      };
    }
    
    if (entryNodeId && nodes[entryNodeId]) {
      return buildNodeTree(entryNodeId);
    }
    
    // Si no hay entry_node_id, construir √°rbol desde todos los nodos sin padre
    const rootNodes = Object.keys(nodes).filter(nodeId => {
      return !edges.some(edge => edge.to === nodeId && (edge.kind === 'child' || !edge.kind));
    });
    
    if (rootNodes.length === 1) {
      return buildNodeTree(rootNodes[0]);
    }
    
    // M√∫ltiples ra√≠ces: crear nodo virtual
    return {
      node: { id: '__root__', kind: 'virtual' },
      children: rootNodes.map(nodeId => buildNodeTree(nodeId)).filter(n => n !== null)
    };
  }
  
  /**
   * Convierte √°rbol jer√°rquico ‚Üí NavigationDefinition (nodes+edges)
   * @param {Object} tree - √Årbol con estructura { node, children: [...] }
   * @param {string} entryNodeId - ID del nodo ra√≠z
   * @returns {Object} NavigationDefinition con nodes y edges
   */
  function buildDefinitionFromTree(tree, entryNodeId) {
    if (!tree) return { nodes: {}, edges: [], entry_node_id: null };
    
    const nodes = {};
    const edges = [];
    let currentOrder = 0;
    
    function processNode(nodeTree, parentId = null, order = 0) {
      if (!nodeTree || !nodeTree.node) return;
      
      const node = nodeTree.node;
      
      // Ignorar nodo virtual ra√≠z
      if (node.id === '__root__' && node.kind === 'virtual') {
        if (nodeTree.children) {
          nodeTree.children.forEach((child, idx) => {
            processNode(child, null, idx);
          });
        }
        return;
      }
      
      // A√±adir nodo
      nodes[node.id] = { ...node };
      
      // A√±adir edge si tiene padre
      if (parentId) {
        edges.push({
          from: parentId,
          to: node.id,
          kind: 'child',
          order: order
        });
      }
      
      // Procesar hijos
      if (nodeTree.children && Array.isArray(nodeTree.children)) {
        nodeTree.children.forEach((child, idx) => {
          processNode(child, node.id, idx);
        });
      }
    }
    
    processNode(tree);
    
    // Actualizar order en nodos seg√∫n posici√≥n en edges
    Object.keys(nodes).forEach(nodeId => {
      const nodeEdges = edges.filter(e => e.to === nodeId);
      if (nodeEdges.length > 0) {
        nodes[nodeId].order = nodeEdges[0].order || 0;
      }
    });
    
    return {
      nodes: nodes,
      edges: edges,
      entry_node_id: entryNodeId || (tree?.node?.id !== '__root__' ? tree?.node?.id : null)
    };
  }
  
  // Renderizar mapa visual jer√°rquico (AHORA USA CANVAS AXE)
  function renderNodesMap() {
    console.log('[NavigationEditor] renderNodesMap - INICIO (MOTOR AXE)');
    
    if (!editorState.definition) {
      console.warn('[NavigationEditor] renderNodesMap - WARNING: definition es falsy');
      return;
    }
    
    // Convertir NavigationDefinition ‚Üí CanvasDefinition
    const canvas = navigationDefinitionToCanvas(editorState.definition);
    console.log('[NavigationEditor] renderNodesMap - canvas convertido:', canvas);
    
    // Renderizar canvas visual
    renderCanvasViewerNav(canvas);
    
    // Actualizar panel contextual si hay nodo seleccionado
    const selectedNodeId = window.canvasSelectionStateNav?.selectedNodeId;
    if (selectedNodeId) {
      renderNodeProperties(selectedNodeId);
    }
    
    console.log('[NavigationEditor] renderNodesMap - FIN (MOTOR AXE)');
  }
  
  // Renderizar √°rbol de nodos con expand/collapse
  function renderNodesTree() {
    console.log('[NavigationEditor] renderNodesTree - INICIO');
    console.log('[NavigationEditor] renderNodesTree - editorState.tree:', editorState.tree);
    console.log('[NavigationEditor] renderNodesTree - editorState.tree es undefined?', editorState.tree === undefined);
    console.log('[NavigationEditor] renderNodesTree - editorState.tree es null?', editorState.tree === null);
    
    const treeEl = document.getElementById('nodes-tree');
    console.log('[NavigationEditor] renderNodesTree - treeEl:', treeEl);
    console.log('[NavigationEditor] renderNodesTree - treeEl es null?', treeEl === null);
    
    if (!treeEl) {
      console.error('[NavigationEditor] renderNodesTree - ERROR: treeEl no existe');
      return;
    }
    
    if (!editorState.tree) {
      console.warn('[NavigationEditor] renderNodesTree - WARNING: editorState.tree es falsy, mostrando mensaje');
      treeEl.innerHTML = '<p class="text-slate-400 text-sm">No hay nodos en esta navegaci√≥n (fail-open)</p>';
      return;
    }
    
    const tree = editorState.tree;
    console.log('[NavigationEditor] renderNodesTree - tree:', tree);
    console.log('[NavigationEditor] renderNodesTree - tree.node:', tree?.node);
    console.log('[NavigationEditor] renderNodesTree - tree.children:', tree?.children);
    
    if (!tree) {
      console.warn('[NavigationEditor] renderNodesTree - WARNING: tree es falsy despu√©s de asignar');
      treeEl.innerHTML = '<p class="text-slate-400 text-sm">No hay nodos en esta navegaci√≥n (fail-open)</p>';
      return;
    }
    
    let html = '';
    
    function renderTreeNode(nodeTree, level = 0) {
      if (!nodeTree || !nodeTree.node) return '';
      
      const node = nodeTree.node;
      
      // Ignorar nodo virtual ra√≠z
      if (node.id === '__root__' && node.kind === 'virtual') {
        if (nodeTree.children) {
          return nodeTree.children.map(child => renderTreeNode(child, level)).join('');
        }
        return '';
      }
      
      const isActive = editorState.selectedNodeId === node.id;
      const hasChildren = nodeTree.children && nodeTree.children.length > 0;
      const isExpanded = editorState.treeState[node.id] !== false; // Por defecto expandido
      const escapedId = (node.id || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
      
      html += `
        <div class="tree-node ${isActive ? 'active' : ''}" onclick="seleccionarNodo('${escapedId}')">
          <div class="tree-node-header">
            ${hasChildren ? `
              <span class="tree-node-toggle" onclick="event.stopPropagation(); toggleTreeNode('${escapedId}')">
                ${isExpanded ? '‚ñº' : '‚ñ∂'}
              </span>
            ` : '<span style="width: 20px;"></span>'}
            <div class="flex-1">
              <div class="font-semibold text-white">${(node.label || node.id || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
              <div class="text-xs text-slate-400">${(node.id || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')} ‚Ä¢ ${(node.kind || 'item').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
            </div>
            <div class="node-actions" onclick="event.stopPropagation()">
              <button onclick="eliminarNodo('${escapedId}')" title="Eliminar" class="px-2 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded">üóëÔ∏è</button>
            </div>
          </div>
        </div>
      `;
      
      // Renderizar hijos si est√° expandido
      if (hasChildren && isExpanded) {
        html += '<div class="tree-node-children">';
        nodeTree.children.forEach(child => {
          html += renderTreeNode(child, level + 1);
        });
        html += '</div>';
      }
      
      return '';
    }
    
    html = renderTreeNode(tree);
    console.log('[NavigationEditor] renderNodesTree - html generado:', html);
    console.log('[NavigationEditor] renderNodesTree - html length:', html.length);
    
    if (html === '') {
      console.warn('[NavigationEditor] renderNodesTree - WARNING: html est√° vac√≠o');
      html = '<p class="text-slate-400 text-sm">No hay nodos en esta navegaci√≥n (fail-open)</p>';
    }
    
    console.log('[NavigationEditor] renderNodesTree - Asignando innerHTML al treeEl...');
    treeEl.innerHTML = html;
    console.log('[NavigationEditor] renderNodesTree - innerHTML asignado');
    console.log('[NavigationEditor] renderNodesTree - FIN');
  }
  
  // Toggle expand/collapse de nodo en √°rbol
  function toggleTreeNode(nodeId) {
    editorState.treeState[nodeId] = !editorState.treeState[nodeId];
    renderNodesTree();
  }
  
  // Drag & Drop handlers
  let draggedNodeId = null;
  
  function handleDragStart(event) {
    draggedNodeId = event.currentTarget.dataset.nodeId;
    event.currentTarget.classList.add('dragging');
    event.dataTransfer.effectAllowed = 'move';
  }
  
  function handleDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    const target = event.currentTarget;
    const targetNodeId = target.dataset.nodeId;
    
    if (targetNodeId !== draggedNodeId) {
      // Verificar si el movimiento es v√°lido
      if (editorState.tree) {
        const isValid = !esAncestroEnTree(editorState.tree, targetNodeId, draggedNodeId) && 
                        draggedNodeId !== editorState.definition?.entry_node_id;
        
        if (isValid) {
          target.classList.add('drag-over', 'drop-zone');
          target.classList.remove('drop-zone-invalid');
        } else {
          target.classList.add('drag-over', 'drop-zone-invalid');
          target.classList.remove('drop-zone');
        }
      } else {
        target.classList.add('drag-over', 'drop-zone');
      }
    }
  }
  
  function handleDrop(event) {
    event.preventDefault();
    const target = event.currentTarget;
    const targetNodeId = target.dataset.nodeId;
    
    // Limpiar clases de drop zone
    target.classList.remove('drag-over', 'drop-zone', 'drop-zone-invalid');
    
    if (draggedNodeId && targetNodeId && draggedNodeId !== targetNodeId) {
      // Verificar que el movimiento es v√°lido antes de ejecutar
      if (editorState.tree) {
        if (esAncestroEnTree(editorState.tree, targetNodeId, draggedNodeId)) {
          showToast('‚ö†Ô∏è Movimiento inv√°lido: no se puede mover un nodo dentro de sus propios descendientes (loop)', 'error');
          return;
        }
        
        if (draggedNodeId === editorState.definition?.entry_node_id) {
          showToast('‚ö†Ô∏è No se puede mover el nodo ra√≠z', 'error');
          return;
        }
      }
      
      // Mover nodo: cambiar parent
      moverNodo(draggedNodeId, targetNodeId);
    }
  }
  
  function handleDragEnd(event) {
    event.currentTarget.classList.remove('dragging');
    document.querySelectorAll('.drag-over, .drop-zone, .drop-zone-invalid').forEach(el => {
      el.classList.remove('drag-over', 'drop-zone', 'drop-zone-invalid');
    });
    draggedNodeId = null;
  }
  
  // Mover nodo (cambiar de padre)
  function moverNodo(nodeId, nuevoParentId) {
    if (!editorState.tree) return;
    
    // Validar que no se cree un loop (no meter un padre dentro de su hijo)
    if (esAncestroEnTree(editorState.tree, nuevoParentId, nodeId)) {
      showToast('‚ö†Ô∏è Movimiento inv√°lido: no se puede mover un nodo dentro de sus propios descendientes (loop)', 'error');
      return;
    }
    
    // Prohibir mover root
    if (nodeId === editorState.definition?.entry_node_id) {
      showToast('‚ö†Ô∏è No se puede mover el nodo ra√≠z', 'error');
      return;
    }
    
    // Mover en el tree (fuente de verdad)
    const moved = moveNodeInTree(editorState.tree, nodeId, nuevoParentId);
    if (!moved) {
      showToast('‚ö†Ô∏è No se pudo mover el nodo', 'error');
      return;
    }
    
    // Reconstruir definition desde tree
    editorState.definition = buildDefinitionFromTree(editorState.tree, editorState.definition?.entry_node_id);
    
    markDirty();
    actualizarUI();
  }
  
  // Mover nodo en el tree
  function moveNodeInTree(tree, nodeId, newParentId) {
    if (!tree || !tree.node) return false;
    
    // Buscar el nodo a mover y su padre actual
    let nodeToMove = null;
    let currentParent = null;
    
    function findNode(parentTree, targetId, parent = null) {
      if (!parentTree || !parentTree.node) return null;
      
      if (parentTree.node.id === targetId) {
        nodeToMove = parentTree;
        currentParent = parent;
        return parentTree;
      }
      
      if (parentTree.children) {
        for (let i = 0; i < parentTree.children.length; i++) {
          const found = findNode(parentTree.children[i], targetId, parentTree);
          if (found) return found;
        }
      }
      
      return null;
    }
    
    findNode(tree, nodeId);
    
    if (!nodeToMove) return false;
    
    // Buscar nuevo padre
    let newParent = null;
    function findParent(parentTree, targetId) {
      if (!parentTree || !parentTree.node) return null;
      
      if (parentTree.node.id === targetId) {
        return parentTree;
      }
      
      if (parentTree.children) {
        for (const child of parentTree.children) {
          const found = findParent(child, targetId);
          if (found) return found;
        }
      }
      
      return null;
    }
    
    newParent = findParent(tree, newParentId);
    if (!newParent) return false;
    
    // Remover de padre actual
    if (currentParent && currentParent.children) {
      currentParent.children = currentParent.children.filter(child => child !== nodeToMove);
    }
    
    // A√±adir a nuevo padre
    if (!newParent.children) {
      newParent.children = [];
    }
    newParent.children.push(nodeToMove);
    
    // Recalcular order
    if (newParent.children) {
      newParent.children.forEach((child, idx) => {
        if (child.node) {
          child.node.order = idx;
        }
      });
    }
    
    return true;
  }
  
  // Verificar si un nodo es ancestro de otro en el tree
  function esAncestroEnTree(tree, ancestroId, descendienteId) {
    if (ancestroId === descendienteId) return true;
    
    function findNode(parentTree, targetId) {
      if (!parentTree || !parentTree.node) return null;
      
      if (parentTree.node.id === targetId) {
        return parentTree;
      }
      
      if (parentTree.children) {
        for (const child of parentTree.children) {
          const found = findNode(child, targetId);
          if (found) return found;
        }
      }
      
      return null;
    }
    
    const ancestroNode = findNode(tree, ancestroId);
    if (!ancestroNode) return false;
    
    // Buscar descendienteId dentro de ancestroNode
    return findNode(ancestroNode, descendienteId) !== null;
  }
  
  // Verificar si un nodo es ancestro de otro (para evitar loops)
  function esAncestro(ancestroId, descendienteId) {
    if (ancestroId === descendienteId) return true;
    
    const edges = editorState.definition.edges || [];
    const childrenMap = {};
    
    edges.forEach(edge => {
      if (edge.kind === 'child' || !edge.kind) {
        if (!childrenMap[edge.from]) {
          childrenMap[edge.from] = [];
        }
        childrenMap[edge.from].push(edge.to);
      }
    });
    
    function buscarDescendientes(nodeId, visited = new Set()) {
      if (visited.has(nodeId)) return false;
      visited.add(nodeId);
      
      if (nodeId === descendienteId) return true;
      
      const children = childrenMap[nodeId] || [];
      return children.some(childId => buscarDescendientes(childId, visited));
    }
    
    return buscarDescendientes(ancestroId);
  }
  
  // Seleccionar nodo
  function seleccionarNodo(nodeId) {
    editorState.selectedNodeId = nodeId;
    renderNodesTree();
    renderNodeProperties(nodeId);
  }
  
  // Renderizar propiedades del nodo (compartido entre vistas)
  function renderNodeProperties(nodeId) {
    // Actualizar en ambas vistas si existen
    const propsEl = document.getElementById('node-properties');
    const propsElArbol = document.getElementById('node-properties-arbol');
    
    const propsHTML = generarHTMLPropiedades(nodeId);
    
    if (propsEl) propsEl.innerHTML = propsHTML;
    if (propsElArbol) propsElArbol.innerHTML = propsHTML;
  }
  
  // Generar HTML de propiedades (reutilizable)
  function generarHTMLPropiedades(nodeId) {
    if (!editorState.definition || !editorState.definition.nodes) {
      return '<div class="text-center text-red-400 py-8">Nodo no encontrado</div>';
    }
    
    const node = editorState.definition.nodes[nodeId];
    if (!node) {
      return '<div class="text-center text-red-400 py-8">Nodo no encontrado</div>';
    }
    
    const escapedId = (nodeId || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
    
    return `
      <h3 class="text-xl font-bold text-white mb-4">Propiedades: ${(node.id || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</h3>
      
      <div class="property-group">
        <label>ID</label>
        <input type="text" id="node-id" value="${(node.id || '').replace(/"/g, '&quot;')}" disabled class="bg-slate-700 text-slate-400">
        <p class="text-xs text-slate-400 mt-1">El ID no se puede cambiar (estable)</p>
      </div>
      
      <div class="property-group">
        <label>Kind</label>
        <select id="node-kind" onchange="actualizarPropiedadNodo('kind', this.value)">
          <option value="section" ${node.kind === 'section' ? 'selected' : ''}>Section</option>
          <option value="group" ${node.kind === 'group' ? 'selected' : ''}>Group</option>
          <option value="item" ${node.kind === 'item' ? 'selected' : ''}>Item</option>
          <option value="hub" ${node.kind === 'hub' ? 'selected' : ''}>Hub</option>
          <option value="external_link" ${node.kind === 'external_link' ? 'selected' : ''}>External Link</option>
          <option value="system_entry" ${node.kind === 'system_entry' ? 'selected' : ''}>System Entry</option>
        </select>
      </div>
      
      <!-- FASE 4.2: Tipo sem√°ntico del nodo -->
      <div class="property-group">
        <label>Type (Sem√°ntico) 
          <span class="text-xs text-slate-400" title="Tipo sem√°ntico del nodo para claridad editorial">‚ÑπÔ∏è</span>
        </label>
        <select id="node-type" onchange="actualizarPropiedadNodo('type', this.value || null)">
          <option value="">Ninguno</option>
          <option value="home" ${node.type === 'home' ? 'selected' : ''}>üè† Home</option>
          <option value="section" ${node.type === 'section' ? 'selected' : ''}>üìÅ Section</option>
          <option value="view" ${node.type === 'view' ? 'selected' : ''}>üëÅÔ∏è View</option>
          <option value="external" ${node.type === 'external' ? 'selected' : ''}>üîó External</option>
          <option value="overlay" ${node.type === 'overlay' ? 'selected' : ''}>üìã Overlay</option>
          <option value="return" ${node.type === 'return' ? 'selected' : ''}>‚Ü©Ô∏è Return</option>
        </select>
        <p class="text-xs text-slate-400 mt-1">
          ${node.type === 'home' ? '‚ö†Ô∏è Solo uno por navegaci√≥n' : ''}
          ${node.type === 'return' ? '‚ö†Ô∏è Solo permite 1 edge saliente' : ''}
          ${node.type === 'overlay' ? '‚ö†Ô∏è No puede ser entry' : ''}
          ${node.type === 'external' ? '‚ö†Ô∏è Requiere URL' : ''}
          ${!node.type ? 'Tipo sem√°ntico opcional para claridad editorial' : ''}
        </p>
      </div>
      
      <div class="property-group">
        <label>Label</label>
        <input type="text" id="node-label" value="${(node.label || '').replace(/"/g, '&quot;')}" onchange="actualizarPropiedadNodo('label', this.value)" placeholder="Texto visible del nodo">
      </div>
      
      <div class="property-group">
        <label>Subtitle</label>
        <input type="text" id="node-subtitle" value="${(node.subtitle || '').replace(/"/g, '&quot;')}" onchange="actualizarPropiedadNodo('subtitle', this.value)" placeholder="Subt√≠tulo opcional">
      </div>
      
      <div class="property-group">
        <label>Icon</label>
        <input type="text" id="node-icon" value="${(node.icon || '').replace(/"/g, '&quot;')}" onchange="actualizarPropiedadNodo('icon', this.value)" placeholder="Emoji o c√≥digo de icono">
      </div>
      
      <div class="property-group">
        <label>Order</label>
        <input type="number" id="node-order" value="${node.order !== undefined ? node.order : ''}" onchange="actualizarPropiedadNodo('order', parseInt(this.value) || 0)" placeholder="0">
        <p class="text-xs text-slate-400 mt-1">Orden entre hermanos (se recalcula autom√°ticamente al mover)</p>
      </div>
      
      <div class="property-group">
        <label>Layout Hint</label>
        <select id="node-layout-hint" onchange="actualizarPropiedadNodo('layout_hint', this.value || null)">
          <option value="">Ninguno</option>
          <option value="list" ${node.layout_hint === 'list' ? 'selected' : ''}>List</option>
          <option value="grid" ${node.layout_hint === 'grid' ? 'selected' : ''}>Grid</option>
          <option value="map" ${node.layout_hint === 'map' ? 'selected' : ''}>Map</option>
          <option value="cards" ${node.layout_hint === 'cards' ? 'selected' : ''}>Cards</option>
          <option value="tree" ${node.layout_hint === 'tree' ? 'selected' : ''}>Tree</option>
        </select>
      </div>
      
      <div class="property-group">
        <label>Target Type</label>
        <select id="node-target-type" onchange="actualizarTargetNodo('type', this.value || null)">
          <option value="">Ninguno</option>
          <option value="recorrido" ${node.target?.type === 'recorrido' ? 'selected' : ''}>Recorrido</option>
          <option value="pde_catalog" ${node.target?.type === 'pde_catalog' ? 'selected' : ''}>PDE Catalog</option>
          <option value="screen" ${node.target?.type === 'screen' ? 'selected' : ''}>Screen</option>
          <option value="url" ${node.target?.type === 'url' ? 'selected' : ''}>URL</option>
          <option value="admin_tool" ${node.target?.type === 'admin_tool' ? 'selected' : ''}>Admin Tool</option>
        </select>
      </div>
      
      <div class="property-group">
        <label>Target Ref</label>
        <input type="text" id="node-target-ref" value="${(node.target?.ref || '').replace(/"/g, '&quot;')}" onchange="actualizarTargetNodo('ref', this.value || null)" placeholder="Referencia seg√∫n Target Type">
      </div>
      
      ${node.visibility ? `
      <div class="property-group">
        <label>Visibility (JSON - Legacy)</label>
        <textarea id="node-visibility" rows="3" onchange="actualizarPropiedadNodo('visibility', JSON.parse(this.value || '{}'))" class="font-mono text-xs">${JSON.stringify(node.visibility, null, 2)}</textarea>
      </div>
      ` : ''}
      
      <!-- FASE 4.3: Reglas de visibilidad (pasivo, sin evaluaci√≥n) -->
      <div class="property-group">
        <details class="cursor-pointer">
          <summary class="text-slate-300 font-semibold mb-2 select-none">
            üëÅÔ∏è Visibilidad (Futuro)
            <span class="text-xs text-slate-500 ml-2" title="No se eval√∫a todav√≠a, solo se guarda">‚ö†Ô∏è No se eval√∫a todav√≠a</span>
          </summary>
          <div class="mt-3 p-3 bg-slate-800 rounded border border-slate-700">
            <p class="text-xs text-slate-400 mb-3">
              üí° Estas reglas se guardan pero NO se eval√∫an todav√≠a. Preparaci√≥n para futuras funcionalidades.
            </p>
            <div class="space-y-3">
              <div>
                <label class="text-xs text-slate-400 block mb-1">Min Level</label>
                <input 
                  type="number" 
                  id="node-visibility-min-level" 
                  value="${node.visibility_rules?.min_level !== undefined ? node.visibility_rules.min_level : ''}"
                  onchange="actualizarVisibilityRules()"
                  placeholder="Nivel m√≠nimo"
                  class="w-full px-2 py-1 bg-slate-900 border border-slate-600 rounded text-white text-sm"
                >
              </div>
              <div>
                <label class="text-xs text-slate-400 block mb-1">Max Level</label>
                <input 
                  type="number" 
                  id="node-visibility-max-level" 
                  value="${node.visibility_rules?.max_level !== undefined ? node.visibility_rules.max_level : ''}"
                  onchange="actualizarVisibilityRules()"
                  placeholder="Nivel m√°ximo"
                  class="w-full px-2 py-1 bg-slate-900 border border-slate-600 rounded text-white text-sm"
                >
              </div>
              <div>
                <label class="text-xs text-slate-400 block mb-1">Flags (separados por comas)</label>
                <input 
                  type="text" 
                  id="node-visibility-flags" 
                  value="${node.visibility_rules?.flags ? node.visibility_rules.flags.join(', ') : ''}"
                  onchange="actualizarVisibilityRules()"
                  placeholder="flag1, flag2, flag3"
                  class="w-full px-2 py-1 bg-slate-900 border border-slate-600 rounded text-white text-sm"
                >
              </div>
              <div>
                <label class="text-xs text-slate-400 block mb-1">Products (separados por comas)</label>
                <input 
                  type="text" 
                  id="node-visibility-products" 
                  value="${node.visibility_rules?.products ? node.visibility_rules.products.join(', ') : ''}"
                  onchange="actualizarVisibilityRules()"
                  placeholder="producto1, producto2"
                  class="w-full px-2 py-1 bg-slate-900 border border-slate-600 rounded text-white text-sm"
                >
              </div>
            </div>
          </div>
        </details>
      </div>
    `;
  }
  
  // Actualizar propiedad del nodo
  function actualizarPropiedadNodo(prop, value) {
    if (!editorState.tree || !editorState.selectedNodeId) return;
    
    // Actualizar en tree (fuente de verdad)
    function updateNodeInTree(tree, nodeId, prop, value) {
      if (!tree || !tree.node) return false;
      
      if (tree.node.id === nodeId) {
        if (value === null || value === '' || value === undefined) {
          delete tree.node[prop];
        } else {
          tree.node[prop] = value;
        }
        return true;
      }
      
      if (tree.children) {
        for (const child of tree.children) {
          if (updateNodeInTree(child, nodeId, prop, value)) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    const updated = updateNodeInTree(editorState.tree, editorState.selectedNodeId, prop, value);
    if (!updated) return;
    
    // Reconstruir definition desde tree
    editorState.definition = buildDefinitionFromTree(editorState.tree, editorState.definition?.entry_node_id);
    
    markDirty();
    updateStatusIndicator();
    renderPreview();
  }
  
  // FASE 4.1: Actualizar tipo de navegaci√≥n
  function actualizarTipoNavegacion(type) {
    if (!editorState.definition) return;
    
    console.log('[AXE][NAV_EDITOR] actualizarTipoNavegacion:', type);
    
    editorState.definition.type = type;
    
    // Mostrar/ocultar context_key seg√∫n tipo
    const contextKeyEl = document.getElementById('navigation-context-key');
    if (contextKeyEl) {
      if (type === 'contextual') {
        contextKeyEl.style.display = 'inline-block';
        // Si no hay context_key y es contextual, mostrar warning pero no bloquear
        if (!editorState.definition.context_key) {
          console.warn('[AXE][NAV_EDITOR] actualizarTipoNavegacion: type=contextual sin context_key (warning, no bloqueo)');
        }
      } else {
        contextKeyEl.style.display = 'none';
        editorState.definition.context_key = null;
      }
    }
    
    markDirty();
    updateStatusIndicator();
    renderPreview();
  }
  
  // FASE 4.1: Actualizar context_key
  function actualizarContextKey(contextKey) {
    if (!editorState.definition) return;
    
    console.log('[AXE][NAV_EDITOR] actualizarContextKey:', contextKey);
    
    const trimmedKey = contextKey?.trim() || null;
    editorState.definition.context_key = trimmedKey;
    
    markDirty();
    updateStatusIndicator();
    renderPreview();
  }
  
  // FASE 4.3: Actualizar reglas de visibilidad
  function actualizarVisibilityRules() {
    if (!editorState.tree || !editorState.selectedNodeId) return;
    
    console.log('[AXE][NAV_EDITOR] actualizarVisibilityRules');
    
    const minLevelEl = document.getElementById('node-visibility-min-level');
    const maxLevelEl = document.getElementById('node-visibility-max-level');
    const flagsEl = document.getElementById('node-visibility-flags');
    const productsEl = document.getElementById('node-visibility-products');
    
    const rules = {};
    
    if (minLevelEl && minLevelEl.value) {
      const minLevel = parseInt(minLevelEl.value);
      if (!isNaN(minLevel)) {
        rules.min_level = minLevel;
      }
    }
    
    if (maxLevelEl && maxLevelEl.value) {
      const maxLevel = parseInt(maxLevelEl.value);
      if (!isNaN(maxLevel)) {
        rules.max_level = maxLevel;
      }
    }
    
    if (flagsEl && flagsEl.value) {
      rules.flags = flagsEl.value.split(',').map(f => f.trim()).filter(f => f);
    }
    
    if (productsEl && productsEl.value) {
      rules.products = productsEl.value.split(',').map(p => p.trim()).filter(p => p);
    }
    
    // Validar JSON (solo estructura, no evaluaci√≥n)
    try {
      JSON.stringify(rules);
    } catch (error) {
      console.error('[AXE][NAV_EDITOR] actualizarVisibilityRules: JSON inv√°lido', error);
      alert('‚ö†Ô∏è Error: Las reglas de visibilidad no son v√°lidas');
      return;
    }
    
    // Actualizar en tree (fuente de verdad)
    function updateVisibilityRulesInTree(tree, nodeId, rules) {
      if (!tree || !tree.node) return false;
      
      if (tree.node.id === nodeId) {
        if (Object.keys(rules).length === 0) {
          delete tree.node.visibility_rules;
        } else {
          tree.node.visibility_rules = rules;
        }
        return true;
      }
      
      if (tree.children) {
        for (const child of tree.children) {
          if (updateVisibilityRulesInTree(child, nodeId, rules)) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    const updated = updateVisibilityRulesInTree(editorState.tree, editorState.selectedNodeId, rules);
    if (!updated) return;
    
    // Reconstruir definition desde tree
    editorState.definition = buildDefinitionFromTree(editorState.tree, editorState.definition?.entry_node_id);
    
    markDirty();
    updateStatusIndicator();
    renderPreview();
  }
  
  // Actualizar target del nodo
  function actualizarTargetNodo(prop, value) {
    if (!editorState.tree || !editorState.selectedNodeId) return;
    
    // Actualizar en tree (fuente de verdad)
    function updateTargetInTree(tree, nodeId, prop, value) {
      if (!tree || !tree.node) return false;
      
      if (tree.node.id === nodeId) {
        if (!tree.node.target) {
          tree.node.target = {};
        }
        
        if (value === null || value === '' || value === undefined) {
          delete tree.node.target[prop];
          if (Object.keys(tree.node.target).length === 0) {
            delete tree.node.target;
          }
        } else {
          tree.node.target[prop] = value;
        }
        return true;
      }
      
      if (tree.children) {
        for (const child of tree.children) {
          if (updateTargetInTree(child, nodeId, prop, value)) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    const updated = updateTargetInTree(editorState.tree, editorState.selectedNodeId, prop, value);
    if (!updated) return;
    
    // Reconstruir definition desde tree
    editorState.definition = buildDefinitionFromTree(editorState.tree, editorState.definition?.entry_node_id);
    
    markDirty();
    updateStatusIndicator();
    renderPreview();
  }
  
  // Renderizar preview (actualiza todas las vistas)
  function renderPreview() {
    if (!editorState.definition) return;
    
    const json = JSON.stringify(editorState.definition, null, 2);
    
    // Actualizar preview en vista Mapa
    const previewEl = document.getElementById('preview-json');
    if (previewEl) previewEl.textContent = json;
    
    // Actualizar preview en vista √Årbol
    const previewElArbol = document.getElementById('preview-json-arbol');
    if (previewElArbol) previewElArbol.textContent = json;
    
    // Actualizar vista JSON completa si est√° activa
    if (editorState.currentView === 'json') {
      renderJSONView();
    }
  }
  
  // A√±adir nodo
  function a√±adirNodo() {
    const nodeId = prompt('ID del nuevo nodo:');
    if (!nodeId || !nodeId.trim()) return;
    
    // Verificar que no existe en definition
    if (editorState.definition?.nodes?.[nodeId.trim()]) {
      showToast('Ya existe un nodo con ese ID', 'error');
      return;
    }
    
    // Crear nuevo nodo en tree
    const newNode = {
      node: {
        id: nodeId.trim(),
        kind: 'item',
        label: nodeId.trim()
      },
      children: []
    };
    
    // Si no hay tree, crear uno nuevo
    if (!editorState.tree) {
      editorState.tree = newNode;
      if (!editorState.definition) {
        editorState.definition = { nodes: {}, edges: [] };
      }
      editorState.definition.entry_node_id = nodeId.trim();
    } else {
      // A√±adir como hijo del nodo seleccionado o del root
      const parentId = editorState.selectedNodeId || editorState.definition?.entry_node_id;
      if (parentId) {
        function addToTree(tree, parentId, newNode) {
          if (!tree || !tree.node) return false;
          
          if (tree.node.id === parentId) {
            if (!tree.children) {
              tree.children = [];
            }
            tree.children.push(newNode);
            return true;
          }
          
          if (tree.children) {
            for (const child of tree.children) {
              if (addToTree(child, parentId, newNode)) {
                return true;
              }
            }
          }
          
          return false;
        }
        
        addToTree(editorState.tree, parentId, newNode);
      } else {
        // Si no hay selecci√≥n, a√±adir al root
        if (!editorState.tree.children) {
          editorState.tree.children = [];
        }
        editorState.tree.children.push(newNode);
      }
    }
    
    // Reconstruir definition desde tree
    editorState.definition = buildDefinitionFromTree(editorState.tree, editorState.definition?.entry_node_id);
    
    // Asignar posici√≥n autom√°tica al nuevo nodo si no existe
    if (editorState.definition.nodes[nodeId.trim()] && !editorState.definition.nodes[nodeId.trim()].position) {
      // Generar posiciones para todos los nodos (incluyendo el nuevo)
      const positions = generateNodePositions(editorState.definition);
      if (positions[nodeId.trim()]) {
        editorState.definition.nodes[nodeId.trim()].position = positions[nodeId.trim()];
      }
    }
    
    markDirty();
    actualizarUI();
    // Seleccionar en canvas si estamos en vista mapa
    if (editorState.currentView === 'mapa') {
      seleccionarNodoCanvasNav(nodeId.trim());
    } else {
      seleccionarNodo(nodeId.trim());
    }
  }
  
  // Eliminar nodo
  function eliminarNodo(nodeId) {
    if (!confirm(`¬øEliminar el nodo "${nodeId}"?`)) return;
    
    if (!editorState.tree) return;
    
    // Prohibir eliminar root
    if (nodeId === editorState.definition?.entry_node_id) {
      showToast('‚ö†Ô∏è No se puede eliminar el nodo ra√≠z', 'error');
      return;
    }
    
    // Eliminar del tree
    function removeFromTree(tree, targetId) {
      if (!tree || !tree.node) return false;
      
      if (tree.children) {
        for (let i = 0; i < tree.children.length; i++) {
          if (tree.children[i].node.id === targetId) {
            tree.children.splice(i, 1);
            return true;
          }
          if (removeFromTree(tree.children[i], targetId)) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    const removed = removeFromTree(editorState.tree, nodeId);
    if (!removed) {
      showToast('No se pudo eliminar el nodo', 'error');
      return;
    }
    
    // Reconstruir definition desde tree
    editorState.definition = buildDefinitionFromTree(editorState.tree, editorState.definition?.entry_node_id);
    
    editorState.selectedNodeId = null;
    markDirty();
    actualizarUI();
  }
  
  // Guardar navegaci√≥n (asegura que edges est√©n sincronizados y posiciones del canvas)
  async function guardarNavegacion() {
    if (!editorState.definition || !editorState.navigationId) return;
    
    editorState.isSaving = true;
    updateStatusIndicator();
    
    try {
      // Sincronizar posiciones del canvas al definition antes de guardar
      if (editorState.currentView === 'mapa') {
        syncCanvasPositionsToDefinition();
      }
      
      // Asegurar que la definici√≥n est√© normalizada
      // Si estamos en vista √°rbol/mapa, los edges ya deber√≠an estar actualizados
      // Pero por si acaso, validar estructura b√°sica
      if (!editorState.definition.nodes) {
        editorState.definition.nodes = {};
      }
      if (!editorState.definition.edges) {
        editorState.definition.edges = [];
      }
      if (!editorState.definition.entry_node_id && Object.keys(editorState.definition.nodes).length > 0) {
        editorState.definition.entry_node_id = Object.keys(editorState.definition.nodes)[0];
      }
      
      const encodedId = encodeURIComponent(editorState.navigationId);
      const response = await fetch(`/admin/api/navigation/${encodedId}/draft`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          draft_json: editorState.definition,
          name: editorState.definition.name || editorState.navigationId
        })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || `Error ${response.status}`);
      }
      
      const data = await response.json();
      if (!data.ok || !data.data) {
        throw new Error('Respuesta inv√°lida del servidor');
      }
      
      editorState.dirty = false;
      editorState.isSaving = false;
      editorState.lastSavedAt = new Date();
      updateStatusIndicator();
      updateDirtyBadge();
      
      const timestamp = editorState.lastSavedAt.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      showToast(`‚úÖ Guardado ‚úì ${timestamp}`, 'success');
    } catch (error) {
      console.error('Error guardando navegaci√≥n:', error);
      editorState.isSaving = false;
      updateStatusIndicator();
      alert(`Error guardando navegaci√≥n: ${error.message}`);
    }
  }
  
  // Validar navegaci√≥n
  async function validarNavegacion() {
    if (!editorState.definition || !editorState.navigationId) {
      showToast('No hay navegaci√≥n para validar', 'error');
      return false;
    }
    
    try {
      const encodedId = encodeURIComponent(editorState.navigationId);
      const response = await fetch(`/admin/api/navigation/${encodedId}/validate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          draft_json: editorState.definition
        })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || `Error ${response.status}`);
      }
      
      const data = await response.json();
      if (!data.ok || !data.data) {
        throw new Error('Respuesta inv√°lida del servidor');
      }
      
      editorState.valid = data.data.ok;
      editorState.validationErrors = data.data.errors || [];
      editorState.validationWarnings = data.data.warnings || [];
      
      // Mostrar mensajes de validaci√≥n
      const messagesEl = document.getElementById('validation-messages');
      if (messagesEl) {
        let html = '';
        
        if (editorState.validationErrors.length > 0) {
          html += `<div class="text-red-400 text-sm font-semibold">‚ùå Errores: ${editorState.validationErrors.length}</div>`;
          editorState.validationErrors.forEach(err => {
            html += `<div class="text-red-300 text-xs ml-4 mt-1">‚Ä¢ ${err}</div>`;
          });
        }
        
        if (editorState.validationWarnings.length > 0) {
          html += `<div class="text-yellow-400 text-sm font-semibold mt-2">‚ö†Ô∏è Advertencias: ${editorState.validationWarnings.length}</div>`;
          editorState.validationWarnings.forEach(warn => {
            html += `<div class="text-yellow-300 text-xs ml-4 mt-1">‚Ä¢ ${warn}</div>`;
          });
        }
        
        if (editorState.valid && editorState.validationErrors.length === 0) {
          html = '<div class="text-green-400 text-sm font-semibold">‚úÖ Navegaci√≥n v√°lida</div>';
        }
        
        messagesEl.innerHTML = html;
      }
      
      updateStatusIndicator();
      return true;
    } catch (error) {
      console.error('Error validando navegaci√≥n:', error);
      showToast(`Error validando navegaci√≥n: ${error.message}`, 'error');
      return false;
    }
  }
  
  // Publicar navegaci√≥n (con validaci√≥n previa)
  async function publicarNavegacion() {
    if (!editorState.definition || !editorState.navigationId) return;
    
    // Primero validar
    const validationResult = await validarNavegacion();
    if (!validationResult) {
      return; // validarNavegacion ya mostr√≥ el error
    }
    
    // Si hay errores, no permitir publicar
    if (editorState.validationErrors && editorState.validationErrors.length > 0) {
      showToast('‚ùå No se puede publicar: hay errores de validaci√≥n. Corr√≠gelos antes de publicar.', 'error');
      return;
    }
    
    // Si hay warnings, mostrar confirmaci√≥n
    if (editorState.validationWarnings && editorState.validationWarnings.length > 0) {
      const warningsText = editorState.validationWarnings.slice(0, 3).join('\n‚Ä¢ ');
      const moreWarnings = editorState.validationWarnings.length > 3 ? `\n... y ${editorState.validationWarnings.length - 3} m√°s` : '';
      if (!confirm(`‚ö†Ô∏è Hay ${editorState.validationWarnings.length} advertencia(s):\n\n‚Ä¢ ${warningsText}${moreWarnings}\n\n¬øContinuar con la publicaci√≥n?`)) {
        return;
      }
    } else {
      if (!confirm('¬øPublicar esta versi√≥n de la navegaci√≥n? Esto crear√° una nueva versi√≥n publicada.')) {
        return;
      }
    }
    
    // Primero guardar el draft
    await guardarNavegacion();
    
    try {
      const encodedId = encodeURIComponent(editorState.navigationId);
      const response = await fetch(`/admin/api/navigation/${encodedId}/publish`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || `Error ${response.status}`);
      }
      
      const data = await response.json();
      if (!data.ok || !data.data) {
        throw new Error('Respuesta inv√°lida del servidor');
      }
      
      showToast(`‚úÖ Navegaci√≥n publicada como versi√≥n ${data.data.version}`, 'success');
      
      // Recargar para obtener la nueva versi√≥n
      await cargarNavegacion();
    } catch (error) {
      console.error('Error publicando navegaci√≥n:', error);
      showToast(`Error publicando navegaci√≥n: ${error.message}`, 'error');
    }
  }
  
  // Exportar navegaci√≥n
  async function exportarNavegacion() {
    if (!editorState.navigationId) return;
    
    try {
      const encodedId = encodeURIComponent(editorState.navigationId);
      const response = await fetch(`/admin/api/navigation/${encodedId}/export`, {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || `Error ${response.status}`);
      }
      
      const data = await response.json();
      if (!data.ok || !data.data) {
        throw new Error('Respuesta inv√°lida del servidor');
      }
      
      // Descargar como archivo JSON
      const blob = new Blob([JSON.stringify(data.data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `navigation-${editorState.navigationId}-v${data.data.version || 'draft'}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Error exportando navegaci√≥n:', error);
      alert(`Error al exportar navegaci√≥n: ${error.message}`);
    }
  }
  
  // Actualizar indicador de estado
  function updateStatusIndicator() {
    const statusEl = document.getElementById('navigation-status');
    if (!statusEl) return;
    
    if (editorState.isSaving) {
      statusEl.textContent = 'üíæ Guardando...';
      statusEl.className = 'px-2 py-1 bg-blue-900 text-blue-200 rounded text-xs';
    } else if (editorState.dirty) {
      statusEl.textContent = '‚óè Cambios sin guardar';
      statusEl.className = 'px-2 py-1 bg-yellow-900 text-yellow-200 rounded text-xs';
    } else {
      if (editorState.lastSavedAt) {
        const timeStr = editorState.lastSavedAt.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
        statusEl.textContent = `‚úì Guardado ${timeStr}`;
      } else {
        statusEl.textContent = '‚úì Guardado';
      }
      statusEl.className = 'px-2 py-1 bg-green-900 text-green-200 rounded text-xs';
    }
  }
  
  // Assert consistency (solo en dev mode)
  function assertConsistency() {
    if (process?.env?.NODE_ENV === 'production') return; // Solo en dev
    
    if (!editorState.tree || !editorState.definition) return;
    
    // Reconstruir tree desde definition
    const rebuiltTree = buildTreeFromDefinition(editorState.definition);
    
    // Comparar estructura (ids y jerarqu√≠a)
    function compareTrees(tree1, tree2) {
      if (!tree1 && !tree2) return true;
      if (!tree1 || !tree2) return false;
      
      if (tree1.node?.id !== tree2.node?.id) return false;
      
      const children1 = tree1.children || [];
      const children2 = tree2.children || [];
      
      if (children1.length !== children2.length) return false;
      
      for (let i = 0; i < children1.length; i++) {
        if (!compareTrees(children1[i], children2[i])) return false;
      }
      
      return true;
    }
    
    const isConsistent = compareTrees(editorState.tree, rebuiltTree);
    
    if (!isConsistent) {
      console.warn('[NavigationEditor] Inconsistencia detectada entre tree y definition', {
        tree: editorState.tree,
        rebuiltTree: rebuiltTree,
        definition: editorState.definition
      });
    }
  }
  
  // ========================================================================
  // MOTOR VISUAL AXE - PORTADO DESDE EDITOR DE RECORRIDOS
  // ========================================================================
  
  // Inicializar estado visual del canvas (AXE)
  if (!window.canvasVisualStateNav) {
    window.canvasVisualStateNav = {
      panX: 0,
      panY: 0,
      zoom: 1,
      isDragging: false,
      dragStartX: 0,
      dragStartY: 0,
      dragNodeId: null,
      dragOffsetX: 0,
      dragOffsetY: 0,
      isPanning: false,
      panStartX: 0,
      panStartY: 0,
      snappingEnabled: false,
      snapGrid: 20
    };
  }
  
  // Estado de selecci√≥n
  if (!window.canvasSelectionStateNav) {
    window.canvasSelectionStateNav = { selectedNodeId: null };
  }
  
  /**
   * Adaptador: NavigationDefinition ‚Üí CanvasDefinition (AXE)
   */
  function navigationDefinitionToCanvas(navDef) {
    if (!navDef || !navDef.nodes) {
      return { nodes: [], edges: [] };
    }
    
    const canvas = {
      nodes: [],
      edges: []
    };
    
    // Convertir nodos
    const nodePositions = generateNodePositions(navDef);
    
    Object.keys(navDef.nodes).forEach(nodeId => {
      const node = navDef.nodes[nodeId];
      const pos = nodePositions[nodeId] || { x: 0, y: 0 };
      
      canvas.nodes.push({
        id: nodeId,
        type: mapKindToType(node.kind || 'item'),
        label: node.label || nodeId,
        position: { x: pos.x, y: pos.y },
        kind: node.kind,
        subtitle: node.subtitle,
        icon: node.icon,
        target: node.target,
        visibility: node.visibility
      });
    });
    
    // Convertir edges
    (navDef.edges || []).forEach(edge => {
      canvas.edges.push({
        from_node_id: edge.from,
        to_node_id: edge.to,
        type: edge.kind || 'child',
        order: edge.order || 0
      });
    });
    
    return canvas;
  }
  
  /**
   * Adaptador: CanvasDefinition ‚Üí NavigationDefinition
   */
  function canvasToNavigationDefinition(canvas, originalNavDef) {
    if (!canvas || !canvas.nodes) {
      return originalNavDef || { nodes: {}, edges: [], entry_node_id: null };
    }
    
    const navDef = {
      nodes: {},
      edges: [],
      entry_node_id: originalNavDef?.entry_node_id || null
    };
    
    // Convertir nodos
    canvas.nodes.forEach(node => {
      navDef.nodes[node.id] = {
        id: node.id,
        kind: node.kind || mapTypeToKind(node.type || 'item'),
        label: node.label || node.id,
        subtitle: node.subtitle,
        icon: node.icon,
        target: node.target,
        visibility: node.visibility,
        position: node.position // Guardar posici√≥n para siguiente conversi√≥n
      };
    });
    
    // Convertir edges
    (canvas.edges || []).forEach(edge => {
      navDef.edges.push({
        from: edge.from_node_id,
        to: edge.to_node_id,
        kind: edge.type || 'child',
        order: edge.order || 0
      });
    });
    
    return navDef;
  }
  
  /**
   * Mapea kind (NavigationDefinition) ‚Üí type (CanvasDefinition)
   */
  function mapKindToType(kind) {
    const mapping = {
      'section': 'section',
      'group': 'group',
      'item': 'item',
      'hub': 'hub',
      'external_link': 'external',
      'system_entry': 'start'
    };
    return mapping[kind] || 'item';
  }
  
  /**
   * Mapea type (CanvasDefinition) ‚Üí kind (NavigationDefinition)
   */
  function mapTypeToKind(type) {
    const mapping = {
      'section': 'section',
      'group': 'group',
      'item': 'item',
      'hub': 'hub',
      'external': 'external_link',
      'start': 'system_entry'
    };
    return mapping[type] || 'item';
  }
  
  /**
   * Genera posiciones autom√°ticas basadas en el √°rbol jer√°rquico
   */
  function generateNodePositions(navDef) {
    const positions = {};
    const nodes = navDef.nodes || {};
    const edges = navDef.edges || [];
    const entryNodeId = navDef.entry_node_id;
    
    // Construir √°rbol de hijos
    const childrenMap = {};
    edges.forEach(edge => {
      if (edge.kind === 'child' || !edge.kind) {
        if (!childrenMap[edge.from]) {
          childrenMap[edge.from] = [];
        }
        childrenMap[edge.from].push({
          nodeId: edge.to,
          order: edge.order || 0
        });
      }
    });
    
    // Ordenar hijos
    Object.keys(childrenMap).forEach(parentId => {
      childrenMap[parentId].sort((a, b) => (a.order || 0) - (b.order || 0));
    });
    
    // Layout autom√°tico: √°rbol horizontal
    const NODE_WIDTH = 180;
    const NODE_HEIGHT = 100;
    const HORIZONTAL_SPACING = 250;
    const VERTICAL_SPACING = 150;
    
    function layoutNode(nodeId, x, y, visited = new Set()) {
      if (visited.has(nodeId) || !nodes[nodeId]) return;
      visited.add(nodeId);
      
      positions[nodeId] = { x, y };
      
      const children = childrenMap[nodeId] || [];
      let childY = y;
      
      children.forEach((child, idx) => {
        const childX = x + HORIZONTAL_SPACING;
        layoutNode(child.nodeId, childX, childY, new Set(visited));
        childY += VERTICAL_SPACING;
      });
    }
    
    // Empezar desde entry_node_id o primer nodo
    const rootId = entryNodeId || Object.keys(nodes)[0];
    if (rootId) {
      layoutNode(rootId, 50, 50, new Set());
    }
    
    return positions;
  }
  
  /**
   * Renderiza el canvas viewer con motor visual AXE
   */
  function renderCanvasViewerNav(canvas) {
    const container = document.getElementById('canvas-nodes-container-nav');
    if (!container || !canvas) return;
    
    const selectedNodeId = window.canvasSelectionStateNav?.selectedNodeId ?? null;
    
    let html = '';
    
    // Renderizar nodos
    for (const node of canvas.nodes || []) {
      const pos = node.position || { x: 0, y: 0 };
      const isSelected = selectedNodeId === node.id;
      
      // Badge de tipo
      let typeBadge = '';
      let nodeColor = 'bg-slate-700';
      if (node.type === 'start' || node.kind === 'system_entry') {
        typeBadge = '<span class="px-1.5 py-0.5 bg-green-600 text-white text-xs rounded">START</span>';
        nodeColor = 'bg-green-700';
      } else if (node.type === 'section' || node.kind === 'section') {
        typeBadge = '<span class="px-1.5 py-0.5 bg-blue-600 text-white text-xs rounded">SECTION</span>';
        nodeColor = 'bg-blue-700';
      } else if (node.type === 'hub' || node.kind === 'hub') {
        typeBadge = '<span class="px-1.5 py-0.5 bg-purple-600 text-white text-xs rounded">HUB</span>';
        nodeColor = 'bg-purple-700';
      }
      
      const borderClass = isSelected 
        ? 'border-2 border-indigo-400 shadow-lg shadow-indigo-500/50' 
        : 'border border-slate-600';
      
      html += `
        <div 
          id="node-nav-${node.id}"
          data-node-id="${node.id}"
          class="absolute ${nodeColor} ${borderClass} rounded-lg p-3 min-w-[120px] cursor-move select-none"
          style="left: ${pos.x}px; top: ${pos.y}px; z-index: 10;"
          onmousedown="handleNodeMouseDownNav(event, '${node.id}')"
          onclick="handleNodeClickNav(event, '${node.id}')"
        >
          <div class="flex items-center justify-between gap-2 mb-1">
            <div class="text-white font-semibold text-sm truncate">${(node.label || node.id).replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
            ${typeBadge}
          </div>
          <div class="text-slate-300 text-xs">${(node.kind || node.type || 'item').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
          ${node.subtitle ? `<div class="text-slate-200 text-xs mt-1 truncate">${(node.subtitle || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>` : ''}
        </div>
      `;
    }
    
    container.innerHTML = html;
    
    // Renderizar edges despu√©s
    setTimeout(() => {
      renderCanvasEdgesNav(canvas);
    }, 0);
  }
  
  /**
   * Renderiza edges como l√≠neas SVG
   */
  function renderCanvasEdgesNav(canvas) {
    const svg = document.getElementById('canvas-edges-svg-nav');
    if (!svg || !canvas) return;
    
    svg.innerHTML = '';
    
    const container = document.getElementById('canvas-visual-container-nav');
    if (!container) return;
    
    const containerRect = container.getBoundingClientRect();
    svg.setAttribute('width', containerRect.width);
    svg.setAttribute('height', containerRect.height);
    
    // Agregar defs con marcador de flecha
    let defs = svg.querySelector('defs');
    if (!defs) {
      defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead-nav');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '10');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3, 0 6');
      polygon.setAttribute('fill', '#64748b');
      
      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.appendChild(defs);
    }
    
    // Renderizar cada edge
    for (const edge of canvas.edges || []) {
      const fromNodeEl = document.getElementById(`node-nav-${edge.from_node_id}`);
      const toNodeEl = document.getElementById(`node-nav-${edge.to_node_id}`);
      
      if (!fromNodeEl || !toNodeEl) continue;
      
      const fromRect = fromNodeEl.getBoundingClientRect();
      const toRect = toNodeEl.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      
      const fromCenterX = fromRect.left - containerRect.left + fromRect.width / 2;
      const fromCenterY = fromRect.top - containerRect.top + fromRect.height / 2;
      const toCenterX = toRect.left - containerRect.left + toRect.width / 2;
      const toCenterY = toRect.top - containerRect.top + toRect.height / 2;
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', fromCenterX);
      line.setAttribute('y1', fromCenterY);
      line.setAttribute('x2', toCenterX);
      line.setAttribute('y2', toCenterY);
      line.setAttribute('stroke', '#64748b');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('marker-end', 'url(#arrowhead-nav)');
      
      svg.appendChild(line);
    }
  }
  
  /**
   * Handlers de interacci√≥n del canvas (AXE)
   */
  function handleNodeMouseDownNav(event, nodeId) {
    event.stopPropagation();
    
    if (!window.canvasVisualStateNav) {
      window.canvasVisualStateNav = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    const nodeEl = document.getElementById(`node-nav-${nodeId}`);
    if (!nodeEl) return;
    
    const container = document.getElementById('canvas-visual-container-nav');
    if (!container) return;
    const containerRect = container.getBoundingClientRect();
    
    window.canvasVisualStateNav.isDragging = true;
    window.canvasVisualStateNav.dragNodeId = nodeId;
    window.canvasVisualStateNav.dragStartX = event.clientX;
    window.canvasVisualStateNav.dragStartY = event.clientY;
    
    const panX = window.canvasVisualStateNav.panX || 0;
    const panY = window.canvasVisualStateNav.panY || 0;
    const zoom = window.canvasVisualStateNav.zoom || 1;
    
    const nodePos = nodeEl.style.left ? parseInt(nodeEl.style.left) : 0;
    const nodeTop = nodeEl.style.top ? parseInt(nodeEl.style.top) : 0;
    
    window.canvasVisualStateNav.dragOffsetX = (event.clientX - containerRect.left - panX) / zoom - nodePos;
    window.canvasVisualStateNav.dragOffsetY = (event.clientY - containerRect.top - panY) / zoom - nodeTop;
    
    container.style.cursor = 'grabbing';
    nodeEl.style.cursor = 'grabbing';
  }
  
  function handleCanvasMouseMoveNav(event) {
    if (!window.canvasVisualStateNav) return;
    
    // Si se est√° arrastrando un nodo
    if (window.canvasVisualStateNav.isDragging && window.canvasVisualStateNav.dragNodeId) {
      const container = document.getElementById('canvas-visual-container-nav');
      if (!container) return;
      const containerRect = container.getBoundingClientRect();
      
      const panX = window.canvasVisualStateNav.panX || 0;
      const panY = window.canvasVisualStateNav.panY || 0;
      const zoom = window.canvasVisualStateNav.zoom || 1;
      
      let newX = (event.clientX - containerRect.left - panX) / zoom - window.canvasVisualStateNav.dragOffsetX;
      let newY = (event.clientY - containerRect.top - panY) / zoom - window.canvasVisualStateNav.dragOffsetY;
      
      // Aplicar snapping
      newX = applySnappingNav(newX);
      newY = applySnappingNav(newY);
      
      newX = Math.max(0, newX);
      newY = Math.max(0, newY);
      
      const nodeEl = document.getElementById(`node-nav-${window.canvasVisualStateNav.dragNodeId}`);
      if (nodeEl) {
        nodeEl.style.left = `${newX}px`;
        nodeEl.style.top = `${newY}px`;
        
        // Actualizar edges en tiempo real
        const canvas = navigationDefinitionToCanvas(editorState.definition);
        renderCanvasEdgesNav(canvas);
      }
    }
    // Si se est√° haciendo pan del canvas
    else if (window.canvasVisualStateNav.isPanning) {
      window.canvasVisualStateNav.panX = event.clientX - window.canvasVisualStateNav.panStartX;
      window.canvasVisualStateNav.panY = event.clientY - window.canvasVisualStateNav.panStartY;
      
      const container = document.getElementById('canvas-nodes-container-nav');
      if (container) {
        const panX = window.canvasVisualStateNav.panX || 0;
        const panY = window.canvasVisualStateNav.panY || 0;
        const zoom = window.canvasVisualStateNav.zoom || 1;
        container.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
      }
      
      const canvas = navigationDefinitionToCanvas(editorState.definition);
      renderCanvasEdgesNav(canvas);
    }
  }
  
  function handleCanvasMouseUpNav(event) {
    if (!window.canvasVisualStateNav) return;
    
    const container = document.getElementById('canvas-visual-container-nav');
    if (container) {
      container.style.cursor = 'grab';
    }
    
    // Si se estaba arrastrando un nodo
    if (window.canvasVisualStateNav.isDragging && window.canvasVisualStateNav.dragNodeId) {
      const nodeEl = document.getElementById(`node-nav-${window.canvasVisualStateNav.dragNodeId}`);
      if (nodeEl) {
        nodeEl.style.cursor = 'move';
      }
      
      // Actualizar posici√≥n en definition
      updateNodePositionInNavDefinition(window.canvasVisualStateNav.dragNodeId);
      
      window.canvasVisualStateNav.isDragging = false;
      window.canvasVisualStateNav.dragNodeId = null;
    }
    
    // Si se estaba haciendo pan
    if (window.canvasVisualStateNav.isPanning) {
      window.canvasVisualStateNav.isPanning = false;
    }
  }
  
  function handleCanvasMouseDownNav(event) {
    if (event.target.id && event.target.id.startsWith('node-nav-')) {
      return;
    }
    
    if (!window.canvasVisualStateNav) {
      window.canvasVisualStateNav = { panX: 0, panY: 0, zoom: 1 };
    }
    
    window.canvasVisualStateNav.isPanning = true;
    window.canvasVisualStateNav.panStartX = event.clientX - window.canvasVisualStateNav.panX;
    window.canvasVisualStateNav.panStartY = event.clientY - window.canvasVisualStateNav.panY;
  }
  
  function handleCanvasWheelNav(event) {
    if (!event.altKey) return;
    
    event.preventDefault();
    event.stopPropagation();
    
    if (!window.canvasVisualStateNav) {
      window.canvasVisualStateNav = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    const delta = event.deltaY > 0 ? 0.9 : 1.1;
    window.canvasVisualStateNav.zoom = Math.max(0.3, Math.min(3, window.canvasVisualStateNav.zoom * delta));
    
    updateZoomDisplayNav();
    
    const container = document.getElementById('canvas-nodes-container-nav');
    if (container) {
      const panX = window.canvasVisualStateNav.panX || 0;
      const panY = window.canvasVisualStateNav.panY || 0;
      const zoom = window.canvasVisualStateNav.zoom || 1;
      container.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
    }
    
    const canvas = navigationDefinitionToCanvas(editorState.definition);
    renderCanvasEdgesNav(canvas);
  }
  
  function handleNodeClickNav(event, nodeId) {
    if (window.canvasVisualStateNav && window.canvasVisualStateNav.isDragging) {
      return;
    }
    
    event.stopPropagation();
    seleccionarNodoCanvasNav(nodeId);
  }
  
  function seleccionarNodoCanvasNav(nodeId) {
    if (!window.canvasSelectionStateNav) {
      window.canvasSelectionStateNav = { selectedNodeId: null };
    }
    window.canvasSelectionStateNav.selectedNodeId = nodeId;
    
    // Actualizar canvas
    const canvas = navigationDefinitionToCanvas(editorState.definition);
    renderCanvasViewerNav(canvas);
    
    // Actualizar panel de propiedades
    renderNodeProperties(nodeId);
  }
  
  function updateNodePositionInNavDefinition(nodeId) {
    const nodeEl = document.getElementById(`node-nav-${nodeId}`);
    if (!nodeEl || !editorState.definition) return;
    
    const x = parseInt(nodeEl.style.left) || 0;
    const y = parseInt(nodeEl.style.top) || 0;
    
    // Guardar posici√≥n en el nodo (para preservarla en conversiones)
    if (editorState.definition.nodes[nodeId]) {
      if (!editorState.definition.nodes[nodeId].position) {
        editorState.definition.nodes[nodeId].position = { x: 0, y: 0 };
      }
      editorState.definition.nodes[nodeId].position.x = x;
      editorState.definition.nodes[nodeId].position.y = y;
    }
    
    markDirty();
    renderPreview();
  }
  
  function toggleSnappingNav() {
    if (!window.canvasVisualStateNav) {
      window.canvasVisualStateNav = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    window.canvasVisualStateNav.snappingEnabled = !window.canvasVisualStateNav.snappingEnabled;
    
    const snapBtn = document.getElementById('snap-toggle-btn-nav');
    if (snapBtn) {
      snapBtn.textContent = `üìê Snap: ${window.canvasVisualStateNav.snappingEnabled ? 'ON' : 'OFF'}`;
      snapBtn.classList.toggle('bg-indigo-600', window.canvasVisualStateNav.snappingEnabled);
    }
  }
  
  function applySnappingNav(value) {
    if (!window.canvasVisualStateNav || !window.canvasVisualStateNav.snappingEnabled) {
      return value;
    }
    const grid = window.canvasVisualStateNav.snapGrid || 20;
    return Math.round(value / grid) * grid;
  }
  
  function resetCanvasViewNav() {
    if (!window.canvasVisualStateNav) {
      window.canvasVisualStateNav = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    window.canvasVisualStateNav.panX = 0;
    window.canvasVisualStateNav.panY = 0;
    window.canvasVisualStateNav.zoom = 1;
    updateZoomDisplayNav();
    
    const container = document.getElementById('canvas-nodes-container-nav');
    if (container) {
      container.style.transform = 'translate(0px, 0px) scale(1)';
    }
    
    const canvas = navigationDefinitionToCanvas(editorState.definition);
    renderCanvasEdgesNav(canvas);
  }
  
  function zoomInCanvasNav() {
    if (!window.canvasVisualStateNav) {
      window.canvasVisualStateNav = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    window.canvasVisualStateNav.zoom = Math.min(3, (window.canvasVisualStateNav.zoom || 1) * 1.2);
    updateZoomDisplayNav();
    
    const container = document.getElementById('canvas-nodes-container-nav');
    if (container) {
      const panX = window.canvasVisualStateNav.panX || 0;
      const panY = window.canvasVisualStateNav.panY || 0;
      const zoom = window.canvasVisualStateNav.zoom || 1;
      container.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
    }
    
    const canvas = navigationDefinitionToCanvas(editorState.definition);
    renderCanvasEdgesNav(canvas);
  }
  
  function zoomOutCanvasNav() {
    if (!window.canvasVisualStateNav) {
      window.canvasVisualStateNav = { panX: 0, panY: 0, zoom: 1, snappingEnabled: false, snapGrid: 20 };
    }
    
    window.canvasVisualStateNav.zoom = Math.max(0.3, (window.canvasVisualStateNav.zoom || 1) * 0.8);
    updateZoomDisplayNav();
    
    const container = document.getElementById('canvas-nodes-container-nav');
    if (container) {
      const panX = window.canvasVisualStateNav.panX || 0;
      const panY = window.canvasVisualStateNav.panY || 0;
      const zoom = window.canvasVisualStateNav.zoom || 1;
      container.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
    }
    
    const canvas = navigationDefinitionToCanvas(editorState.definition);
    renderCanvasEdgesNav(canvas);
  }
  
  function updateZoomDisplayNav() {
    const zoomLevel = document.getElementById('zoom-level-nav');
    if (zoomLevel && window.canvasVisualStateNav) {
      const zoom = Math.round((window.canvasVisualStateNav.zoom || 1) * 100);
      zoomLevel.textContent = `${zoom}%`;
    }
  }
  
  /**
   * Sincroniza todas las posiciones del canvas al definition (antes de guardar)
   */
  function syncCanvasPositionsToDefinition() {
    if (!editorState.definition || !editorState.definition.nodes) return;
    
    // Actualizar posiciones de todos los nodos desde el DOM
    Object.keys(editorState.definition.nodes).forEach(nodeId => {
      const nodeEl = document.getElementById(`node-nav-${nodeId}`);
      if (nodeEl) {
        const x = parseInt(nodeEl.style.left) || 0;
        const y = parseInt(nodeEl.style.top) || 0;
        
        if (!editorState.definition.nodes[nodeId].position) {
          editorState.definition.nodes[nodeId].position = { x: 0, y: 0 };
        }
        editorState.definition.nodes[nodeId].position.x = x;
        editorState.definition.nodes[nodeId].position.y = y;
      }
    });
  }
  
  // ========================================================================
  // FIN MOTOR VISUAL AXE
  // ========================================================================
  
  // Inicializar cuando se carga la p√°gina
  document.addEventListener('DOMContentLoaded', () => {
    const editor = document.getElementById('navigation-editor');
    if (!editor) {
      console.error('[Editor] DOMContentLoaded: ERROR - Elemento #navigation-editor no encontrado');
      // Fail-open: mostrar mensaje visible
      const body = document.body;
      if (body) {
        body.innerHTML = `
          <div style="padding: 40px; background: #1e293b; color: #fca5a5; font-family: sans-serif;">
            <h1 style="color: #ef4444; margin-bottom: 20px;">‚ö†Ô∏è Error cargando editor de navegaci√≥n</h1>
            <p>No se pudo encontrar el contenedor del editor. Por favor, recarga la p√°gina.</p>
            <p style="margin-top: 20px; font-size: 0.9em; color: #94a3b8;">Si el problema persiste, verifica la consola del navegador para m√°s detalles.</p>
          </div>
        `;
      }
      return;
    }
    console.log('[Editor] DOMContentLoaded: calling initEditor()');
    initEditor().catch(err => {
      console.error('[Editor] DOMContentLoaded: ERROR in initEditor():', err);
      // Fail-open: mostrar mensaje visible
      const mapEl = document.getElementById('nodes-map');
      const treeEl = document.getElementById('nodes-tree');
      if (mapEl) mapEl.innerHTML = `<p class="text-red-400 text-sm">‚ö†Ô∏è Error inicializando editor: ${err.message}</p>`;
      if (treeEl) treeEl.innerHTML = `<p class="text-red-400 text-sm">‚ö†Ô∏è Error inicializando editor: ${err.message}</p>`;
    });
  });
  
  // ========================================================================
  // FUNCIONES DE PREVIEW EFECTIVO (FASE 5)
  // ========================================================================
  
  // Estado del preview
  let previewState = {
    effectiveDef: null,
    provenance: null,
    warnings: []
  };
  
  // Inicializar vista preview
  async function renderPreviewView() {
    console.log('[Preview] renderPreviewView start');
    
    // Cargar lista de navegaciones en selectores
    await cargarNavegacionesParaPreview();
  }
  
  // Cargar lista de navegaciones para los selectores
  async function cargarNavegacionesParaPreview() {
    try {
      const response = await fetch('/admin/api/navigation', {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });
      
      if (!response.ok) {
        console.error('[Preview] Error cargando navegaciones:', response.status);
        return;
      }
      
      const data = await response.json();
      if (!data.ok || !data.data || !Array.isArray(data.data)) {
        console.error('[Preview] Respuesta inv√°lida:', data);
        return;
      }
      
      const navigations = data.data;
      
      // Llenar selector de globales
      const globalSelect = document.getElementById('preview-global-select');
      if (globalSelect) {
        globalSelect.innerHTML = '<option value="">Seleccionar navegaci√≥n global...</option>';
        navigations
          .filter(nav => nav.type === 'global' || !nav.type) // Incluir sin tipo (legacy)
          .forEach(nav => {
            const option = document.createElement('option');
            option.value = nav.navigation_id;
            option.textContent = `${nav.name} (${nav.navigation_id})`;
            globalSelect.appendChild(option);
          });
      }
      
      // Llenar selector de contextuales (se usar√° en a√±adirContextoPreview)
      window.previewContextualNavigations = navigations.filter(nav => nav.type === 'contextual');
      
    } catch (error) {
      console.error('[Preview] Error cargando navegaciones:', error);
    }
  }
  
  // A√±adir selector de contexto
  function a√±adirContextoPreview() {
    const container = document.getElementById('preview-contexts-container');
    if (!container) return;
    
    const contextualNavigations = window.previewContextualNavigations || [];
    
    const contextDiv = document.createElement('div');
    contextDiv.className = 'flex gap-2 items-center';
    
    const select = document.createElement('select');
    select.className = 'flex-1 px-3 py-2 bg-slate-800 text-white rounded border border-slate-700';
    select.innerHTML = '<option value="">Seleccionar contexto...</option>';
    contextualNavigations.forEach(nav => {
      const option = document.createElement('option');
      option.value = nav.navigation_id;
      option.textContent = `${nav.name} (${nav.context_key || nav.navigation_id})`;
      select.appendChild(option);
    });
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'px-2 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded';
    removeBtn.textContent = '‚úï';
    removeBtn.onclick = () => contextDiv.remove();
    
    contextDiv.appendChild(select);
    contextDiv.appendChild(removeBtn);
    container.appendChild(contextDiv);
  }
  
  // Generar preview efectivo
  async function generarPreviewEfectivo() {
    const globalSelect = document.getElementById('preview-global-select');
    if (!globalSelect || !globalSelect.value) {
      alert('‚ö†Ô∏è Por favor, selecciona una navegaci√≥n global');
      return;
    }
    
    const globalNavId = globalSelect.value;
    const contextContainer = document.getElementById('preview-contexts-container');
    const contextNavIds = [];
    
    if (contextContainer) {
      const selects = contextContainer.querySelectorAll('select');
      selects.forEach(select => {
        if (select.value) {
          contextNavIds.push(select.value);
        }
      });
    }
    
    console.log('[Preview] Generando preview efectivo:', {
      global: globalNavId,
      contexts: contextNavIds
    });
    
    try {
      const response = await fetch('/admin/api/navigation/preview-effective', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          global_navigation_id: globalNavId,
          context_navigation_ids: contextNavIds
        })
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('[Preview] Error generando preview:', response.status, errorText);
        alert(`‚ùå Error generando preview: ${response.status}`);
        return;
      }
      
      const data = await response.json();
      if (!data.ok || !data.data) {
        console.error('[Preview] Respuesta inv√°lida:', data);
        alert('‚ùå Error: respuesta inv√°lida del servidor');
        return;
      }
      
      previewState.effectiveDef = data.data.effectiveDef;
      previewState.provenance = data.data.provenance;
      previewState.warnings = data.data.warnings || [];
      
      console.log('[Preview] Preview generado:', {
        nodes: Object.keys(previewState.effectiveDef.nodes || {}).length,
        edges: (previewState.effectiveDef.edges || []).length,
        warnings: previewState.warnings.length
      });
      
      // Renderizar en canvas
      renderPreviewCanvas();
      
      // Mostrar warnings
      mostrarPreviewWarnings();
      
      // Mostrar provenance
      mostrarPreviewProvenance();
      
    } catch (error) {
      console.error('[Preview] Error generando preview:', error);
      alert(`‚ùå Error: ${error.message}`);
    }
  }
  
  // Renderizar preview en canvas (reutilizando motor AXE)
  function renderPreviewCanvas() {
    if (!previewState.effectiveDef) return;
    
    // Usar la misma funci√≥n de conversi√≥n que el editor normal
    const canvas = navigationDefinitionToCanvas(previewState.effectiveDef);
    
    // Renderizar nodos
    const nodesContainer = document.getElementById('canvas-nodes-container-preview');
    if (nodesContainer) {
      nodesContainer.innerHTML = '';
      
      canvas.nodes.forEach(node => {
        const nodeEl = document.createElement('div');
        nodeEl.id = `node-preview-${node.id}`;
        nodeEl.className = 'absolute bg-slate-700 border-2 border-slate-500 rounded-lg p-3 cursor-move';
        nodeEl.style.left = `${node.x}px`;
        nodeEl.style.top = `${node.y}px`;
        nodeEl.style.minWidth = '120px';
        nodeEl.style.zIndex = '10';
        
        // A√±adir badge de provenance
        const provenance = previewState.provenance?.nodes?.[node.id] || 'unknown';
        const provenanceColor = provenance === 'global' ? 'bg-blue-600' : 'bg-purple-600';
        const provenanceLabel = provenance === 'global' ? 'üåê' : `üéØ ${provenance}`;
        
        nodeEl.innerHTML = `
          <div class="flex items-center justify-between mb-1">
            <span class="text-xs ${provenanceColor} text-white px-2 py-0.5 rounded">${provenanceLabel}</span>
          </div>
          <div class="text-white font-semibold text-sm">${node.label || node.id}</div>
          ${node.subtitle ? `<div class="text-slate-400 text-xs mt-1">${node.subtitle}</div>` : ''}
        `;
        
        nodesContainer.appendChild(nodeEl);
      });
    }
    
    // Renderizar edges
    renderCanvasEdgesPreview(canvas);
  }
  
  // Renderizar edges en canvas preview
  function renderCanvasEdgesPreview(canvas) {
    const svg = document.getElementById('canvas-edges-svg-preview');
    if (!svg) return;
    
    svg.innerHTML = '';
    
    canvas.edges.forEach(edge => {
      const fromNode = canvas.nodes.find(n => n.id === edge.from);
      const toNode = canvas.nodes.find(n => n.id === edge.to);
      
      if (!fromNode || !toNode) return;
      
      // Calcular posici√≥n del edge
      const x1 = fromNode.x + 60; // Centro del nodo
      const y1 = fromNode.y + 40;
      const x2 = toNode.x + 60;
      const y2 = toNode.y + 40;
      
      // Color seg√∫n provenance
      const provenance = previewState.provenance?.edges?.[`${edge.from}:${edge.to}:${edge.kind || 'child'}`] || 'unknown';
      const edgeColor = provenance === 'global' ? '#3b82f6' : '#a855f7';
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke', edgeColor);
      line.setAttribute('stroke-width', '2');
      line.setAttribute('marker-end', 'url(#arrowhead)');
      
      svg.appendChild(line);
    });
    
    // A√±adir marker para flechas si no existe
    if (!svg.querySelector('#arrowhead')) {
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '10');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3, 0 6');
      polygon.setAttribute('fill', '#94a3b8');
      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.appendChild(defs);
    }
  }
  
  // Mostrar warnings
  function mostrarPreviewWarnings() {
    const warningsEl = document.getElementById('preview-warnings');
    const warningsListEl = document.getElementById('preview-warnings-list');
    
    if (!warningsEl || !warningsListEl) return;
    
    if (previewState.warnings.length === 0) {
      warningsEl.classList.add('hidden');
      return;
    }
    
    warningsEl.classList.remove('hidden');
    warningsListEl.innerHTML = '';
    
    previewState.warnings.forEach(warning => {
      const warningDiv = document.createElement('div');
      warningDiv.className = 'text-xs p-2 bg-yellow-800/50 rounded mb-1';
      warningDiv.innerHTML = `
        <div class="font-semibold">${warning.type}</div>
        <div class="text-yellow-200">${warning.message}</div>
        ${warning.node_id ? `<div class="text-yellow-300 mt-1">Nodo: ${warning.node_id}</div>` : ''}
        ${warning.context_key ? `<div class="text-yellow-300 mt-1">Contexto: ${warning.context_key}</div>` : ''}
      `;
      warningsListEl.appendChild(warningDiv);
    });
  }
  
  // Mostrar provenance
  function mostrarPreviewProvenance() {
    const provenanceEl = document.getElementById('preview-provenance');
    if (!provenanceEl || !previewState.provenance) return;
    
    const nodes = previewState.provenance.nodes || {};
    const edges = previewState.provenance.edges || {};
    const entrySource = previewState.provenance.entry_node_id_source || 'unknown';
    
    let html = `<div class="mb-2"><strong>Entry:</strong> ${entrySource}</div>`;
    html += `<div class="mb-2"><strong>Nodos:</strong> ${Object.keys(nodes).length}</div>`;
    html += `<div class="mb-2"><strong>Edges:</strong> ${Object.keys(edges).length}</div>`;
    html += `<div class="mt-2 text-xs">`;
    html += `<div>üåê Global: ${Object.values(nodes).filter(v => v === 'global').length} nodos</div>`;
    const contextCounts = {};
    Object.values(nodes).forEach(v => {
      if (v !== 'global') {
        contextCounts[v] = (contextCounts[v] || 0) + 1;
      }
    });
    Object.entries(contextCounts).forEach(([ctx, count]) => {
      html += `<div>üéØ ${ctx}: ${count} nodos</div>`;
    });
    html += `</div>`;
    
    provenanceEl.innerHTML = html;
  }
  
  // Funciones de canvas para preview (simplificadas)
  let previewCanvasState = { panX: 0, panY: 0, zoom: 1, isPanning: false, startX: 0, startY: 0 };
  
  function handleCanvasMouseDownPreview(event) {
    if (event.target.id && event.target.id.startsWith('node-preview-')) {
      return;
    }
    previewCanvasState.isPanning = true;
    previewCanvasState.startX = event.clientX - previewCanvasState.panX;
    previewCanvasState.startY = event.clientY - previewCanvasState.panY;
  }
  
  function handleCanvasMouseMovePreview(event) {
    if (!previewCanvasState.isPanning) return;
    previewCanvasState.panX = event.clientX - previewCanvasState.startX;
    previewCanvasState.panY = event.clientY - previewCanvasState.startY;
    const container = document.getElementById('canvas-nodes-container-preview');
    if (container) {
      container.style.transform = `translate(${previewCanvasState.panX}px, ${previewCanvasState.panY}px) scale(${previewCanvasState.zoom})`;
    }
  }
  
  function handleCanvasMouseUpPreview(event) {
    previewCanvasState.isPanning = false;
  }
  
  function handleCanvasWheelPreview(event) {
    if (!event.altKey) return;
    event.preventDefault();
    const delta = event.deltaY > 0 ? 0.9 : 1.1;
    previewCanvasState.zoom = Math.max(0.1, Math.min(3, previewCanvasState.zoom * delta));
    const container = document.getElementById('canvas-nodes-container-preview');
    if (container) {
      container.style.transform = `translate(${previewCanvasState.panX}px, ${previewCanvasState.panY}px) scale(${previewCanvasState.zoom})`;
    }
    const zoomLevel = document.getElementById('zoom-level-preview');
    if (zoomLevel) {
      zoomLevel.textContent = `${Math.round(previewCanvasState.zoom * 100)}%`;
    }
  }
  
  function resetCanvasViewPreview() {
    previewCanvasState.panX = 0;
    previewCanvasState.panY = 0;
    previewCanvasState.zoom = 1;
    const container = document.getElementById('canvas-nodes-container-preview');
    if (container) {
      container.style.transform = 'translate(0px, 0px) scale(1)';
    }
    const zoomLevel = document.getElementById('zoom-level-preview');
    if (zoomLevel) {
      zoomLevel.textContent = '100%';
    }
    if (previewState.effectiveDef) {
      renderPreviewCanvas();
    }
  }
  
  function zoomInCanvasPreview() {
    previewCanvasState.zoom = Math.min(3, previewCanvasState.zoom * 1.2);
    const container = document.getElementById('canvas-nodes-container-preview');
    if (container) {
      container.style.transform = `translate(${previewCanvasState.panX}px, ${previewCanvasState.panY}px) scale(${previewCanvasState.zoom})`;
    }
    const zoomLevel = document.getElementById('zoom-level-preview');
    if (zoomLevel) {
      zoomLevel.textContent = `${Math.round(previewCanvasState.zoom * 100)}%`;
    }
  }
  
  function zoomOutCanvasPreview() {
    previewCanvasState.zoom = Math.max(0.1, previewCanvasState.zoom / 1.2);
    const container = document.getElementById('canvas-nodes-container-preview');
    if (container) {
      container.style.transform = `translate(${previewCanvasState.panX}px, ${previewCanvasState.panY}px) scale(${previewCanvasState.zoom})`;
    }
    const zoomLevel = document.getElementById('zoom-level-preview');
    if (zoomLevel) {
      zoomLevel.textContent = `${Math.round(previewCanvasState.zoom * 100)}%`;
    }
  }
</script>

