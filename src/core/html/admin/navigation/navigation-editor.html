<!-- 
  EDITOR DE NAVEGACI√ìN v2 - NAV Editor Thin & Proven
  Rehacer completo desde cero con motor visual m√≠nimo y verificable
  Versi√≥n: v5.12.0-nav-editor-v2-sprint2-panel-warnings-multiselect
-->

<div id="nav-editor-root" class="nav-editor-root">
  <!-- Header -->
  <header id="nav-editor-header" class="nav-editor-header">
    <!-- Theme Selector -->
    <div id="nav-theme-selector" class="nav-theme-selector">
      <label for="theme-select" class="nav-theme-label">Tema:</label>
      <select id="theme-select" class="nav-theme-select" onchange="applyThemeFromSelect(this.value)">
        <option value="auto">Auto</option>
        <option value="light-classic">Light Classic</option>
        <option value="dark-classic">Dark Classic</option>
      </select>
      <a href="/admin/themes/studio" class="nav-theme-studio-link" target="_blank" title="Abrir Theme Studio">üé® Theme Studio</a>
    </div>
    <div class="nav-editor-header-content">
      <div class="nav-editor-header-left">
        <a href="/admin/navigation" class="nav-back-link" title="Volver al listado">‚Üê</a>
        <h1 id="navigation-name" class="nav-title">Cargando...</h1>
        <span id="navigation-id-badge" class="nav-badge">-</span>
        <span id="save-status-badge" class="nav-badge nav-badge-saved" style="display: none;">‚úì Guardado</span>
        <span id="dirty-badge" class="nav-badge nav-badge-dirty" style="display: none;">‚óè Cambios sin guardar</span>
        <span id="published-status-badge" class="nav-badge nav-badge-published" style="display: none;">üì¶ Published: v-</span>
      </div>
      <div class="nav-editor-header-right">
        <button onclick="guardarNavegacion()" class="nav-btn nav-btn-primary" title="Guardar draft">
          üíæ Guardar
        </button>
        <button onclick="validarNavegacion()" class="nav-btn nav-btn-secondary">
          ‚úì Validar
        </button>
        <button id="btn-publish" onclick="publicarNavegacion()" class="nav-btn nav-btn-success" title="Publicar navegaci√≥n (requiere guardar cambios primero)">
          üöÄ Publicar
        </button>
      </div>
    </div>
    <div id="error-banner" class="nav-error-banner" style="display: none;"></div>
  </header>

  <!-- Body: Canvas + Panel -->
  <div class="nav-editor-body">
    <!-- Main Canvas Area -->
    <main id="nav-canvas-area" class="nav-canvas-area">
      <!-- Toolbar -->
      <div id="nav-canvas-toolbar" class="nav-canvas-toolbar">
        <div class="nav-toolbar-left">
          <span class="nav-toolbar-label">Vista:</span>
          <button onclick="setNavigationView('mapa')" id="tab-mapa" class="nav-tab active">üó∫Ô∏è Mapa</button>
          <button onclick="setNavigationView('arbol')" id="tab-arbol" class="nav-tab">üå≥ √Årbol</button>
          <button onclick="setNavigationView('json')" id="tab-json" class="nav-tab">üìÑ JSON</button>
          <button onclick="setNavigationView('preview')" id="tab-preview" class="nav-tab">üëÅÔ∏è Preview Efectivo</button>
        </div>
        <div class="nav-toolbar-right">
          <button id="btn-connect" onclick="toggleConnectMode()" class="nav-btn-icon" title="Modo conectar (crear edges)">üîó Conectar</button>
          <button id="btn-grid" onclick="toggleGridSnap()" class="nav-btn-icon" title="Snapping a grid">‚äû Grid</button>
          <button onclick="fitToView()" class="nav-btn-icon" title="Ajustar vista (F)">üìê Fit</button>
          <button onclick="centerSelection()" class="nav-btn-icon" title="Centrar selecci√≥n">üéØ Centrar</button>
          <button onclick="zoomOutCanvas()" class="nav-btn-icon" title="Alejar">‚ûñ</button>
          <span id="zoom-level" class="nav-zoom-indicator">100%</span>
          <button onclick="zoomInCanvas()" class="nav-btn-icon" title="Acercar">‚ûï</button>
          <button onclick="resetCanvasView()" class="nav-btn-icon" title="Resetear vista">üîÑ</button>
          <button onclick="a√±adirNodo()" class="nav-btn-icon nav-btn-add" title="A√±adir nodo">‚ûï Nodo</button>
        </div>
      </div>

      <!-- Viewport -->
      <div id="nav-canvas-viewport" class="nav-canvas-viewport">
        <!-- Stage (transformado) -->
        <div id="nav-canvas-stage" class="nav-canvas-stage">
          <!-- Watermark temporal para smoke test -->
          <div class="nav-watermark">NAV EDITOR V2 LIVE</div>
        </div>
        <!-- SVG para edges -->
        <svg id="nav-edges-svg" class="nav-edges-svg"></svg>
        <!-- Grid overlay (opcional) -->
        <div id="nav-grid-overlay" class="nav-grid-overlay" style="display: none;"></div>
        <!-- Connect mode hint -->
        <div id="nav-connect-hint" class="nav-connect-hint" style="display: none;">
          Click origen ‚Üí click destino (ESC para cancelar)
        </div>
      </div>
    </main>

    <!-- Right Panel -->
    <aside id="nav-right-panel" class="nav-right-panel">
      <div id="nav-props" class="nav-props">
        <div class="nav-props-placeholder">
          <p>Selecciona un nodo del canvas para editarlo</p>
          <p class="nav-hint">
            üí° Arrastra nodos para moverlos<br/>
            üí° CTRL + rueda para zoom<br/>
            üí° Arrastra fondo para pan
          </p>
        </div>
      </div>
      <div id="nav-warnings" class="nav-warnings"></div>
    </aside>
  </div>
</div>

<style>
  /* Reset y base */
  .nav-editor-root {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100%;
    background: var(--bg-main, #0f172a);
    color: var(--text-primary, #e2e8f0);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    overflow: hidden;
  }

  /* Theme Selector */
  .nav-theme-selector {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 24px;
    background: var(--bg-card, #1e293b);
    border-bottom: 1px solid var(--border-soft, #334155);
  }

  .nav-theme-label {
    font-size: 13px;
    color: var(--text-muted, #94a3b8);
  }

  .nav-theme-select {
    padding: 4px 8px;
    background: var(--bg-main, #0f172a);
    border: 1px solid var(--border-soft, #334155);
    border-radius: 4px;
    color: var(--text-primary, #e2e8f0);
    font-size: 13px;
    cursor: pointer;
  }

  .nav-theme-studio-link {
    margin-left: auto;
    padding: 4px 8px;
    color: var(--accent-primary, #3b82f6);
    text-decoration: none;
    font-size: 13px;
    border-radius: 4px;
    transition: background 0.2s;
  }

  .nav-theme-studio-link:hover {
    background: var(--bg-main, #0f172a);
  }

  /* Header */
  .nav-editor-header {
    background: var(--bg-card, #1e293b);
    border-bottom: 1px solid var(--border-soft, #334155);
    padding: 12px 24px;
    flex-shrink: 0;
  }

  .nav-editor-header-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
  }

  .nav-editor-header-left {
    display: flex;
    align-items: center;
    gap: 12px;
    flex: 1;
    min-width: 0;
  }

  .nav-back-link {
    color: var(--text-muted, #94a3b8);
    text-decoration: none;
    font-size: 18px;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.2s;
  }

  .nav-back-link:hover {
    background: var(--bg-main, #0f172a);
    color: var(--text-primary, #fff);
  }

  .nav-title {
    font-size: 18px;
    font-weight: 600;
    margin: 0;
    color: var(--text-primary, #fff);
  }

  .nav-badge {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
    background: var(--bg-main, #475569);
    color: var(--text-primary, #e2e8f0);
  }

  .nav-badge-saved {
    background: var(--accent-primary, #059669);
    color: var(--text-primary, #d1fae5);
  }

  .nav-badge-dirty {
    background: var(--accent-primary, #92400e);
    color: var(--text-primary, #fef3c7);
  }

  .nav-editor-header-right {
    display: flex;
    gap: 8px;
  }

  .nav-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  }

  .nav-btn-primary {
    background: var(--bg-main, #475569);
    color: var(--text-primary, #fff);
  }

  .nav-btn-primary:hover {
    background: var(--accent-primary, #64748b);
  }

  .nav-btn-secondary {
    background: var(--accent-primary, #3b82f6);
    color: var(--text-primary, #fff);
  }

  .nav-btn-secondary:hover {
    background: var(--accent-primary, #2563eb);
    opacity: 0.9;
  }

  .nav-btn-success {
    background: var(--accent-primary, #059669);
    color: var(--text-primary, #fff);
  }

  .nav-btn-success:hover {
    background: var(--accent-primary, #047857);
    opacity: 0.9;
  }

  .nav-error-banner {
    margin-top: 8px;
    padding: 8px 12px;
    background: var(--accent-primary, #7f1d1d);
    color: var(--text-primary, #fecaca);
    border-radius: 4px;
    font-size: 13px;
  }

  /* Body */
  .nav-editor-body {
    display: flex;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }

  /* Canvas Area */
  .nav-canvas-area {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    background: var(--bg-main, #0f172a);
  }

  .nav-canvas-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 16px;
    background: var(--bg-card, #1e293b);
    border-bottom: 1px solid var(--border-soft, #334155);
    flex-shrink: 0;
  }

  .nav-toolbar-left,
  .nav-toolbar-right {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .nav-toolbar-label {
    font-size: 13px;
    color: var(--text-muted, #94a3b8);
    margin-right: 4px;
  }

  .nav-tab {
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    background: transparent;
    color: var(--text-muted, #94a3b8);
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .nav-tab:hover {
    background: var(--bg-main, #334155);
    color: var(--text-primary, #fff);
  }

  .nav-tab.active {
    background: var(--accent-primary, #3b82f6);
    color: var(--text-primary, #fff);
  }

  .nav-btn-icon {
    padding: 6px 10px;
    border: none;
    border-radius: 4px;
    background: var(--bg-main, #334155);
    color: var(--text-primary, #e2e8f0);
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .nav-btn-icon:hover {
    background: var(--accent-primary, #475569);
  }

  .nav-btn-icon.active {
    background: var(--accent-primary, #3b82f6);
    color: var(--text-primary, #fff);
  }

  .nav-btn-add {
    background: var(--accent-primary, #6366f1);
    color: var(--text-primary, #fff);
    font-weight: 500;
  }

  .nav-btn-add:hover {
    background: var(--accent-primary, #4f46e5);
    opacity: 0.9;
  }

  .nav-zoom-indicator {
    padding: 6px 10px;
    font-size: 13px;
    color: var(--text-muted, #94a3b8);
    min-width: 50px;
    text-align: center;
  }

  /* Viewport */
  .nav-canvas-viewport {
    position: relative;
    flex: 1;
    overflow: hidden;
    background: var(--bg-main, #0f172a);
    cursor: grab;
  }

  .nav-canvas-viewport:active {
    cursor: grabbing;
  }

  /* Grid overlay */
  .nav-grid-overlay {
    position: absolute;
    inset: 0;
    pointer-events: none;
    background-image: 
      linear-gradient(var(--border-soft, rgba(148, 163, 184, 0.1)) 1px, transparent 1px),
      linear-gradient(90deg, var(--border-soft, rgba(148, 163, 184, 0.1)) 1px, transparent 1px);
    background-size: 20px 20px;
    z-index: 0;
  }

  /* Connect mode hint */
  .nav-connect-hint {
    position: absolute;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 16px;
    background: var(--bg-card, #1e293b);
    border: 1px solid var(--border-soft, #334155);
    border-radius: 4px;
    color: var(--text-primary, #e2e8f0);
    font-size: 13px;
    z-index: 1000;
    pointer-events: none;
  }

  /* Stage */
  .nav-canvas-stage {
    position: absolute;
    inset: 0;
    transform-origin: 0 0;
    transform: translate(0px, 0px) scale(1);
  }

  /* Watermark temporal para smoke test */
  .nav-watermark {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 8px 16px;
    background: var(--bg-card, rgba(239, 68, 68, 0.2));
    border: 2px solid var(--accent-primary, #ef4444);
    border-radius: 4px;
    color: var(--text-muted, #fecaca);
    font-weight: bold;
    font-size: 14px;
    z-index: 1000;
    pointer-events: none;
    opacity: 0.5;
  }

  /* SVG Edges */
  .nav-edges-svg {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 2;
  }

  .nav-edges-svg line {
    stroke: var(--text-muted, #64748b);
    stroke-width: 2;
    marker-end: url(#arrowhead);
    transition: stroke 0.2s;
  }

  .nav-edges-svg line.selected {
    stroke: var(--accent-primary, #3b82f6);
    stroke-width: 3;
  }

  .nav-edges-svg line.hitbox {
    stroke: transparent;
    stroke-width: 12;
    cursor: pointer;
    pointer-events: all;
  }

  /* Nodes */
  .nav-node {
    position: absolute;
    min-width: 120px;
    min-height: 60px;
    background: var(--bg-card, #1e293b);
    border: 2px solid var(--border-soft, #475569);
    border-radius: 8px;
    padding: 12px;
    cursor: move;
    transition: all 0.2s;
    box-shadow: 0 2px 8px var(--shadow-sm, rgba(0, 0, 0, 0.3));
    z-index: 10;
  }

  .nav-node:hover {
    border-color: var(--accent-primary, #3b82f6);
    box-shadow: 0 4px 12px var(--shadow-md, rgba(59, 130, 246, 0.3));
  }

  .nav-node.selected {
    border-color: var(--accent-primary, #3b82f6);
    background: var(--bg-card, #1e3a8a);
    box-shadow: 0 0 0 3px var(--accent-primary, rgba(59, 130, 246, 0.3));
  }
  
  .nav-node.has-warning {
    border-color: var(--accent-warning, #f59e0b);
  }
  
  .nav-node-warning-badge {
    margin-left: 4px;
    font-size: 12px;
    color: var(--accent-warning, #f59e0b);
  }

  .nav-node.connecting-from {
    border-color: var(--accent-primary, #3b82f6);
    box-shadow: 0 0 0 4px var(--accent-primary, rgba(59, 130, 246, 0.5));
  }

  .nav-node-label {
    font-weight: 600;
    color: var(--text-primary, #fff);
    margin-bottom: 4px;
    font-size: 14px;
  }

  .nav-node-meta {
    font-size: 11px;
    color: var(--text-muted, #94a3b8);
  }

  /* Right Panel */
  .nav-right-panel {
    width: 420px;
    background: var(--bg-card, #1e293b);
    border-left: 1px solid var(--border-soft, #334155);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    flex-shrink: 0;
  }

  .nav-props {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
  }

  .nav-props-placeholder {
    text-align: center;
    color: var(--text-muted, #64748b);
    padding: 32px 16px;
  }

  .nav-hint {
    font-size: 12px;
    margin-top: 16px;
    line-height: 1.6;
    color: var(--text-muted, #94a3b8);
  }

  .nav-warnings {
    padding: 16px;
    background: var(--bg-card, #1e293b);
    border-top: 1px solid var(--border-soft, #334155);
    max-height: 200px;
    overflow-y: auto;
  }
  
  .nav-warnings-header {
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--accent-warning, #f59e0b);
  }
  
  .nav-warnings-section {
    margin-bottom: 12px;
  }
  
  .nav-warnings-section strong {
    display: block;
    margin-bottom: 4px;
    font-size: 12px;
    color: var(--text-muted, #94a3b8);
  }
  
  .nav-warnings-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  
  .nav-warning-item {
    padding: 4px 0;
    font-size: 12px;
    color: var(--text-muted, #94a3b8);
  }
  
  .nav-warnings-empty {
    text-align: center;
    color: var(--text-muted, #64748b);
    font-size: 12px;
  }
  
  .nav-badge-warning {
    background: var(--accent-warning, #f59e0b);
    color: var(--text-primary, #fff);
  }
  
  /* IDE Panel Styles */
  .nav-ide-panel {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .nav-ide-section {
    border: 1px solid var(--border-soft, #334155);
    border-radius: 4px;
    overflow: hidden;
    background: var(--bg-main, #0f172a);
  }
  
  .nav-ide-section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: var(--bg-card, #1e293b);
    cursor: pointer;
    user-select: none;
    transition: background 0.2s;
  }
  
  .nav-ide-section-header:hover {
    background: var(--bg-main, #334155);
  }
  
  .nav-ide-section-title {
    font-weight: 500;
    font-size: 13px;
    color: var(--text-primary, #e2e8f0);
  }
  
  .nav-ide-section-toggle {
    font-size: 10px;
    color: var(--text-muted, #94a3b8);
  }
  
  .nav-ide-section-content {
    padding: 12px;
  }
  
  .nav-quick-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 12px;
  }
  
  .nav-action-btn {
    padding: 6px 10px;
    background: var(--bg-card, #1e293b);
    border: 1px solid var(--border-soft, #334155);
    border-radius: 4px;
    color: var(--text-primary, #e2e8f0);
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .nav-action-btn:hover {
    background: var(--accent-primary, #3b82f6);
    border-color: var(--accent-primary, #3b82f6);
  }
  
  .nav-diagnostic-ok {
    color: var(--accent-success, #059669);
    font-size: 12px;
    margin: 0;
  }
  
  /* Box Select Overlay */
  .nav-box-select-overlay {
    position: absolute;
    border: 2px dashed var(--accent-primary, #3b82f6);
    background: rgba(59, 130, 246, 0.1);
    pointer-events: none;
    z-index: 100;
    display: none;
  }

  /* Form inputs */
  .nav-form-group {
    margin-bottom: 16px;
  }

  .nav-form-label {
    display: block;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-muted, #94a3b8);
    margin-bottom: 6px;
  }

  .nav-form-input {
    width: 100%;
    padding: 8px 12px;
    background: var(--bg-main, #0f172a);
    border: 1px solid var(--border-soft, #334155);
    border-radius: 4px;
    color: var(--text-primary, #e2e8f0);
    font-size: 13px;
  }

  .nav-form-input:focus {
    outline: none;
    border-color: var(--accent-primary, #3b82f6);
  }

  .nav-form-select {
    width: 100%;
    padding: 8px 12px;
    background: var(--bg-main, #0f172a);
    border: 1px solid var(--border-soft, #334155);
    border-radius: 4px;
    color: var(--text-primary, #e2e8f0);
    font-size: 13px;
  }

  .nav-form-textarea {
    width: 100%;
    padding: 8px 12px;
    background: var(--bg-main, #0f172a);
    border: 1px solid var(--border-soft, #334155);
    border-radius: 4px;
    color: var(--text-primary, #e2e8f0);
    font-size: 13px;
    min-height: 80px;
    resize: vertical;
    font-family: monospace;
  }

  .nav-form-btn {
    width: 100%;
    padding: 8px;
    background: var(--accent-primary, #dc2626);
    color: var(--text-primary, #fff);
    border: none;
    border-radius: 4px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    margin-top: 8px;
  }

  .nav-form-btn:hover {
    background: var(--accent-primary, #b91c1c);
    opacity: 0.9;
  }

  /* Vistas ocultas */
  .nav-view-container {
    display: none;
    flex: 1;
    overflow: hidden;
  }

  .nav-view-container.active {
    display: flex;
  }

  /* Vista √Årbol */
  .nav-tree-view {
    flex: 1;
    display: flex;
    overflow: hidden;
  }

  .nav-tree-sidebar {
    width: 300px;
    background: var(--bg-card, #1e293b);
    border-right: 1px solid var(--border-soft, #334155);
    overflow-y: auto;
    padding: 16px;
  }

  .nav-tree-item {
    padding: 8px 12px;
    margin-bottom: 4px;
    background: var(--bg-main, #0f172a);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .nav-tree-item:hover {
    background: var(--bg-card, #1e293b);
  }

  .nav-tree-item.selected {
    background: var(--bg-card, #1e3a8a);
    border-left: 3px solid var(--accent-primary, #3b82f6);
  }

  /* Vista JSON */
  .nav-json-view {
    flex: 1;
    padding: 16px;
    overflow-y: auto;
  }

  .nav-json-textarea {
    width: 100%;
    height: 100%;
    padding: 16px;
    background: var(--bg-main, #0f172a);
    border: 1px solid var(--border-soft, #334155);
    border-radius: 4px;
    color: var(--text-primary, #e2e8f0);
    font-family: 'Courier New', monospace;
    font-size: 13px;
    resize: none;
  }

  /* Vista Preview */
  .nav-preview-view {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background: var(--bg-main, #0f172a);
  }

  .nav-node-base {
    border-color: var(--border-soft, #475569);
  }

  .nav-node-contextual {
    border-color: var(--accent-primary, #3b82f6);
    border-width: 3px;
  }
</style>

<script>
  // ========================================================================
  // ESTADO GLOBAL
  // ========================================================================
  console.log('[AXE][NAV2] Inicializando editor v2...');

  const navState = {
    navigationId: null,
    view: 'mapa', // mapa, arbol, json, preview
    panX: 0,
    panY: 0,
    zoom: 1,
    selectedNodeId: null,
    selectedNodeIds: [], // Multi-selecci√≥n
    selectedEdgeId: null,
    canvas: {
      nodes: [],
      edges: []
    },
    navDef: null,
    isDirty: false,
    publishedVersion: null,
    isDragging: false,
    isPanning: false,
    isBoxSelecting: false,
    boxSelectStart: { x: 0, y: 0 },
    dragStart: { x: 0, y: 0 },
    panStart: { x: 0, y: 0 },
    ui: {
      connectMode: false,
      connectFromNodeId: null,
      snapToGrid: false,
      gridSize: 20,
      panelSections: {
        basic: true,
        target: true,
        visibility: false,
        meta: false,
        diagnostics: true
      }
    },
    warnings: {
      global: [],
      nodes: {},
      edges: {}
    },
    save: {
      inFlight: false,
      queued: false,
      lastSavedSnapshot: '',
      autosaveTimer: null
    }
  };

  // ========================================================================
  // INICIALIZACI√ìN
  // ========================================================================
  async function initNavigationEditor() {
    try {
      console.log('[AXE][NAV2] Iniciando editor...');
      
      // Cargar tema desde localStorage
      await loadThemeFromStorage();
      
      // Cargar estado de secciones del panel desde localStorage
      loadPanelSectionsState();
      
      // Cargar lista de temas din√°mica
      await loadThemesList();

      // Obtener navigation_id de la URL o del data attribute
      const editorRoot = document.getElementById('nav-editor-root');
      const navIdFromUrl = window.location.pathname.match(/\/admin\/navigation\/([^\/]+)\/edit/);
      const navId = navIdFromUrl ? decodeURIComponent(navIdFromUrl[1]) : 'new';
      
      navState.navigationId = navId;
      console.log('[AXE][NAV2] Navigation ID:', navId);

      // Configurar event listeners
      setupEventListeners();

      // Cargar navegaci√≥n si no es 'new'
      if (navId !== 'new') {
        await loadNavigation(navId);
      } else {
        // Crear navegaci√≥n m√≠nima
        createMinimalNavigation();
      }

      // Inicializar snapshot para dirty state
      updateSavedSnapshot();

      // Render inicial
      renderCanvas();
      updateUI();
      computeAndRenderWarnings();

      console.log('[AXE][NAV2] Editor inicializado correctamente');
    } catch (error) {
      console.error('[AXE][NAV2] Error en inicializaci√≥n:', error);
      showError('Error al inicializar editor: ' + error.message);
      // Fail-open: crear navegaci√≥n m√≠nima
      createMinimalNavigation();
      renderCanvas();
      computeAndRenderWarnings();
    }
  }

  // ========================================================================
  // EVENT LISTENERS
  // ========================================================================
  function setupEventListeners() {
    const viewport = document.getElementById('nav-canvas-viewport');
    const stage = document.getElementById('nav-canvas-stage');

    // Pan: mousedown en viewport (no en nodo)
    viewport.addEventListener('mousedown', (e) => {
      if (e.target === viewport || e.target === stage || e.target.id === 'nav-edges-svg' || e.target.id === 'nav-grid-overlay') {
        // Si estamos en modo conectar, cancelar al click en fondo
        if (navState.ui.connectMode && navState.ui.connectFromNodeId) {
          navState.ui.connectFromNodeId = null;
          updateConnectModeUI();
          return;
        }
        
        // Box-select con Shift
        if (e.shiftKey) {
          startBoxSelect(e);
          return;
        }
        
        navState.isPanning = true;
        navState.panStart = { x: e.clientX - navState.panX, y: e.clientY - navState.panY };
        viewport.style.cursor = 'grabbing';
      }
    });

    // Pan: mousemove
    document.addEventListener('mousemove', (e) => {
      if (navState.isBoxSelecting) {
        updateBoxSelectOverlay(e);
      } else if (navState.isPanning) {
        navState.panX = e.clientX - navState.panStart.x;
        navState.panY = e.clientY - navState.panStart.y;
        updateStageTransform();
      }
    });

    // Pan: mouseup
    document.addEventListener('mouseup', (e) => {
      if (navState.isBoxSelecting) {
        endBoxSelect(e);
      }
      if (navState.isPanning) {
        navState.isPanning = false;
        viewport.style.cursor = 'grab';
      }
      if (navState.isDragging) {
        navState.isDragging = false;
        document.removeEventListener('mousemove', handleDragNode);
        // Autosave despu√©s de drag
        scheduleAutosave('drag-end');
      }
    });

    // Zoom: SOLO con CTRL + rueda (alrededor del cursor)
    viewport.addEventListener('wheel', (e) => {
      if (!e.ctrlKey) {
        // Sin CTRL: permitir scroll normal del navegador
        return;
      }

      // Con CTRL: zoom del canvas alrededor del cursor
      e.preventDefault();
      
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Convertir a coordenadas del mundo antes del zoom
      const worldX = (mouseX - navState.panX) / navState.zoom;
      const worldY = (mouseY - navState.panY) / navState.zoom;
      
      // Aplicar zoom
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newZoom = Math.max(0.3, Math.min(3, navState.zoom * delta));
      
      // Recalcular pan para que el mismo punto del mundo quede bajo el cursor
      navState.panX = mouseX - worldX * newZoom;
      navState.panY = mouseY - worldY * newZoom;
      navState.zoom = newZoom;
      
      updateStageTransform();
      updateZoomIndicator();
    }, { passive: false });

    // Atajos de teclado
    document.addEventListener('keydown', (e) => {
      // Ctrl/Cmd+S: guardar
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveDraftNow({ manual: true });
        return;
      }

      // ESC: cancelar connect mode o deseleccionar
      if (e.key === 'Escape') {
        if (navState.ui.connectFromNodeId) {
          navState.ui.connectFromNodeId = null;
          updateConnectModeUI();
          renderCanvas();
        } else if (navState.selectedEdgeId || navState.selectedNodeIds.length > 0) {
          clearSelection();
        }
        return;
      }

      // Delete/Backspace: borrar selecci√≥n
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (navState.selectedEdgeId) {
          deleteEdge(navState.selectedEdgeId);
        } else if (navState.selectedNodeIds.length > 1) {
          deleteSelectedNodes();
        } else if (navState.selectedNodeId) {
          deleteNode(navState.selectedNodeId);
        }
        return;
      }

      // F: fit to view
      if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        fitToView();
        return;
      }
    });

    // Click en fondo: deseleccionar (solo si no es box-select)
    viewport.addEventListener('click', (e) => {
      if (e.target === viewport || e.target === stage || e.target.id === 'nav-grid-overlay') {
        if (!navState.ui.connectMode && !navState.isBoxSelecting) {
          clearSelection();
        }
      }
    });
  }

  // ========================================================================
  // THEME MANAGEMENT
  // ========================================================================
  async function loadThemeFromStorage() {
    try {
      const themePref = localStorage.getItem('ap_nav_editor_theme_pref') || 'auto';
      const themeSelect = document.getElementById('theme-select');
      if (themeSelect) {
        themeSelect.value = themePref;
      }
      await applyThemeSafely(themePref);
    } catch (error) {
      console.error('[AXE][NAV2] Error cargando tema:', error);
    }
  }

  async function applyThemeFromSelect(themeId) {
    try {
      localStorage.setItem('ap_nav_editor_theme_pref', themeId);
      await applyThemeSafely(themeId);
    } catch (error) {
      console.error('[AXE][NAV2] Error aplicando tema:', error);
      showError('Error al aplicar tema: ' + error.message);
    }
  }

  async function applyThemeSafely(themeId) {
    try {
      // Si es 'auto', usar el tema del sistema (dark-classic por defecto)
      const effectiveThemeId = themeId === 'auto' ? 'dark-classic' : themeId;
      
      // Hacer fetch al endpoint que devuelve los tokens del tema
      const response = await fetch(`/admin/api/themes/${encodeURIComponent(effectiveThemeId)}`);
      
      if (!response.ok) {
        throw new Error(`Tema no encontrado: ${effectiveThemeId}`);
      }

      const data = await response.json();
      
      // El endpoint devuelve { theme, draft, published_version }
      // Preferir draft si existe, sino usar published_version
      let definitionJson = null;
      if (data.draft && data.draft.definition_json) {
        definitionJson = data.draft.definition_json;
      } else if (data.published_version && data.published_version.definition_json) {
        definitionJson = data.published_version.definition_json;
      }

      if (!definitionJson) {
        throw new Error('Tema sin definici√≥n disponible');
      }

      // Obtener tokens del tema
      const tokens = definitionJson.tokens || definitionJson;

      // Inyectar CSS variables en el documento
      injectThemeTokens(tokens);
      
      console.log('[AXE][NAV2] Tema aplicado:', effectiveThemeId);
    } catch (error) {
      console.error('[AXE][NAV2] Error aplicando tema, usando fallback:', error);
      // Fail-open: usar tema por defecto (dark-classic)
      try {
        const fallbackResponse = await fetch('/admin/api/themes/dark-classic');
        if (fallbackResponse.ok) {
          const fallbackData = await fallbackResponse.json();
          let fallbackDefinitionJson = null;
          if (fallbackData.draft && fallbackData.draft.definition_json) {
            fallbackDefinitionJson = fallbackData.draft.definition_json;
          } else if (fallbackData.published_version && fallbackData.published_version.definition_json) {
            fallbackDefinitionJson = fallbackData.published_version.definition_json;
          }
          
          if (fallbackDefinitionJson) {
            const fallbackTokens = fallbackDefinitionJson.tokens || fallbackDefinitionJson;
            injectThemeTokens(fallbackTokens);
          }
        }
      } catch (fallbackError) {
        console.error('[AXE][NAV2] Error en fallback de tema:', fallbackError);
      }
      showError('Tema no aplicable, usando fallback');
    }
  }

  function injectThemeTokens(tokens) {
    // Buscar o crear el style tag para temas
    let styleTag = document.getElementById('ap-theme-tokens');
    if (!styleTag) {
      styleTag = document.createElement('style');
      styleTag.id = 'ap-theme-tokens';
      document.head.appendChild(styleTag);
    }

    // Construir CSS
    const cssVars = Object.entries(tokens)
      .filter(([key]) => key.startsWith('--'))
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([key, value]) => `  ${key}: ${String(value).replace(/</g, '\\3c ')};`)
      .join('\n');

    styleTag.textContent = `:root {\n${cssVars}\n}`;
  }

  // ========================================================================
  // CONNECT MODE (EDGES)
  // ========================================================================
  function toggleConnectMode() {
    navState.ui.connectMode = !navState.ui.connectMode;
    if (!navState.ui.connectMode) {
      navState.ui.connectFromNodeId = null;
    }
    updateConnectModeUI();
    renderCanvas();
  }

  function updateConnectModeUI() {
    const btn = document.getElementById('btn-connect');
    const hint = document.getElementById('nav-connect-hint');
    
    if (btn) {
      btn.classList.toggle('active', navState.ui.connectMode);
    }
    
    if (hint) {
      hint.style.display = navState.ui.connectMode ? 'block' : 'none';
    }
  }

  function handleNodeClickForConnect(nodeId) {
    if (!navState.ui.connectMode) return false;

    if (!navState.ui.connectFromNodeId) {
      // Primer click: seleccionar nodo origen
      navState.ui.connectFromNodeId = nodeId;
      navState.selectedNodeId = nodeId;
      updateConnectModeUI();
      renderCanvas();
      return true;
    } else {
      // Segundo click: crear edge
      const fromId = navState.ui.connectFromNodeId;
      if (fromId === nodeId) {
        showToast('No se puede crear edge a s√≠ mismo', 'error');
        return true;
      }

      // Verificar si ya existe
      const exists = navState.canvas.edges.some(e => e.from === fromId && e.to === nodeId);
      if (exists) {
        showToast('Edge ya existe', 'error');
        navState.ui.connectFromNodeId = null;
        updateConnectModeUI();
        renderCanvas();
        return true;
      }

      // Crear edge
      createEdge(fromId, nodeId);
      navState.ui.connectFromNodeId = null;
      updateConnectModeUI();
      renderCanvas();
      return true;
    }
  }

  function createEdge(from, to) {
    const edgeId = `e_${from}__${to}`;
    navState.canvas.edges.push({
      id: edgeId,
      from: from,
      to: to,
      kind: 'child'
    });
    markDirty();
    scheduleAutosave('edge-create');
    console.log('[AXE][NAV2] Edge creado:', edgeId);
  }

  function deleteEdge(edgeId) {
    navState.canvas.edges = navState.canvas.edges.filter(e => e.id !== edgeId);
    if (navState.selectedEdgeId === edgeId) {
      navState.selectedEdgeId = null;
    }
    markDirty();
    scheduleAutosave('edge-delete');
    renderCanvas();
    renderNodeProperties();
    console.log('[AXE][NAV2] Edge eliminado:', edgeId);
  }

  // ========================================================================
  // GRID SNAPPING
  // ========================================================================
  function toggleGridSnap() {
    navState.ui.snapToGrid = !navState.ui.snapToGrid;
    const btn = document.getElementById('btn-grid');
    const overlay = document.getElementById('nav-grid-overlay');
    
    if (btn) {
      btn.classList.toggle('active', navState.ui.snapToGrid);
    }
    
    if (overlay) {
      overlay.style.display = navState.ui.snapToGrid ? 'block' : 'none';
    }
  }

  function snapToGrid(value) {
    if (!navState.ui.snapToGrid) return value;
    return Math.round(value / navState.ui.gridSize) * navState.ui.gridSize;
  }

  // ========================================================================
  // FIT TO VIEW & CENTER
  // ========================================================================
  function fitToView() {
    if (navState.canvas.nodes.length === 0) return;

    // Calcular bounding box
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    navState.canvas.nodes.forEach(node => {
      minX = Math.min(minX, node.position.x);
      minY = Math.min(minY, node.position.y);
      maxX = Math.max(maxX, node.position.x + 120); // ancho aproximado
      maxY = Math.max(maxY, node.position.y + 60); // alto aproximado
    });

    const width = maxX - minX;
    const height = maxY - minY;
    const padding = 60;

    const viewport = document.getElementById('nav-canvas-viewport');
    const viewportWidth = viewport.clientWidth;
    const viewportHeight = viewport.clientHeight;

    // Calcular zoom para encuadrar
    const zoomX = (viewportWidth - padding * 2) / width;
    const zoomY = (viewportHeight - padding * 2) / height;
    const newZoom = Math.max(0.3, Math.min(3, Math.min(zoomX, zoomY)));

    // Centrar
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;

    navState.zoom = newZoom;
    navState.panX = viewportWidth / 2 - centerX * newZoom;
    navState.panY = viewportHeight / 2 - centerY * newZoom;

    updateStageTransform();
    updateZoomIndicator();
    console.log('[AXE][NAV2] Fit to view aplicado');
  }

  function centerSelection() {
    const viewport = document.getElementById('nav-canvas-viewport');
    const viewportWidth = viewport.clientWidth;
    const viewportHeight = viewport.clientHeight;

    if (navState.selectedNodeId) {
      const node = navState.canvas.nodes.find(n => n.id === navState.selectedNodeId);
      if (node) {
        navState.panX = viewportWidth / 2 - (node.position.x + 60) * navState.zoom;
        navState.panY = viewportHeight / 2 - (node.position.y + 30) * navState.zoom;
        updateStageTransform();
        return;
      }
    }

    if (navState.selectedEdgeId) {
      const edge = navState.canvas.edges.find(e => e.id === navState.selectedEdgeId);
      if (edge) {
        const fromNode = navState.canvas.nodes.find(n => n.id === edge.from);
        const toNode = navState.canvas.nodes.find(n => n.id === edge.to);
        if (fromNode && toNode) {
          const midX = (fromNode.position.x + toNode.position.x + 120) / 2;
          const midY = (fromNode.position.y + toNode.position.y + 60) / 2;
          navState.panX = viewportWidth / 2 - midX * navState.zoom;
          navState.panY = viewportHeight / 2 - midY * navState.zoom;
          updateStageTransform();
        }
      }
    }
  }

  // ========================================================================
  // RENDER CANVAS
  // ========================================================================
  function renderCanvas() {
    console.log('[AXE][NAV2] Renderizando canvas...');
    
    const stage = document.getElementById('nav-canvas-stage');
    const svg = document.getElementById('nav-edges-svg');

    // Limpiar
    stage.innerHTML = '<div class="nav-watermark">NAV EDITOR V2 LIVE</div>';
    svg.innerHTML = '';

    // Fail-open: si no hay nodos, crear uno home
    if (navState.canvas.nodes.length === 0) {
      console.log('[AXE][NAV2] No hay nodos, creando nodo home fallback');
      navState.canvas.nodes.push({
        id: 'home',
        label: 'Home',
        type: 'home',
        kind: 'section',
        position: { x: 120, y: 120 }
      });
    }

    // Renderizar nodos
    navState.canvas.nodes.forEach(node => {
      const nodeEl = document.createElement('div');
      let classes = 'nav-node';
      if (navState.selectedNodeIds.includes(node.id)) classes += ' selected';
      if (node.id === navState.ui.connectFromNodeId) classes += ' connecting-from';
      
      // Indicador de warnings
      const nodeWarnings = navState.warnings.nodes[node.id] || [];
      if (nodeWarnings.length > 0) {
        classes += ' has-warning';
      }
      
      nodeEl.className = classes;
      nodeEl.id = `nav-node-${node.id}`;
      nodeEl.style.left = `${node.position.x}px`;
      nodeEl.style.top = `${node.position.y}px`;
      
      const warningIndicator = nodeWarnings.length > 0 ? '<span class="nav-node-warning-badge">‚ö†Ô∏è</span>' : '';
      nodeEl.innerHTML = `
        <div class="nav-node-label">${escapeHtml(node.label || node.id)}${warningIndicator}</div>
        <div class="nav-node-meta">${node.type || node.kind || 'node'}</div>
      `;

      // Event listeners para nodo
      nodeEl.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        if (e.target === nodeEl || nodeEl.contains(e.target)) {
          // Si estamos en modo conectar, manejar conexi√≥n
          if (handleNodeClickForConnect(node.id)) {
            return;
          }
          // Modo normal: seleccionar y arrastrar
          selectNode(node.id);
          navState.selectedEdgeId = null; // Deseleccionar edge si hay uno
          startDragNode(e, node.id);
        }
      });

      stage.appendChild(nodeEl);
    });

    // Renderizar edges
    renderEdges();

    console.log('[AXE][NAV2] Canvas renderizado:', navState.canvas.nodes.length, 'nodos');
  }

  function renderEdges() {
    const svg = document.getElementById('nav-edges-svg');
    
    // Limpiar edges anteriores
    const existingLines = svg.querySelectorAll('line');
    existingLines.forEach(line => line.remove());
    
    // Definir marker para flecha (si no existe)
    if (!svg.querySelector('#arrowhead')) {
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '10');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3, 0 6');
      const computedStyle = getComputedStyle(document.documentElement);
      const strokeColor = computedStyle.getPropertyValue('--text-muted').trim() || '#64748b';
      polygon.setAttribute('fill', strokeColor);
      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.appendChild(defs);
    }

    // Renderizar l√≠neas
    navState.canvas.edges.forEach(edge => {
      const sourceNode = navState.canvas.nodes.find(n => n.id === edge.from);
      const targetNode = navState.canvas.nodes.find(n => n.id === edge.to);
      
      if (!sourceNode || !targetNode) return;

      const x1 = sourceNode.position.x + 60; // centro del nodo (aprox)
      const y1 = sourceNode.position.y + 30;
      const x2 = targetNode.position.x + 60;
      const y2 = targetNode.position.y + 30;

      const isSelected = edge.id === navState.selectedEdgeId;

      // L√≠nea visible
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('marker-end', 'url(#arrowhead)');
      line.setAttribute('data-edge-id', edge.id || `e_${edge.from}__${edge.to}`);
      if (isSelected) {
        line.classList.add('selected');
      }
      svg.appendChild(line);

      // Hitbox invisible para clicks
      const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      hitbox.setAttribute('x1', x1);
      hitbox.setAttribute('y1', y1);
      hitbox.setAttribute('x2', x2);
      hitbox.setAttribute('y2', y2);
      hitbox.setAttribute('data-edge-id', edge.id || `e_${edge.from}__${edge.to}`);
      hitbox.classList.add('hitbox');
      hitbox.addEventListener('click', (e) => {
        e.stopPropagation();
        const edgeId = hitbox.getAttribute('data-edge-id');
        navState.selectedEdgeId = edgeId;
        navState.selectedNodeId = null;
        renderCanvas();
        renderNodeProperties();
      });
      svg.appendChild(hitbox);
    });

    // Habilitar pointer events en el SVG para clicks en edges
    svg.style.pointerEvents = 'all';
  }

  // ========================================================================
  // DRAG NODOS
  // ========================================================================
  function startDragNode(e, nodeId) {
    const node = navState.canvas.nodes.find(n => n.id === nodeId);
    if (!node) return;

    // Si hay m√∫ltiples nodos seleccionados, asegurar que este est√© incluido
    if (navState.selectedNodeIds.length > 1 && !navState.selectedNodeIds.includes(nodeId)) {
      selectNode(nodeId); // Cambiar a selecci√≥n simple
    }

    navState.isDragging = true;
    
    // Calcular offset desde la posici√≥n del nodo primario
    const primaryNode = navState.selectedNodeIds.length > 1 
      ? navState.canvas.nodes.find(n => n.id === navState.selectedNodeIds[0]) || node
      : node;
    
    const stage = document.getElementById('nav-canvas-stage');
    const rect = stage.getBoundingClientRect();
    const worldX = (e.clientX - rect.left - navState.panX) / navState.zoom;
    const worldY = (e.clientY - rect.top - navState.panY) / navState.zoom;
    
    navState.dragStart = {
      x: worldX - primaryNode.position.x,
      y: worldY - primaryNode.position.y
    };

    document.addEventListener('mousemove', handleDragNode);
  }

  function handleDragNode(e) {
    if (!navState.isDragging) return;
    
    // Si hay m√∫ltiples nodos seleccionados, mover todos
    const nodesToMove = navState.selectedNodeIds.length > 1 
      ? navState.canvas.nodes.filter(n => navState.selectedNodeIds.includes(n.id))
      : [navState.canvas.nodes.find(n => n.id === navState.selectedNodeId)];
    
    if (nodesToMove.length === 0 || !nodesToMove[0]) return;
    
    const primaryNode = nodesToMove[0];
    const stage = document.getElementById('nav-canvas-stage');
    const rect = stage.getBoundingClientRect();
    const worldX = (e.clientX - rect.left - navState.panX) / navState.zoom;
    const worldY = (e.clientY - rect.top - navState.panY) / navState.zoom;
    
    // Calcular nueva posici√≥n del nodo primario
    const newPrimaryX = Math.max(0, worldX - navState.dragStart.x);
    const newPrimaryY = Math.max(0, worldY - navState.dragStart.y);
    
    // Calcular delta
    const deltaX = newPrimaryX - primaryNode.position.x;
    const deltaY = newPrimaryY - primaryNode.position.y;
    
    // Mover todos los nodos seleccionados
    nodesToMove.forEach(node => {
      node.position.x = snapToGrid(node.position.x + deltaX);
      node.position.y = snapToGrid(node.position.y + deltaY);
      
      // Actualizar visualmente
      const nodeEl = document.getElementById(`nav-node-${node.id}`);
      if (nodeEl) {
        nodeEl.style.left = `${node.position.x}px`;
        nodeEl.style.top = `${node.position.y}px`;
      }
    });
    
    // Actualizar edges en tiempo real
    renderEdges();
  }

  // ========================================================================
  // TRANSFORM Y ZOOM
  // ========================================================================
  function updateStageTransform() {
    const stage = document.getElementById('nav-canvas-stage');
    if (stage) {
      stage.style.transform = `translate(${navState.panX}px, ${navState.panY}px) scale(${navState.zoom})`;
    }
    // SVG tambi√©n debe transformarse
    const svg = document.getElementById('nav-edges-svg');
    if (svg) {
      svg.style.transform = `translate(${navState.panX}px, ${navState.panY}px) scale(${navState.zoom})`;
    }
  }

  function updateZoomIndicator() {
    const indicator = document.getElementById('zoom-level');
    if (indicator) {
      indicator.textContent = `${Math.round(navState.zoom * 100)}%`;
    }
  }

  function zoomInCanvas() {
    navState.zoom = Math.min(3, navState.zoom * 1.2);
    updateStageTransform();
    updateZoomIndicator();
  }

  function zoomOutCanvas() {
    navState.zoom = Math.max(0.3, navState.zoom / 1.2);
    updateStageTransform();
    updateZoomIndicator();
  }

  function resetCanvasView() {
    navState.panX = 0;
    navState.panY = 0;
    navState.zoom = 1;
    updateStageTransform();
    updateZoomIndicator();
  }

  // ========================================================================
  // SELECCI√ìN Y PANEL
  // ========================================================================
  function selectNode(nodeId) {
    navState.selectedNodeId = nodeId;
    navState.selectedNodeIds = [nodeId]; // Mantener compatibilidad con multi-select
    navState.selectedEdgeId = null; // Deseleccionar edge si hay uno
    renderCanvas(); // Re-render para actualizar selected class
    renderNodeProperties();
    computeAndRenderWarnings();
  }
  
  function selectNodes(nodeIds) {
    navState.selectedNodeIds = Array.isArray(nodeIds) ? nodeIds : [nodeIds];
    navState.selectedNodeId = navState.selectedNodeIds[0] || null;
    navState.selectedEdgeId = null;
    renderCanvas();
    renderNodeProperties();
    computeAndRenderWarnings();
  }
  
  function clearSelection() {
    navState.selectedNodeId = null;
    navState.selectedNodeIds = [];
    navState.selectedEdgeId = null;
    renderCanvas();
    renderNodeProperties();
    computeAndRenderWarnings();
  }

  function renderNodeProperties() {
    const propsPanel = document.getElementById('nav-props');
    if (!propsPanel) return;

    // Si hay edge seleccionado, mostrar propiedades del edge
    if (navState.selectedEdgeId) {
      const edge = navState.canvas.edges.find(e => e.id === navState.selectedEdgeId);
      if (edge) {
        const fromNode = navState.canvas.nodes.find(n => n.id === edge.from);
        const toNode = navState.canvas.nodes.find(n => n.id === edge.to);
        propsPanel.innerHTML = renderEdgeProperties(edge, fromNode, toNode);
        return;
      }
    }

    // Si hay m√∫ltiples nodos seleccionados
    if (navState.selectedNodeIds.length > 1) {
      propsPanel.innerHTML = renderMultiNodeProperties();
      return;
    }

    const node = navState.canvas.nodes.find(n => n.id === navState.selectedNodeId);
    if (!node) {
      propsPanel.innerHTML = `
        <div class="nav-props-placeholder">
          <p>Selecciona un nodo o edge del canvas para editarlo</p>
          <p class="nav-hint">
            üí° Arrastra nodos para moverlos<br/>
            üí° CTRL + rueda para zoom<br/>
            üí° Shift + arrastra fondo para selecci√≥n m√∫ltiple<br/>
            üí° Click en edge para seleccionarlo<br/>
            üí° Modo Conectar para crear edges
          </p>
        </div>
      `;
      return;
    }

    // Panel estilo IDE con secciones colapsables
    propsPanel.innerHTML = renderNodePropertiesIDE(node);
  }
  
  function renderNodePropertiesIDE(node) {
    const sections = navState.ui.panelSections;
    const nodeTarget = node.target || {};
    const nodeVisibility = node.visibility_rules || {};
    const nodeMeta = node.meta || {};
    
    // Determinar campos de target seg√∫n semantic_type
    const targetType = nodeTarget.type || '';
    const targetRef = nodeTarget.ref || '';
    const targetUrl = nodeTarget.url || (nodeTarget.type === 'url' ? nodeTarget.ref : '');
    
    return `
      <div class="nav-ide-panel">
        ${renderCollapsibleSection('basic', 'B√°sico', sections.basic, `
          <div class="nav-form-group">
            <label class="nav-form-label">ID</label>
            <input type="text" class="nav-form-input" value="${escapeHtml(node.id)}" readonly>
          </div>
          <div class="nav-form-group">
            <label class="nav-form-label">Label</label>
            <input type="text" class="nav-form-input" id="node-label-input" value="${escapeHtml(node.label || '')}" 
                   onchange="updateNodeProperty('label', this.value)">
          </div>
          <div class="nav-form-group">
            <label class="nav-form-label">Semantic Type</label>
            <select class="nav-form-select" id="node-type-input" onchange="updateNodeSemanticType(this.value)">
              <option value="" ${!node.type ? 'selected' : ''}>-</option>
              <option value="home" ${node.type === 'home' ? 'selected' : ''}>Home</option>
              <option value="entry" ${node.type === 'entry' ? 'selected' : ''}>Entry</option>
              <option value="section" ${node.type === 'section' ? 'selected' : ''}>Section</option>
              <option value="view" ${node.type === 'view' ? 'selected' : ''}>View</option>
              <option value="external" ${node.type === 'external' ? 'selected' : ''}>External</option>
              <option value="overlay" ${node.type === 'overlay' ? 'selected' : ''}>Overlay</option>
              <option value="return" ${node.type === 'return' ? 'selected' : ''}>Return</option>
            </select>
          </div>
          <div class="nav-form-group">
            <label class="nav-form-label">Kind</label>
            <input type="text" class="nav-form-input" value="${escapeHtml(node.kind || '')}" readonly>
          </div>
        `)}
        
        ${renderCollapsibleSection('target', 'Target', sections.target, `
          ${renderTargetFields(node.type || '', targetType, targetRef, targetUrl)}
        `)}
        
        ${renderCollapsibleSection('visibility', 'Visibilidad', sections.visibility, `
          <div class="nav-form-group">
            <label class="nav-form-label">Min Level</label>
            <input type="number" class="nav-form-input" id="node-visibility-min-level" 
                   value="${nodeVisibility.min_level || ''}" 
                   onchange="updateVisibilityRule('min_level', this.value ? parseInt(this.value) : undefined)">
          </div>
          <div class="nav-form-group">
            <label class="nav-form-label">Max Level</label>
            <input type="number" class="nav-form-input" id="node-visibility-max-level" 
                   value="${nodeVisibility.max_level || ''}" 
                   onchange="updateVisibilityRule('max_level', this.value ? parseInt(this.value) : undefined)">
          </div>
          <div class="nav-form-group">
            <label class="nav-form-label">Feature Flags (JSON array)</label>
            <textarea class="nav-form-textarea" id="node-visibility-flags" 
                      onchange="updateVisibilityRule('flags', this.value)">${escapeHtml(JSON.stringify(nodeVisibility.flags || [], null, 2))}</textarea>
          </div>
        `)}
        
        ${renderCollapsibleSection('meta', 'Meta JSON', sections.meta, `
          <div class="nav-form-group">
            <label class="nav-form-label">Meta (JSON)</label>
            <textarea class="nav-form-textarea" id="node-meta-input" 
                      onchange="updateNodeProperty('meta', this.value)">${escapeHtml(JSON.stringify(nodeMeta, null, 2))}</textarea>
          </div>
        `)}
        
        ${renderCollapsibleSection('diagnostics', 'Diagn√≥stico', sections.diagnostics, `
          <div id="node-diagnostics-content">
            ${renderNodeDiagnostics(node)}
          </div>
          <div class="nav-quick-actions">
            <button class="nav-action-btn" onclick="markAsEntry('${node.id}')" title="Marcar como Entry">
              üè† Entry
            </button>
            <button class="nav-action-btn" onclick="markAsHome('${node.id}')" title="Marcar como Home">
              üè° Home
            </button>
            <button class="nav-action-btn" onclick="duplicateNode('${node.id}')" title="Duplicar nodo">
              üìã Duplicar
            </button>
            <button class="nav-action-btn" onclick="centerSelection()" title="Centrar en vista">
              üéØ Centrar
            </button>
          </div>
        `)}
      </div>
    `;
  }
  
  function renderCollapsibleSection(sectionId, title, isOpen, content) {
    return `
      <div class="nav-ide-section">
        <div class="nav-ide-section-header" onclick="togglePanelSection('${sectionId}')">
          <span class="nav-ide-section-title">${title}</span>
          <span class="nav-ide-section-toggle">${isOpen ? '‚ñº' : '‚ñ∂'}</span>
        </div>
        <div class="nav-ide-section-content" style="display: ${isOpen ? 'block' : 'none'}">
          ${content}
        </div>
      </div>
    `;
  }
  
  function renderTargetFields(semanticType, targetType, targetRef, targetUrl) {
    if (semanticType === 'external') {
      return `
        <div class="nav-form-group">
          <label class="nav-form-label">URL</label>
          <input type="text" class="nav-form-input" id="node-target-url" 
                 value="${escapeHtml(targetUrl)}" 
                 onchange="updateTargetField('url', this.value)">
        </div>
      `;
    } else if (semanticType === 'return' || semanticType === 'overlay') {
      return `
        <div class="nav-form-group">
          <label class="nav-form-label">Acci√≥n</label>
          <input type="text" class="nav-form-input" id="node-target-action" 
                 value="${escapeHtml(targetRef)}" 
                 onchange="updateTargetField('action', this.value)">
        </div>
      `;
    } else {
      return `
        <div class="nav-form-group">
          <label class="nav-form-label">Target Type</label>
          <select class="nav-form-select" id="node-target-type" onchange="updateTargetField('type', this.value)">
            <option value="">-</option>
            <option value="recorrido" ${targetType === 'recorrido' ? 'selected' : ''}>Recorrido</option>
            <option value="pde_catalog" ${targetType === 'pde_catalog' ? 'selected' : ''}>PDE Catalog</option>
            <option value="screen" ${targetType === 'screen' ? 'selected' : ''}>Screen</option>
            <option value="url" ${targetType === 'url' ? 'selected' : ''}>URL</option>
            <option value="admin_tool" ${targetType === 'admin_tool' ? 'selected' : ''}>Admin Tool</option>
          </select>
        </div>
        <div class="nav-form-group">
          <label class="nav-form-label">Target Ref</label>
          <input type="text" class="nav-form-input" id="node-target-ref" 
                 value="${escapeHtml(targetRef)}" 
                 onchange="updateTargetField('ref', this.value)">
        </div>
      `;
    }
  }
  
  function renderEdgeProperties(edge, fromNode, toNode) {
    return `
      <div class="nav-ide-panel">
        <div class="nav-ide-section">
          <div class="nav-ide-section-header">
            <span class="nav-ide-section-title">Edge Properties</span>
          </div>
          <div class="nav-ide-section-content">
            <div class="nav-form-group">
              <label class="nav-form-label">Edge ID</label>
              <input type="text" class="nav-form-input" value="${escapeHtml(edge.id)}" readonly>
            </div>
            <div class="nav-form-group">
              <label class="nav-form-label">Desde</label>
              <input type="text" class="nav-form-input" value="${escapeHtml(fromNode?.label || edge.from)}" readonly>
            </div>
            <div class="nav-form-group">
              <label class="nav-form-label">Hacia</label>
              <input type="text" class="nav-form-input" value="${escapeHtml(toNode?.label || edge.to)}" readonly>
            </div>
            <div class="nav-form-group">
              <label class="nav-form-label">Kind</label>
              <input type="text" class="nav-form-input" value="${escapeHtml(edge.kind || 'child')}" readonly>
            </div>
            <button class="nav-form-btn" onclick="deleteEdge('${edge.id}')">üóëÔ∏è Eliminar edge</button>
          </div>
        </div>
      </div>
    `;
  }
  
  function renderMultiNodeProperties() {
    return `
      <div class="nav-ide-panel">
        <div class="nav-ide-section">
          <div class="nav-ide-section-header">
            <span class="nav-ide-section-title">M√∫ltiples Nodos Seleccionados</span>
          </div>
          <div class="nav-ide-section-content">
            <p>${navState.selectedNodeIds.length} nodos seleccionados</p>
            <button class="nav-form-btn" onclick="deleteSelectedNodes()">üóëÔ∏è Eliminar selecci√≥n</button>
            <button class="nav-action-btn" onclick="centerSelection()">üéØ Centrar</button>
          </div>
        </div>
      </div>
    `;
  }
  
  function renderNodeDiagnostics(node) {
    const nodeWarnings = navState.warnings.nodes[node.id] || [];
    if (nodeWarnings.length === 0) {
      return '<p class="nav-diagnostic-ok">‚úì Sin warnings para este nodo</p>';
    }
    return `
      <ul class="nav-warnings-list">
        ${nodeWarnings.map(w => `<li class="nav-warning-item">‚ö†Ô∏è ${escapeHtml(w)}</li>`).join('')}
      </ul>
    `;
  }

  function updateNodeProperty(prop, value) {
    const node = navState.canvas.nodes.find(n => n.id === navState.selectedNodeId);
    if (!node) return;

    try {
      if (prop === 'target' || prop === 'visibility_rules' || prop === 'meta') {
        node[prop] = JSON.parse(value);
      } else {
        node[prop] = value;
      }
      markDirty();
      scheduleAutosave('property-change');
      renderCanvas();
      computeAndRenderWarnings();
    } catch (e) {
      console.error('[AXE][NAV2] Error actualizando propiedad:', e);
      showToast('Error al actualizar: ' + e.message, 'error');
    }
  }
  
  function updateNodeSemanticType(newType) {
    const node = navState.canvas.nodes.find(n => n.id === navState.selectedNodeId);
    if (!node) return;
    
    // Conservar datos previos en meta si cambia el tipo
    const oldType = node.type;
    node.type = newType || undefined;
    
    // Si cambia a external, inicializar target.url si no existe
    if (newType === 'external' && (!node.target || !node.target.url)) {
      if (!node.target) node.target = {};
      if (!node.target.url) node.target.url = '';
    }
    
    markDirty();
    scheduleAutosave('semantic-type-change');
    renderNodeProperties(); // Re-render para actualizar campos din√°micos
    computeAndRenderWarnings();
    console.log('[AXE][NAV2] semantic_type cambiado:', oldType, '->', newType);
  }
  
  function updateTargetField(field, value) {
    const node = navState.canvas.nodes.find(n => n.id === navState.selectedNodeId);
    if (!node) return;
    
    if (!node.target) node.target = {};
    
    if (field === 'url') {
      node.target.type = 'url';
      node.target.ref = value;
      node.target.url = value;
    } else if (field === 'action') {
      node.target.type = 'action';
      node.target.ref = value;
    } else {
      node.target[field] = value;
    }
    
    markDirty();
    scheduleAutosave('target-change');
    computeAndRenderWarnings();
  }
  
  function updateVisibilityRule(field, value) {
    const node = navState.canvas.nodes.find(n => n.id === navState.selectedNodeId);
    if (!node) return;
    
    if (!node.visibility_rules) node.visibility_rules = {};
    
    if (field === 'flags') {
      try {
        node.visibility_rules.flags = JSON.parse(value);
      } catch (e) {
        console.error('[AXE][NAV2] Error parseando flags:', e);
        return;
      }
    } else {
      if (value === undefined || value === null || value === '') {
        delete node.visibility_rules[field];
      } else {
        node.visibility_rules[field] = value;
      }
    }
    
    markDirty();
    scheduleAutosave('visibility-change');
    computeAndRenderWarnings();
  }
  
  function togglePanelSection(sectionId) {
    navState.ui.panelSections[sectionId] = !navState.ui.panelSections[sectionId];
    savePanelSectionsState();
    renderNodeProperties();
  }
  
  function loadPanelSectionsState() {
    try {
      const saved = localStorage.getItem('ap_nav_editor_panel_sections');
      if (saved) {
        const parsed = JSON.parse(saved);
        navState.ui.panelSections = { ...navState.ui.panelSections, ...parsed };
      }
    } catch (e) {
      console.error('[AXE][NAV2] Error cargando estado de secciones:', e);
    }
  }
  
  function savePanelSectionsState() {
    try {
      localStorage.setItem('ap_nav_editor_panel_sections', JSON.stringify(navState.ui.panelSections));
    } catch (e) {
      console.error('[AXE][NAV2] Error guardando estado de secciones:', e);
    }
  }

  function deleteNode(nodeId) {
    const node = navState.canvas.nodes.find(n => n.id === nodeId);
    if (!node) return;

    // Guardarra√≠les: si es entry/home, warning
    if (navState.navDef && navState.navDef.entry_node_id === nodeId) {
      if (!confirm('‚ö†Ô∏è Este nodo es el nodo de entrada. ¬øEst√°s seguro de eliminarlo?')) {
        return;
      }
    }

    // Eliminar nodo
    navState.canvas.nodes = navState.canvas.nodes.filter(n => n.id !== nodeId);
    // Eliminar edges incidentes
    navState.canvas.edges = navState.canvas.edges.filter(e => e.from !== nodeId && e.to !== nodeId);
    
    if (navState.selectedNodeId === nodeId) {
      navState.selectedNodeId = null;
    }

    markDirty();
    scheduleAutosave('node-delete');
    renderCanvas();
    renderNodeProperties();
  }

  // ========================================================================
  // DIRTY STATE & AUTOSAVE
  // ========================================================================
  function normalizeNavDef(navDef) {
    if (!navDef) return {};
    
    const normalized = {
      navigation_id: navDef.navigation_id || '',
      name: navDef.name || '',
      entry_node_id: navDef.entry_node_id || '',
      nodes: {},
      edges: []
    };

    // Normalizar nodos (orden determinista por id)
    if (navDef.nodes) {
      const nodeIds = Object.keys(navDef.nodes).sort();
      nodeIds.forEach(id => {
        const node = navDef.nodes[id];
        normalized.nodes[id] = {
          id: node.id || id,
          label: node.label || '',
          type: node.type || '',
          kind: node.kind || '',
          target: node.target || {},
          visibility_rules: node.visibility_rules || {},
          meta: node.meta || {},
          position: node.position || { x: 0, y: 0 }
        };
      });
    }

    // Normalizar edges (orden determinista por from|to)
    if (navDef.edges) {
      normalized.edges = navDef.edges
        .map(e => ({
          from: e.from || '',
          to: e.to || '',
          kind: e.kind || 'child',
          id: e.id || `e_${e.from}__${e.to}`
        }))
        .sort((a, b) => {
          const keyA = `${a.from}|${a.to}`;
          const keyB = `${b.from}|${b.to}`;
          return keyA.localeCompare(keyB);
        });
    }

    return normalized;
  }

  function stableStringify(obj) {
    return JSON.stringify(normalizeNavDef(obj));
  }

  function updateSavedSnapshot() {
    const navDef = convertCanvasToNavDef();
    navState.save.lastSavedSnapshot = stableStringify(navDef);
    navState.isDirty = false;
    updateUI();
    console.log('[AXE][NAV2] Snapshot actualizado');
  }

  function checkDirtyState() {
    const navDef = convertCanvasToNavDef();
    const currentSnapshot = stableStringify(navDef);
    const isDirty = currentSnapshot !== navState.save.lastSavedSnapshot;
    
    if (isDirty !== navState.isDirty) {
      navState.isDirty = isDirty;
      updateUI();
    }
    
    return isDirty;
  }

  function scheduleAutosave(reason = 'change') {
    if (navState.save.inFlight) {
      navState.save.queued = true;
      console.log('[AXE][NAV2] autosave scheduled (queued, save in flight)');
      return;
    }

    // Limpiar timer anterior
    if (navState.save.autosaveTimer) {
      clearTimeout(navState.save.autosaveTimer);
    }

    // Verificar dirty state
    if (!checkDirtyState()) {
      console.log('[AXE][NAV2] autosave skipped (not dirty)');
      return;
    }

    console.log('[AXE][NAV2] autosave scheduled', reason);
    
    // Programar autosave
    navState.save.autosaveTimer = setTimeout(() => {
      console.log('[AXE][NAV2] autosave fired');
      saveDraftNow({ autosave: true, reason });
    }, 2000);
  }

  // ========================================================================
  // CARGA Y GUARDADO
  // ========================================================================
  async function loadNavigation(navId) {
    try {
      console.log('[AXE][NAV2] Cargando navegaci√≥n:', navId);
      
      const encodedId = encodeURIComponent(navId);
      
      // Cargar draft
      let response = await fetch(`/admin/api/navigation/${encodedId}/draft`);
      let navDef = null;
      
      if (response.ok) {
        const data = await response.json();
        if (data.ok && data.data.draft_json) {
          navDef = data.data.draft_json;
        }
      }
      
      // Si no hay draft, intentar published
      if (!navDef) {
        response = await fetch(`/admin/api/navigation/${encodedId}/published`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok && data.data.definition_json) {
            navDef = data.data.definition_json;
            navState.publishedVersion = {
              version: data.data.version,
              published_at: data.data.published_at,
            };
          }
        }
      } else {
        // Si hay draft, tambi√©n cargar published para mostrar versi√≥n
        response = await fetch(`/admin/api/navigation/${encodedId}/published`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok && data.data.definition_json) {
            navState.publishedVersion = {
              version: data.data.version,
              published_at: data.data.published_at,
            };
          }
        }
      }

      if (!navDef) {
        throw new Error(`No se pudo cargar navegaci√≥n: ${response.status}`);
      }

      navState.navDef = navDef;

      // Convertir navDef a canvas
      convertNavDefToCanvas(navDef);

      // Actualizar UI
      const nameEl = document.getElementById('navigation-name');
      if (nameEl) nameEl.textContent = navDef.name || navId;
      
      const idBadge = document.getElementById('navigation-id-badge');
      if (idBadge) idBadge.textContent = navId;

      // Actualizar badge de published
      updatePublishedStatus();

      // Inicializar snapshot despu√©s de cargar
      updateSavedSnapshot();

      console.log('[AXE][NAV2] Navegaci√≥n cargada:', navState.canvas.nodes.length, 'nodos');
    } catch (error) {
      console.error('[AXE][NAV2] Error cargando navegaci√≥n:', error);
      showError('Error al cargar navegaci√≥n: ' + error.message);
      // Fail-open: crear m√≠nima
      createMinimalNavigation();
    }
  }

  function convertNavDefToCanvas(navDef) {
    navState.canvas.nodes = [];
    navState.canvas.edges = [];

    // Convertir nodos
    if (navDef.nodes) {
      Object.values(navDef.nodes).forEach(node => {
        navState.canvas.nodes.push({
          id: node.id,
          label: node.label || node.id,
          type: node.type,
          kind: node.kind,
          target: node.target || {},
          visibility_rules: node.visibility_rules || {},
          meta: node.meta || {},
          position: node.position || { x: 120, y: 120 }
        });
      });
    }

    // Convertir edges
    if (navDef.edges) {
      navDef.edges.forEach(edge => {
        navState.canvas.edges.push({
          id: edge.id || `e_${edge.from}__${edge.to}`,
          from: edge.from,
          to: edge.to,
          kind: edge.kind || 'child'
        });
      });
    }
  }

  function convertCanvasToNavDef() {
    if (!navState.navDef) {
      navState.navDef = {
        navigation_id: navState.navigationId,
        name: 'Nueva Navegaci√≥n',
        entry_node_id: navState.canvas.nodes[0]?.id || 'home',
        nodes: {},
        edges: []
      };
    }

    // Actualizar nodos con posiciones
    navState.canvas.nodes.forEach(node => {
      navState.navDef.nodes[node.id] = {
        id: node.id,
        label: node.label,
        type: node.type,
        kind: node.kind,
        target: node.target || {},
        visibility_rules: node.visibility_rules || {},
        meta: node.meta || {},
        position: node.position
      };
    });

    // Actualizar edges
    navState.navDef.edges = navState.canvas.edges.map(e => ({
      id: e.id || `e_${e.from}__${e.to}`,
      from: e.from,
      to: e.to,
      kind: e.kind || 'child'
    }));

    return navState.navDef;
  }

  async function guardarNavegacion() {
    await saveDraftNow({ manual: true });
  }

  async function saveDraftNow({ manual = false, autosave = false, reason = 'manual' } = {}) {
    try {
      if (navState.save.inFlight) {
        navState.save.queued = true;
        console.log('[AXE][NAV2] save in flight, queued');
        return;
      }

      navState.save.inFlight = true;
      console.log('[AXE][NAV2] Guardando navegaci√≥n...', { manual, autosave, reason });
      
      const navDef = convertCanvasToNavDef();
      const encodedId = encodeURIComponent(navState.navigationId);

      const response = await fetch(`/admin/api/navigation/${encodedId}/draft`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ draft_json: navDef })
      });

      if (!response.ok) {
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('text/html')) {
          throw new Error('Error del servidor (HTML recibido en lugar de JSON)');
        }
        const error = await response.json().catch(() => ({ error: { message: 'Error desconocido' } }));
        throw new Error(error.error?.message || 'Error al guardar');
      }

      const data = await response.json();
      if (!data.ok) {
        throw new Error(data.error?.message || 'Error al guardar');
      }

      // Actualizar snapshot
      updateSavedSnapshot();

      if (manual) {
        showToast('‚úì Guardado correctamente', 'success');
      }
      console.log('[AXE][NAV2] save ok');
    } catch (error) {
      console.error('[AXE][NAV2] save error:', error);
      if (manual) {
        showToast('Error al guardar: ' + error.message, 'error');
      } else {
        showError('Error en autosave: ' + error.message);
      }
    } finally {
      navState.save.inFlight = false;
      
      // Si hay cambios en cola, guardar de nuevo
      if (navState.save.queued) {
        navState.save.queued = false;
        console.log('[AXE][NAV2] save queued, firing immediate save');
        setTimeout(() => saveDraftNow({ autosave: true, reason: 'queued' }), 100);
      }
    }
  }

  async function validarNavegacion() {
    try {
      const navDef = convertCanvasToNavDef();
      const encodedId = encodeURIComponent(navState.navigationId);

      const response = await fetch(`/admin/api/navigation/${encodedId}/validate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ draft_json: navDef })
      });

      const data = await response.json();
      if (data.ok && data.data.ok) {
        showToast('‚úì Validaci√≥n exitosa', 'success');
      } else {
        const errors = data.data?.errors || [];
        showToast('Errores de validaci√≥n: ' + errors.length, 'error');
      }
    } catch (error) {
      showToast('Error al validar: ' + error.message, 'error');
    }
  }

  async function publicarNavegacion() {
    // Verificar que no hay cambios sin guardar
    if (navState.isDirty) {
      showToast('‚ö†Ô∏è Guarda los cambios antes de publicar', 'error');
      return;
    }

    if (!confirm('¬øPublicar esta navegaci√≥n? Esta acci√≥n crear√° una nueva versi√≥n inmutable.')) return;

    try {
      const encodedId = encodeURIComponent(navState.navigationId);
      const response = await fetch(`/admin/api/navigation/${encodedId}/publish`, {
        method: 'POST'
      });

      const data = await response.json();
      if (data.ok) {
        // Actualizar versi√≥n publicada
        navState.publishedVersion = {
          version: data.data.version,
          published_at: data.data.published_at,
        };
        updatePublishedStatus();
        showToast(`‚úì Publicado v${data.data.version} correctamente`, 'success');
      } else {
        // Mostrar errores de validaci√≥n en modal/listado bonito
        const errors = data.error?.details?.errors || [data.error?.message || 'Error desconocido'];
        if (Array.isArray(errors) && errors.length > 0) {
          showValidationErrors(errors);
        } else {
          showToast('Error al publicar: ' + (data.error?.message || 'Error desconocido'), 'error');
        }
      }
    } catch (error) {
      showToast('Error al publicar: ' + error.message, 'error');
    }
  }

  function showValidationErrors(errors) {
    // Crear modal con errores
    const modal = document.createElement('div');
    modal.className = 'nav-error-modal';
    modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center;';
    
    const content = document.createElement('div');
    content.style.cssText = 'background: var(--bg-card, #1e293b); padding: 24px; border-radius: 8px; max-width: 600px; max-height: 80vh; overflow-y: auto;';
    
    content.innerHTML = `
      <h2 style="margin: 0 0 16px 0; color: var(--text-primary, #fff);">‚ùå Errores de Validaci√≥n</h2>
      <p style="margin: 0 0 16px 0; color: var(--text-muted, #94a3b8);">La navegaci√≥n no puede publicarse debido a los siguientes errores:</p>
      <ul style="margin: 0 0 16px 0; padding-left: 24px; color: var(--text-primary, #fff);">
        ${errors.map(e => `<li style="margin: 8px 0;">${e}</li>`).join('')}
      </ul>
      <button onclick="this.closest('.nav-error-modal').remove()" style="padding: 8px 16px; background: var(--accent-primary, #3b82f6); color: white; border: none; border-radius: 4px; cursor: pointer;">Cerrar</button>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
  }

  // ========================================================================
  // VISTAS
  // ========================================================================
  function setNavigationView(view) {
    navState.view = view;

    // Actualizar tabs
    ['mapa', 'arbol', 'json', 'preview'].forEach(v => {
      const tab = document.getElementById(`tab-${v}`);
      if (tab) {
        tab.classList.toggle('active', v === view);
      }
    });

    // Mostrar/ocultar vistas
    const canvasArea = document.getElementById('nav-canvas-area');
    const rightPanel = document.getElementById('nav-right-panel');

    if (view === 'mapa') {
      canvasArea.style.display = 'flex';
      rightPanel.style.display = 'flex';
      renderCanvas();
    } else if (view === 'arbol') {
      canvasArea.style.display = 'none';
      rightPanel.style.display = 'flex';
      renderTreeView();
    } else if (view === 'json') {
      canvasArea.style.display = 'none';
      rightPanel.style.display = 'none';
      renderJsonView();
    } else if (view === 'preview') {
      canvasArea.style.display = 'none';
      rightPanel.style.display = 'none';
      renderPreviewView();
    }
  }

  function renderTreeView() {
    const propsPanel = document.getElementById('nav-props');
    if (!propsPanel) return;

    let html = '<div class="nav-tree-view"><div class="nav-tree-sidebar">';
    
    navState.canvas.nodes.forEach(node => {
      html += `<div class="nav-tree-item ${node.id === navState.selectedNodeId ? 'selected' : ''}" 
                      onclick="selectNode('${node.id}'); setNavigationView('mapa')">
        ${escapeHtml(node.label || node.id)}
      </div>`;
    });

    html += '</div><div class="nav-props">';
    html += navState.selectedNodeId ? renderNodePropertiesHTML() : '<p>Selecciona un nodo</p>';
    html += '</div></div>';

    propsPanel.innerHTML = html;
  }

  function renderJsonView() {
    const body = document.querySelector('.nav-editor-body');
    if (!body) return;

    const navDef = convertCanvasToNavDef();
    const jsonStr = JSON.stringify(navDef, null, 2);

    body.innerHTML = `
      <div class="nav-json-view">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <h2 style="color: #fff; margin: 0;">Vista JSON (Read-Only)</h2>
          <button onclick="copiarJSON()" class="nav-btn nav-btn-primary">üìã Copiar</button>
        </div>
        <textarea class="nav-json-textarea" readonly>${escapeHtml(jsonStr)}</textarea>
      </div>
    `;
  }

  // ========================================================================
  // PREVIEW EFECTIVO
  // ========================================================================
  
  /**
   * Normaliza respuesta del endpoint preview-effective
   * Acepta m√∫ltiples shapes legacy y devuelve siempre { effectiveDef, warnings }
   */
  function normalizePreviewResponse(resp) {
    try {
      // Shape can√≥nico: { ok: true, effective: {...}, warnings: [] }
      if (resp.ok && resp.effective) {
        return {
          effectiveDef: resp.effective,
          warnings: resp.warnings || []
        };
      }

      // Shape legacy: { ok: true, data: {...} }
      if (resp.ok && resp.data) {
        console.log('[AXE][NAV2][PREVIEW] normalized legacy shape: { ok, data }');
        // Si data tiene navigation, usar eso
        if (resp.data.navigation) {
          return {
            effectiveDef: resp.data.navigation,
            warnings: resp.data.warnings || []
          };
        }
        // Si data es directamente la navegaci√≥n
        return {
          effectiveDef: resp.data,
          warnings: resp.warnings || []
        };
      }

      // Shape legacy: { ok: true, effectiveDef: {...} }
      if (resp.ok && resp.effectiveDef) {
        console.log('[AXE][NAV2][PREVIEW] normalized legacy shape: { ok, effectiveDef }');
        return {
          effectiveDef: resp.effectiveDef,
          warnings: resp.warnings || []
        };
      }

      // Error shape: { ok: false, error: "...", fallback: {...} }
      if (!resp.ok && resp.fallback) {
        return {
          effectiveDef: resp.fallback,
          warnings: [resp.error || 'Error al cargar preview efectivo']
        };
      }

      // Fallback: asumir que resp es directamente la navegaci√≥n
      return {
        effectiveDef: resp,
        warnings: []
      };
    } catch (error) {
      console.error('[AXE][NAV2][PREVIEW] Error normalizando respuesta:', error);
      return {
        effectiveDef: null,
        warnings: ['Error normalizando respuesta del preview']
      };
    }
  }

  async function renderPreviewView() {
    const body = document.querySelector('.nav-editor-body');
    if (!body) return;

    // Mostrar loading
    body.innerHTML = `
      <div class="nav-preview-view">
        <div style="text-align: center; padding: 40px;">
          <p>Cargando preview efectivo...</p>
        </div>
      </div>
    `;

    try {
      const navigationId = navState.navigationId;
      if (!navigationId || navigationId === 'new') {
        body.innerHTML = `
          <div class="nav-preview-view">
            <div style="text-align: center; padding: 40px;">
              <p>‚ö†Ô∏è Guarda la navegaci√≥n primero para ver el preview efectivo</p>
            </div>
          </div>
        `;
        return;
      }

      // Obtener context_key del selector (si existe)
      const contextKeySelect = document.getElementById('preview-context-select');
      const contextKey = contextKeySelect ? contextKeySelect.value : null;

      // Llamar al endpoint
      const encodedId = encodeURIComponent(navigationId);
      const url = `/admin/api/navigation/preview-effective?navigation_id=${encodedId}${contextKey ? '&context_key=' + encodeURIComponent(contextKey) : ''}`;
      
      console.log('[AXE][NAV2][PREVIEW] fetching preview-effective:', url);
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      
      // Normalizar respuesta
      const normalized = normalizePreviewResponse(data);
      
      if (!normalized.effectiveDef) {
        throw new Error('No se pudo obtener navegaci√≥n efectiva');
      }

      // Renderizar preview efectivo
      renderPreviewEffective(normalized.effectiveDef, normalized.warnings, contextKey);
    } catch (error) {
      console.error('[AXE][NAV2][PREVIEW] Error cargando preview:', error);
      
      // Fail-open: mostrar base navigation con banner
      const baseNav = convertCanvasToNavDef();
      body.innerHTML = `
        <div class="nav-preview-view">
          <div class="nav-error-banner" style="display: block; margin: 16px;">
            ‚ö†Ô∏è Preview efectivo no disponible. Mostrando base. Error: ${escapeHtml(error.message)}
          </div>
          <div id="preview-canvas-container" style="flex: 1; overflow: hidden;">
            ${renderPreviewCanvas(baseNav, [], null)}
          </div>
        </div>
      `;
    }
  }

  function renderPreviewEffective(effectiveDef, warnings, contextKey) {
    const body = document.querySelector('.nav-editor-body');
    if (!body) return;

    // Obtener context keys disponibles
    const availableContextKeys = [];
    // TODO: cargar desde endpoint o estado global

    body.innerHTML = `
      <div class="nav-preview-view" style="display: flex; flex-direction: column; height: 100%;">
        <!-- Header con selector de contexto -->
        <div style="padding: 16px; border-bottom: 1px solid var(--border-soft, #334155); background: var(--bg-card, #1e293b);">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2 style="margin: 0; color: var(--text-primary, #fff);">Preview Efectivo</h2>
            <div style="display: flex; gap: 12px; align-items: center;">
              <label style="color: var(--text-muted, #94a3b8); font-size: 13px;">Contexto:</label>
              <select id="preview-context-select" class="nav-form-select" style="width: 200px;" onchange="reloadPreviewEffective()">
                <option value="">Base</option>
                ${availableContextKeys.map(key => `<option value="${escapeHtml(key)}" ${key === contextKey ? 'selected' : ''}>${escapeHtml(key)}</option>`).join('')}
              </select>
              <button onclick="fitPreviewToView()" class="nav-btn-icon" title="Ajustar vista">üìê Fit</button>
            </div>
          </div>
          ${warnings.length > 0 ? `
            <div class="nav-error-banner" style="display: block; margin-top: 12px;">
              ‚ö†Ô∏è Warnings (${warnings.length}): ${warnings.map(w => escapeHtml(typeof w === 'string' ? w : w.message || 'Warning')).join('; ')}
            </div>
          ` : ''}
          ${contextKey ? `
            <div style="margin-top: 8px; font-size: 12px; color: var(--text-muted, #94a3b8);">
              Contexto activo: <strong>${escapeHtml(contextKey)}</strong> | Entry: <strong>${escapeHtml(effectiveDef.entry_node_id || 'N/A')}</strong>
            </div>
          ` : `
            <div style="margin-top: 8px; font-size: 12px; color: var(--text-muted, #94a3b8);">
              Mostrando navegaci√≥n base | Entry: <strong>${escapeHtml(effectiveDef.entry_node_id || 'N/A')}</strong>
            </div>
          `}
        </div>
        <!-- Canvas read-only -->
        <div id="preview-canvas-container" style="flex: 1; overflow: hidden; position: relative;">
          ${renderPreviewCanvas(effectiveDef, warnings, contextKey)}
        </div>
      </div>
    `;

    // Inicializar interacciones del canvas (zoom, pan)
    setupPreviewCanvasInteractions();
  }

  function renderPreviewCanvas(effectiveDef, warnings, contextKey) {
    const nodes = effectiveDef.nodes || {};
    const edges = effectiveDef.edges || [];
    const provenance = effectiveDef.meta?.provenance || {};

    // Convertir a formato canvas
    const canvasNodes = Object.values(nodes).map(node => ({
      id: node.id,
      label: node.label || node.id,
      type: node.type,
      kind: node.kind,
      position: node.position || { x: 120, y: 120 },
      provenance: provenance.nodeId?.[node.id] || 'base'
    }));

    const canvasEdges = edges.map(edge => ({
      id: edge.id || `e_${edge.from}__${edge.to}`,
      from: edge.from,
      to: edge.to,
      kind: edge.kind || 'child',
      provenance: provenance.edgeIdx?.[`${edge.from}:${edge.to}:${edge.kind || 'child'}`] || 'base'
    }));

    // Renderizar HTML
    let html = `
      <div id="preview-canvas-viewport" class="nav-canvas-viewport" style="cursor: grab;">
        <div id="preview-canvas-stage" class="nav-canvas-stage" style="transform: translate(0px, 0px) scale(1);">
    `;

    // Renderizar nodos
    canvasNodes.forEach(node => {
      const provenanceClass = node.provenance === 'contextual' ? 'nav-node-contextual' : 'nav-node-base';
      html += `
        <div class="nav-node ${provenanceClass}" 
             style="left: ${node.position.x}px; top: ${node.position.y}px; cursor: default;"
             title="Provenance: ${node.provenance}">
          <div class="nav-node-label">${escapeHtml(node.label)}</div>
          <div class="nav-node-meta">${node.type || node.kind || 'node'}</div>
          ${node.provenance === 'contextual' ? '<div style="position: absolute; top: 4px; right: 4px; font-size: 10px; background: var(--accent-primary, #3b82f6); color: #fff; padding: 2px 4px; border-radius: 2px;">CTX</div>' : ''}
        </div>
      `;
    });

    html += `
        </div>
        <svg id="preview-edges-svg" class="nav-edges-svg"></svg>
      </div>
    `;

    // Renderizar edges (despu√©s de que el DOM est√© listo)
    setTimeout(() => {
      renderPreviewEdges(canvasNodes, canvasEdges);
    }, 0);

    return html;
  }

  function renderPreviewEdges(nodes, edges) {
    const svg = document.getElementById('preview-edges-svg');
    if (!svg) return;

    svg.innerHTML = '';

    // Definir marker para flecha
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    marker.setAttribute('id', 'preview-arrowhead');
    marker.setAttribute('markerWidth', '10');
    marker.setAttribute('markerHeight', '10');
    marker.setAttribute('refX', '9');
    marker.setAttribute('refY', '3');
    marker.setAttribute('orient', 'auto');
    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    polygon.setAttribute('points', '0 0, 10 3, 0 6');
    const computedStyle = getComputedStyle(document.documentElement);
    const strokeColor = computedStyle.getPropertyValue('--text-muted').trim() || '#64748b';
    polygon.setAttribute('fill', strokeColor);
    marker.appendChild(polygon);
    defs.appendChild(marker);
    svg.appendChild(defs);

    // Renderizar l√≠neas
    edges.forEach(edge => {
      const sourceNode = nodes.find(n => n.id === edge.from);
      const targetNode = nodes.find(n => n.id === edge.to);
      
      if (!sourceNode || !targetNode) return;

      const x1 = sourceNode.position.x + 60;
      const y1 = sourceNode.position.y + 30;
      const x2 = targetNode.position.x + 60;
      const y2 = targetNode.position.y + 30;

      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('marker-end', 'url(#preview-arrowhead)');
      if (edge.provenance === 'contextual') {
        line.setAttribute('stroke', '#3b82f6');
        line.setAttribute('stroke-width', '3');
      }
      svg.appendChild(line);
    });
  }

  function setupPreviewCanvasInteractions() {
    const viewport = document.getElementById('preview-canvas-viewport');
    const stage = document.getElementById('preview-canvas-stage');
    if (!viewport || !stage) return;

    let panX = 0, panY = 0, zoom = 1;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };

    // Pan
    viewport.addEventListener('mousedown', (e) => {
      if (e.target === viewport || e.target === stage) {
        isPanning = true;
        panStart = { x: e.clientX - panX, y: e.clientY - panY };
        viewport.style.cursor = 'grabbing';
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (isPanning) {
        panX = e.clientX - panStart.x;
        panY = e.clientY - panStart.y;
        updatePreviewTransform();
      }
    });

    document.addEventListener('mouseup', () => {
      if (isPanning) {
        isPanning = false;
        viewport.style.cursor = 'grab';
      }
    });

    // Zoom: SOLO con CTRL + rueda
    viewport.addEventListener('wheel', (e) => {
      if (!e.ctrlKey) return;
      e.preventDefault();
      
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      const worldX = (mouseX - panX) / zoom;
      const worldY = (mouseY - panY) / zoom;
      
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      zoom = Math.max(0.3, Math.min(3, zoom * delta));
      
      panX = mouseX - worldX * zoom;
      panY = mouseY - worldY * zoom;
      
      updatePreviewTransform();
    }, { passive: false });

    function updatePreviewTransform() {
      stage.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
      const svg = document.getElementById('preview-edges-svg');
      if (svg) {
        svg.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
      }
    }

    // Guardar estado para fitToView
    window.previewCanvasState = { panX, panY, zoom, updateTransform: updatePreviewTransform };
  }

  function fitPreviewToView() {
    const viewport = document.getElementById('preview-canvas-viewport');
    const stage = document.getElementById('preview-canvas-stage');
    if (!viewport || !stage) return;

    const nodes = stage.querySelectorAll('.nav-node');
    if (nodes.length === 0) return;

    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    nodes.forEach(node => {
      const rect = node.getBoundingClientRect();
      const stageRect = stage.getBoundingClientRect();
      const x = rect.left - stageRect.left;
      const y = rect.top - stageRect.top;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x + rect.width);
      maxY = Math.max(maxY, y + rect.height);
    });

    const width = maxX - minX;
    const height = maxY - minY;
    const padding = 60;

    const viewportWidth = viewport.clientWidth;
    const viewportHeight = viewport.clientHeight;

    const zoomX = (viewportWidth - padding * 2) / width;
    const zoomY = (viewportHeight - padding * 2) / height;
    const newZoom = Math.max(0.3, Math.min(3, Math.min(zoomX, zoomY)));

    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;

    if (window.previewCanvasState) {
      window.previewCanvasState.zoom = newZoom;
      window.previewCanvasState.panX = viewportWidth / 2 - centerX * newZoom;
      window.previewCanvasState.panY = viewportHeight / 2 - centerY * newZoom;
      window.previewCanvasState.updateTransform();
    }
  }

  function reloadPreviewEffective() {
    renderPreviewView();
  }

  // Exponer funciones globalmente
  window.reloadPreviewEffective = reloadPreviewEffective;
  window.fitPreviewToView = fitPreviewToView;

  function copiarJSON() {
    const navDef = convertCanvasToNavDef();
    const jsonStr = JSON.stringify(navDef, null, 2);
    navigator.clipboard.writeText(jsonStr).then(() => {
      showToast('‚úì JSON copiado al portapapeles', 'success');
    });
  }

  // ========================================================================
  // WARNINGS SYSTEM
  // ========================================================================
  function computeNavWarnings(navDef) {
    const warnings = {
      global: [],
      nodes: {},
      edges: {}
    };
    
    if (!navDef) return warnings;
    
    const nodes = navDef.nodes || {};
    const edges = navDef.edges || [];
    const entryNodeId = navDef.entry_node_id;
    
    // Global: No hay entry/home
    if (!entryNodeId) {
      warnings.global.push('No hay entry_node_id definido');
    } else if (!nodes[entryNodeId]) {
      warnings.global.push(`Entry node "${entryNodeId}" no existe en nodes`);
    }
    
    // Global: Home sin salidas
    if (entryNodeId && nodes[entryNodeId]) {
      const entryOutbound = edges.filter(e => e.from === entryNodeId);
      if (entryOutbound.length === 0) {
        warnings.global.push('Nodo de entrada no tiene salidas');
      }
    }
    
    // Por nodo: hu√©rfanos (sin inbound y no es entry)
    const nodeIds = Object.keys(nodes);
    nodeIds.forEach(nodeId => {
      if (nodeId === entryNodeId) return; // Entry puede no tener inbound
      
      const inbound = edges.filter(e => e.to === nodeId);
      if (inbound.length === 0) {
        if (!warnings.nodes[nodeId]) warnings.nodes[nodeId] = [];
        warnings.nodes[nodeId].push('Nodo hu√©rfano (sin conexiones entrantes)');
      }
    });
    
    // Por nodo: sin outbound (y no es terminal por semantic_type)
    nodeIds.forEach(nodeId => {
      const node = nodes[nodeId];
      const outbound = edges.filter(e => e.from === nodeId);
      const isTerminal = node?.type === 'return' || node?.type === 'external';
      
      if (outbound.length === 0 && !isTerminal && nodeId !== entryNodeId) {
        if (!warnings.nodes[nodeId]) warnings.nodes[nodeId] = [];
        warnings.nodes[nodeId].push('Nodo sin salidas (puede ser terminal)');
      }
    });
    
    // Por edge: apunta a nodo inexistente
    edges.forEach(edge => {
      if (!nodes[edge.from]) {
        if (!warnings.edges[edge.id || `${edge.from}__${edge.to}`]) {
          warnings.edges[edge.id || `${edge.from}__${edge.to}`] = [];
        }
        warnings.edges[edge.id || `${edge.from}__${edge.to}`].push(`Edge desde nodo inexistente: ${edge.from}`);
      }
      if (!nodes[edge.to]) {
        if (!warnings.edges[edge.id || `${edge.from}__${edge.to}`]) {
          warnings.edges[edge.id || `${edge.from}__${edge.to}`] = [];
        }
        warnings.edges[edge.id || `${edge.from}__${edge.to}`].push(`Edge hacia nodo inexistente: ${edge.to}`);
      }
    });
    
    // Detectar duplicidades (por normalize)
    const edgeKeys = new Set();
    edges.forEach(edge => {
      const key = `${edge.from}|${edge.to}|${edge.kind || 'child'}`;
      if (edgeKeys.has(key)) {
        if (!warnings.edges[edge.id || `${edge.from}__${edge.to}`]) {
          warnings.edges[edge.id || `${edge.from}__${edge.to}`] = [];
        }
        warnings.edges[edge.id || `${edge.from}__${edge.to}`].push('Edge duplicado');
      }
      edgeKeys.add(key);
    });
    
    console.log('[AXE][NAV2] warnings computed:', {
      global: warnings.global.length,
      nodes: Object.keys(warnings.nodes).length,
      edges: Object.keys(warnings.edges).length
    });
    
    return warnings;
  }
  
  function computeAndRenderWarnings() {
    const navDef = convertCanvasToNavDef();
    navState.warnings = computeNavWarnings(navDef);
    renderWarningsPanel();
    
    // Actualizar badge de warnings en toolbar
    const totalWarnings = navState.warnings.global.length + 
      Object.values(navState.warnings.nodes).reduce((sum, arr) => sum + arr.length, 0) +
      Object.values(navState.warnings.edges).reduce((sum, arr) => sum + arr.length, 0);
    
    updateWarningsBadge(totalWarnings);
    
    // Si hay nodo seleccionado, actualizar diagn√≥stico
    if (navState.selectedNodeId) {
      const diagnosticsEl = document.getElementById('node-diagnostics-content');
      if (diagnosticsEl) {
        const node = navState.canvas.nodes.find(n => n.id === navState.selectedNodeId);
        if (node) {
          diagnosticsEl.innerHTML = renderNodeDiagnostics(node);
        }
      }
    }
  }
  
  function renderWarningsPanel() {
    const warningsPanel = document.getElementById('nav-warnings');
    if (!warningsPanel) return;
    
    const totalWarnings = navState.warnings.global.length + 
      Object.values(navState.warnings.nodes).reduce((sum, arr) => sum + arr.length, 0) +
      Object.values(navState.warnings.edges).reduce((sum, arr) => sum + arr.length, 0);
    
    if (totalWarnings === 0) {
      warningsPanel.innerHTML = '<div class="nav-warnings-empty">‚úì Sin warnings</div>';
      return;
    }
    
    let html = '<div class="nav-warnings-header">‚ö†Ô∏è Warnings (' + totalWarnings + ')</div>';
    
    // Global warnings
    if (navState.warnings.global.length > 0) {
      html += '<div class="nav-warnings-section"><strong>Global:</strong><ul>';
      navState.warnings.global.forEach(w => {
        html += `<li class="nav-warning-item">${escapeHtml(w)}</li>`;
      });
      html += '</ul></div>';
    }
    
    // Node warnings (solo para nodos seleccionados o visibles)
    const selectedNodeWarnings = navState.selectedNodeId ? navState.warnings.nodes[navState.selectedNodeId] : [];
    if (selectedNodeWarnings && selectedNodeWarnings.length > 0) {
      html += `<div class="nav-warnings-section"><strong>Nodo seleccionado:</strong><ul>`;
      selectedNodeWarnings.forEach(w => {
        html += `<li class="nav-warning-item">${escapeHtml(w)}</li>`;
      });
      html += '</ul></div>';
    }
    
    warningsPanel.innerHTML = html;
  }
  
  function updateWarningsBadge(count) {
    // Buscar o crear badge en toolbar
    let badge = document.getElementById('warnings-badge');
    if (!badge && count > 0) {
      const toolbar = document.querySelector('.nav-toolbar-right');
      if (toolbar) {
        badge = document.createElement('span');
        badge.id = 'warnings-badge';
        badge.className = 'nav-badge nav-badge-warning';
        badge.style.marginLeft = '8px';
        toolbar.insertBefore(badge, toolbar.firstChild);
      }
    }
    if (badge) {
      badge.textContent = `‚ö†Ô∏è ${count}`;
      badge.style.display = count > 0 ? 'inline-block' : 'none';
    }
  }
  
  // ========================================================================
  // MULTI-SELECTION & BOX-SELECT
  // ========================================================================
  function startBoxSelect(e) {
    if (!e.shiftKey) return; // Solo con Shift
    
    navState.isBoxSelecting = true;
    const viewport = document.getElementById('nav-canvas-viewport');
    const rect = viewport.getBoundingClientRect();
    navState.boxSelectStart = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
    
    // Crear overlay de selecci√≥n
    let boxOverlay = document.getElementById('nav-box-select-overlay');
    if (!boxOverlay) {
      boxOverlay = document.createElement('div');
      boxOverlay.id = 'nav-box-select-overlay';
      boxOverlay.className = 'nav-box-select-overlay';
      viewport.appendChild(boxOverlay);
    }
    boxOverlay.style.display = 'block';
    updateBoxSelectOverlay(e);
    
    e.preventDefault();
    e.stopPropagation();
  }
  
  function updateBoxSelectOverlay(e) {
    if (!navState.isBoxSelecting) return;
    
    const viewport = document.getElementById('nav-canvas-viewport');
    const rect = viewport.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;
    
    const boxOverlay = document.getElementById('nav-box-select-overlay');
    if (!boxOverlay) return;
    
    const left = Math.min(navState.boxSelectStart.x, currentX);
    const top = Math.min(navState.boxSelectStart.y, currentY);
    const width = Math.abs(currentX - navState.boxSelectStart.x);
    const height = Math.abs(currentY - navState.boxSelectStart.y);
    
    boxOverlay.style.left = left + 'px';
    boxOverlay.style.top = top + 'px';
    boxOverlay.style.width = width + 'px';
    boxOverlay.style.height = height + 'px';
  }
  
  function endBoxSelect(e) {
    if (!navState.isBoxSelecting) return;
    
    navState.isBoxSelecting = false;
    const boxOverlay = document.getElementById('nav-box-select-overlay');
    if (boxOverlay) {
      boxOverlay.style.display = 'none';
    }
    
    // Calcular nodos dentro del rect√°ngulo
    const viewport = document.getElementById('nav-canvas-viewport');
    const rect = viewport.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;
    
    const boxLeft = Math.min(navState.boxSelectStart.x, currentX);
    const boxTop = Math.min(navState.boxSelectStart.y, currentY);
    const boxRight = Math.max(navState.boxSelectStart.x, currentX);
    const boxBottom = Math.max(navState.boxSelectStart.y, currentY);
    
    // Convertir a coordenadas del mundo (considerando pan y zoom)
    const worldBoxLeft = (boxLeft - navState.panX) / navState.zoom;
    const worldBoxTop = (boxTop - navState.panY) / navState.zoom;
    const worldBoxRight = (boxRight - navState.panX) / navState.zoom;
    const worldBoxBottom = (boxBottom - navState.panY) / navState.zoom;
    
    // Seleccionar nodos dentro del rect√°ngulo
    const selectedNodes = [];
    navState.canvas.nodes.forEach(node => {
      const nodeX = node.position.x;
      const nodeY = node.position.y;
      const nodeWidth = 120; // Aproximado
      const nodeHeight = 60; // Aproximado
      
      if (nodeX + nodeWidth >= worldBoxLeft && nodeX <= worldBoxRight &&
          nodeY + nodeHeight >= worldBoxTop && nodeY <= worldBoxBottom) {
        selectedNodes.push(node.id);
      }
    });
    
    if (selectedNodes.length > 0) {
      selectNodes(selectedNodes);
      console.log('[AXE][NAV2] box-select: ' + selectedNodes.length + ' nodes');
    } else {
      clearSelection();
    }
  }
  
  function deleteSelectedNodes() {
    if (navState.selectedNodeIds.length === 0) return;
    
    // Verificar si incluye entry/home
    const navDef = convertCanvasToNavDef();
    const includesEntry = navState.selectedNodeIds.includes(navDef.entry_node_id);
    
    if (includesEntry) {
      if (!confirm('‚ö†Ô∏è La selecci√≥n incluye el nodo de entrada. ¬øEst√°s seguro de eliminarlo?')) {
        return;
      }
    }
    
    // Eliminar nodos
    navState.selectedNodeIds.forEach(nodeId => {
      deleteNode(nodeId);
    });
    
    clearSelection();
  }
  
  // ========================================================================
  // DUPLICATE NODE & QUICK ACTIONS
  // ========================================================================
  function duplicateNode(nodeId) {
    const node = navState.canvas.nodes.find(n => n.id === nodeId);
    if (!node) return;
    
    const newId = `node_${Date.now()}`;
    const newNode = {
      ...node,
      id: newId,
      label: node.label + ' (copia)',
      position: {
        x: node.position.x + 40,
        y: node.position.y + 40
      }
    };
    
    // Asegurar que no se salga del canvas
    newNode.position.x = Math.max(0, newNode.position.x);
    newNode.position.y = Math.max(0, newNode.position.y);
    
    navState.canvas.nodes.push(newNode);
    markDirty();
    scheduleAutosave('node-duplicate');
    renderCanvas();
    selectNode(newId);
    console.log('[AXE][NAV2] duplicated node: ' + nodeId + ' -> ' + newId);
  }
  
  function markAsEntry(nodeId) {
    const navDef = convertCanvasToNavDef();
    navDef.entry_node_id = nodeId;
    navState.navDef = navDef;
    markDirty();
    scheduleAutosave('mark-entry');
    computeAndRenderWarnings();
    showToast('‚úì Marcado como Entry', 'success');
  }
  
  function markAsHome(nodeId) {
    const node = navState.canvas.nodes.find(n => n.id === nodeId);
    if (!node) return;
    
    node.type = 'home';
    markDirty();
    scheduleAutosave('mark-home');
    renderNodeProperties();
    computeAndRenderWarnings();
    showToast('‚úì Marcado como Home', 'success');
  }
  
  // ========================================================================
  // THEMES LIST (DYNAMIC)
  // ========================================================================
  async function loadThemesList() {
    try {
      const response = await fetch('/admin/api/themes');
      if (!response.ok) {
        throw new Error('Error al cargar temas');
      }
      
      const data = await response.json();
      const themes = data.themes || [];
      
      const themeSelect = document.getElementById('theme-select');
      if (!themeSelect) return;
      
      // Guardar opciones actuales (Auto, Classic)
      const currentValue = themeSelect.value;
      const autoOption = themeSelect.querySelector('option[value="auto"]');
      const lightClassicOption = themeSelect.querySelector('option[value="light-classic"]');
      const darkClassicOption = themeSelect.querySelector('option[value="dark-classic"]');
      
      // Limpiar select (excepto Auto)
      themeSelect.innerHTML = '';
      if (autoOption) themeSelect.appendChild(autoOption);
      if (lightClassicOption) themeSelect.appendChild(lightClassicOption);
      if (darkClassicOption) themeSelect.appendChild(darkClassicOption);
      
      // A√±adir temas din√°micos
      if (themes.length > 0) {
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = '--- Temas del sistema ---';
        themeSelect.appendChild(separator);
        
        themes.forEach(theme => {
          const option = document.createElement('option');
          option.value = theme.id;
          option.textContent = theme.name || theme.id;
          themeSelect.appendChild(option);
        });
        
        console.log('[AXE][NAV2] theme list loaded: ' + themes.length);
      }
      
      // Restaurar valor seleccionado
      themeSelect.value = currentValue;
    } catch (error) {
      console.error('[AXE][NAV2] Error cargando lista de temas:', error);
      // Fail-open: mantener opciones actuales
      console.log('[AXE][NAV2] theme list failed, usando fallback');
    }
  }
  
  // ========================================================================
  // HELPERS
  // ========================================================================
  function createMinimalNavigation() {
    navState.navDef = {
      navigation_id: navState.navigationId || 'new',
      name: 'Nueva Navegaci√≥n',
      entry_node_id: 'home',
      nodes: {
        home: {
          id: 'home',
          kind: 'section',
          type: 'home',
          label: 'Home',
          position: { x: 120, y: 120 }
        }
      },
      edges: []
    };
    convertNavDefToCanvas(navState.navDef);
  }

  function a√±adirNodo() {
    const newNodeId = `node-${Date.now()}`;
    const newNode = {
      id: newNodeId,
      label: 'Nuevo Nodo',
      type: 'view',
      kind: 'item',
      position: { x: 200, y: 200 }
    };
    navState.canvas.nodes.push(newNode);
    markDirty();
    scheduleAutosave('node-create');
    renderCanvas();
    selectNode(newNodeId);
  }

  function markDirty() {
    checkDirtyState();
    updateUI();
  }

  function updateUI() {
    const dirtyBadge = document.getElementById('dirty-badge');
    const savedBadge = document.getElementById('save-status-badge');
    const publishBtn = document.getElementById('btn-publish');
    
    if (dirtyBadge) dirtyBadge.style.display = navState.isDirty ? 'inline-block' : 'none';
    if (savedBadge) savedBadge.style.display = !navState.isDirty ? 'inline-block' : 'none';
    
    // Deshabilitar bot√≥n Publicar si hay cambios sin guardar
    if (publishBtn) {
      publishBtn.disabled = navState.isDirty;
      publishBtn.title = navState.isDirty 
        ? 'Publicar navegaci√≥n (requiere guardar cambios primero)' 
        : 'Publicar navegaci√≥n';
    }
    
    updatePublishedStatus();
  }

  function updatePublishedStatus() {
    const publishedBadge = document.getElementById('published-status-badge');
    if (publishedBadge) {
      if (navState.publishedVersion) {
        publishedBadge.textContent = `üì¶ Published: v${navState.publishedVersion.version}`;
        publishedBadge.style.display = 'inline-block';
      } else {
        publishedBadge.textContent = 'üì¶ Draft';
        publishedBadge.style.display = 'inline-block';
      }
    }
  }

  function showError(message) {
    const banner = document.getElementById('error-banner');
    if (banner) {
      banner.textContent = '‚ö†Ô∏è ' + message;
      banner.style.display = 'block';
    }
    console.error('[AXE][NAV2]', message);
  }

  function showToast(message, type = 'info') {
    // Toast simple
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      background: ${type === 'success' ? '#059669' : type === 'error' ? '#dc2626' : '#475569'};
      color: #fff;
      border-radius: 6px;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 3000);
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function renderNodePropertiesHTML() {
    const node = navState.canvas.nodes.find(n => n.id === navState.selectedNodeId);
    if (!node) return '<p>No hay nodo seleccionado</p>';

    return `
      <div class="nav-form-group">
        <label class="nav-form-label">ID</label>
        <input type="text" class="nav-form-input" value="${escapeHtml(node.id)}" readonly>
      </div>
      <div class="nav-form-group">
        <label class="nav-form-label">Label</label>
        <input type="text" class="nav-form-input" value="${escapeHtml(node.label || '')}" 
               onchange="updateNodeProperty('label', this.value)">
      </div>
      <div class="nav-form-group">
        <label class="nav-form-label">Type</label>
        <select class="nav-form-select" onchange="updateNodeProperty('type', this.value)">
          <option value="home" ${node.type === 'home' ? 'selected' : ''}>Home</option>
          <option value="section" ${node.type === 'section' ? 'selected' : ''}>Section</option>
          <option value="view" ${node.type === 'view' ? 'selected' : ''}>View</option>
          <option value="external" ${node.type === 'external' ? 'selected' : ''}>External</option>
        </select>
      </div>
    `;
  }

  // ========================================================================
  // INICIALIZAR AL CARGAR
  // ========================================================================
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initNavigationEditor);
  } else {
    initNavigationEditor();
  }
</script>
